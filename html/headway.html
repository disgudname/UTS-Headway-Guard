<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="/media/favicon.ico" />
  <link rel="apple-touch-icon" sizes="120x120" href="/media/apple-touch-icon-120.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/media/apple-touch-icon-152.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/media/apple-touch-icon-180.png" />
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#E57200">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Headway Explorer</title>
  <script defer src="/nav-bar.js"></script>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 0;
      background: #0d0d0d;
      color: #f5f5f5;
      line-height: 1.5;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      background: linear-gradient(120deg, #12345b, #0f1f3a);
      padding: 1.5rem 0;
      color: #e6f0ff;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .content-width {
      width: min(1200px, calc(100% - 2.5rem));
      margin: 0 auto;
      box-sizing: border-box;
    }
    .header-inner {
      padding: 0 0.5rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.8rem;
      letter-spacing: 0.02em;
    }
    header p {
      margin: 0.25rem 0 0;
      color: #b9d4ff;
    }
    main {
      padding: 2rem 0;
      flex: 1;
      width: min(1200px, calc(100% - 2.5rem));
      margin: 0 auto;
      display: grid;
      gap: 1.5rem;
    }
    .card {
      background: #161616;
      border: 1px solid #222;
      border-radius: 10px;
      padding: 1.25rem;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.25);
    }
    .card h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: 1.2rem;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem 1.5rem;
      align-items: start;
    }
    label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.4rem;
      color: #d9e2ff;
    }
    input, select, button {
      width: 100%;
      box-sizing: border-box;
      border-radius: 8px;
      border: 1px solid #2d2d2d;
      background: #0f0f0f;
      color: #f3f4f6;
      padding: 0.6rem 0.75rem;
      font-size: 0.95rem;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }
    select[multiple] {
      height: 12rem;
    }
    button {
      background: linear-gradient(120deg, #1f7aff, #16a1ff);
      border: none;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      box-shadow: 0 6px 18px rgba(31, 122, 255, 0.35);
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 28px rgba(31, 122, 255, 0.45);
    }
    button.secondary {
      background: #202020;
      border: 1px solid #2b2b2b;
      box-shadow: none;
    }
    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 0.5rem;
    }
    .status {
      margin-top: 0.75rem;
      color: #9fb7ff;
      font-size: 0.95rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      background: #0f0f0f;
      border-radius: 10px;
      overflow: hidden;
    }
    th, td {
      padding: 0.65rem 0.75rem;
      border-bottom: 1px solid #1f1f1f;
      text-align: left;
    }
    th {
      background: #111827;
      color: #e5edff;
      font-weight: 700;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    tr:nth-child(even) td { background: #131313; }
    tr:hover td { background: #1a1a1a; }
    .pill {
      display: inline-block;
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      background: #1f2937;
      color: #cde2ff;
      font-size: 0.8rem;
      border: 1px solid #253041;
      margin-left: 0.35rem;
    }
    .empty-state {
      padding: 1rem;
      background: #111;
      border: 1px dashed #2d2d2d;
      border-radius: 8px;
      color: #9ca3af;
      text-align: center;
    }
    .highlight-row td {
      background: #3a0d0d;
      color: #ffdede;
    }
    .highlight-row:hover td {
      background: #4a1010;
    }
    @media (max-width: 640px) {
      select[multiple] { height: 10rem; }
    }
    /* Disclaimer Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 1rem;
    }
    .modal-overlay.hidden {
      display: none;
    }
    .modal {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 12px;
      max-width: 640px;
      max-height: 80vh;
      overflow-y: auto;
      padding: 1.5rem;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
    }
    .modal h2 {
      margin-top: 0;
      color: #fca5a5;
      font-size: 1.3rem;
    }
    .modal h3 {
      color: #fde68a;
      font-size: 1rem;
      margin: 1.25rem 0 0.5rem;
    }
    .modal ul {
      margin: 0;
      padding-left: 1.5rem;
      color: #d1d5db;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    .modal li {
      margin-bottom: 0.35rem;
    }
    .modal-close {
      margin-top: 1.25rem;
      background: linear-gradient(120deg, #1f7aff, #16a1ff);
      border: none;
      color: #fff;
      font-weight: 700;
      padding: 0.6rem 1.5rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.95rem;
    }
    .modal-close:hover {
      opacity: 0.9;
    }
    .disclaimer-link {
      font-size: 0.85rem;
      color: #9fb7ff;
      cursor: pointer;
      text-decoration: underline;
      margin-left: 1rem;
    }
    .disclaimer-link:hover {
      color: #c4d5ff;
    }
  </style>
</head>
<body>
  <div class="modal-overlay" id="disclaimer-modal">
    <div class="modal">
      <h2>Data Disclaimer</h2>
      <h3>Vehicle assignment issues:</h3>
      <ul>
        <li>Unassigned/out-of-service buses (startups and OOS blocks)</li>
        <li>Switches – might look like a gap or duplicate</li>
      </ul>
      <h3>GPS/detection issues:</h3>
      <ul>
        <li>GPS drift may cause false arrivals/departures (we attempt to avoid this but are ultimately dependent on the data TransLoc provides)</li>
        <li>Unusual stop approaches (e.g. detours) might not trigger the approach bubble detection</li>
        <li>Traffic congestion – bus might be moving &lt; 0.5 m/s but not actually at the stop</li>
      </ul>
      <h3>Operational edge cases:</h3>
      <ul>
        <li>Detours around construction – stops on detour path get missed</li>
        <li>Deadheading – bus passes stop without stopping while still marked as in service, will register as a 0s dwell</li>
        <li>Layovers at timestops – very long dwell times could skew stats</li>
      </ul>
      <h3>Data boundary issues:</h3>
      <ul>
        <li>Arrivals might not be detected if bus arrives at stop while marked as out of service</li>
        <li>Departures might not be detected if bus is marked as out of service while at stop</li>
        <li>Server restarts/API outages/whatever else TransLoc throws at us create gaps in data</li>
      </ul>
      <h3>Filtering blind spots:</h3>
      <ul>
        <li>Only tracking configured routes/stops – truly new stops might not be in config. Existing stops added to routes should be accounted for but may not be.</li>
      </ul>
      <button class="modal-close" id="disclaimer-close">I understand</button>
    </div>
  </div>
  <header>
    <div class="content-width header-inner">
      <h1>Headway Explorer</h1>
      <p>Select routes, stops, and a window to inspect recorded headway events. <span class="disclaimer-link" id="show-disclaimer">View data disclaimer</span></p>
    </div>
  </header>
  <main class="content-width">
    <section class="card">
      <h2>Filters</h2>
      <div class="grid">
        <div>
          <label for="from-date">From date</label>
          <input type="date" id="from-date" />
        </div>
        <div>
          <label for="from-time">From time</label>
          <input type="time" id="from-time" step="60" />
        </div>
        <div>
          <label for="to-date">To date</label>
          <input type="date" id="to-date" />
        </div>
        <div>
          <label for="to-time">To time</label>
          <input type="time" id="to-time" step="60" />
        </div>
      </div>
      <div class="grid" style="margin-top: 1rem;">
        <div>
          <label for="route-select">Routes (select one or more)</label>
          <select id="route-select" multiple></select>
        </div>
        <div>
          <label for="stop-select">Stops (select one or more)</label>
          <select id="stop-select" multiple></select>
        </div>
        <div>
          <label for="headway-type">Headway type</label>
          <select id="headway-type">
            <option value="arrival_arrival" selected>Arrival to arrival</option>
            <option value="departure_arrival">Departure to arrival</option>
          </select>
        </div>
        <div>
          <label for="highlight-threshold">Highlight Above (min)</label>
          <input type="number" id="highlight-threshold" min="0" step="1" placeholder="e.g. 15" />
        </div>
      </div>
      <div class="actions">
        <button id="load-btn">Load headway</button>
        <button id="export-btn" class="secondary">Export CSV</button>
        <button id="clear-btn" class="secondary">Clear selections</button>
      </div>
      <div class="status" id="status">Loading routes and stops…</div>
    </section>

    <section class="card">
      <h2>Results</h2>
      <div id="summary" class="status"></div>
      <div id="results-container">
        <div class="empty-state">No data loaded yet.</div>
      </div>
    </section>
  </main>

  <script>
    const routeSelect = document.getElementById('route-select');
    const stopSelect = document.getElementById('stop-select');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');
    const resultsContainer = document.getElementById('results-container');
    const headwayTypeSelect = document.getElementById('headway-type');
    const highlightInput = document.getElementById('highlight-threshold');

    let allRoutes = [];
    let allStops = [];
    let routeNameById = new Map();
    let stopNameById = new Map();
    let stopIdsByCanonical = new Map();
    let vehicleNameById = new Map();

    function formatRouteLabel(route) {
      const id = route.RouteID ?? route.RouteId ?? route.id ?? '';
      const name = route.RouteName || route.Description || route.LongName || route.ShortName || `Route ${id}`;
      const short = route.ShortName || route.InfoText;
      return short && short !== name ? `${name} (${short})` : name;
    }

    function collectStopIds(stop) {
      return [
        stop.StopID,
        stop.StopId,
        stop.stop_id,
        stop.Stop?.StopID,
        stop.Stop?.StopId,
        stop.RouteStopID,
        stop.RouteStopId,
        stop.AddressID,
        stop.AddressId,
        stop.address_id,
        stop.id,
      ].filter(id => id !== undefined && id !== null);
    }

    function getStopId(stop) {
      const candidates = collectStopIds(stop);
      return candidates.length ? candidates[0] : null;
    }

    function normalizeStopName(stop) {
      const name = stop.Name || stop.Description || stop.StopName || '';
      return name.trim().toLowerCase();
    }

    function getStopCoords(stop) {
      const lat = stop.Latitude ?? stop.latitude ?? stop.lat ?? stop.StopLat ?? stop.StopLatitude ?? stop.Lat;
      const lon = stop.Longitude ?? stop.longitude ?? stop.lon ?? stop.Lon ?? stop.StopLon ?? stop.StopLongitude ?? stop.Lng;
      if (lat == null || lon == null || Number.isNaN(Number(lat)) || Number.isNaN(Number(lon))) return null;
      return { lat: Number(lat), lon: Number(lon) };
    }

    function getStopKey(stop) {
      const id = getStopId(stop);
      const name = normalizeStopName(stop);
      const coords = getStopCoords(stop);
      if (name && coords) return `${name}|${coords.lat.toFixed(5)},${coords.lon.toFixed(5)}`;
      if (coords) return `coords:${coords.lat.toFixed(5)},${coords.lon.toFixed(5)}`;
      if (name) return `name:${name}`;
      return id != null ? `id:${id}` : null;
    }

    function formatStopLabel(stop) {
      const id = getStopId(stop) ?? '';
      const name = stop.Name || stop.Description || stop.StopName || `Stop ${id}`;
      const routeIds = new Set([
        ...(stop.RouteIDs || stop.RouteIds || stop.RouteIds || stop.Routes || []),
        ...(stop._routeIds || []),
      ]
        .map(r => (typeof r === 'object' ? (r.RouteID ?? r.RouteId ?? r.id) : r))
        .filter(Boolean)
        .map(String));
      const routes = Array.from(routeIds);
      return routes.length ? `${name} — ${routes.join(', ')}` : name;
    }

    function getRouteName(id) {
      if (!id) return '';
      const key = String(id);
      return routeNameById.get(key) || `Route ${key}`;
    }

    function getStopName(id) {
      if (!id) return '';
      const key = String(id);
      return stopNameById.get(key) || `Stop ${key}`;
    }

    function pickVehicleName(record) {
      if (!record) return '';
      return (
        record.vehicle_name ||
        record.Name ||
        record.VehicleName ||
        record.vehicle_label ||
        record.vehicle_fleet_no ||
        record.vehicle_no ||
        ''
      );
    }

    function updateVehicleNameLookup(events = [], vehicleNames = null) {
      if (vehicleNames && typeof vehicleNames === 'object') {
        Object.entries(vehicleNames).forEach(([id, name]) => {
          if (id == null || !name) return;
          vehicleNameById.set(String(id), String(name));
        });
      }
      events.forEach(ev => {
        const id = ev.vehicle_id || ev.vehicle;
        const name = ev.vehicle_name || pickVehicleName(ev);
        if (id == null || !name) return;
        vehicleNameById.set(String(id), String(name));
      });
    }

    async function refreshVehicleRoster() {
      try {
        const res = await fetch('/v1/vehicles?include_stale=1&include_unassigned=1');
        if (!res.ok) throw new Error(`Vehicle roster fetch failed (${res.status})`);
        const data = await res.json();
        const rosterNames = (Array.isArray(data.vehicles) ? data.vehicles : []).reduce((acc, entry) => {
          const id = entry.VehicleID ?? entry.VehicleId ?? entry.id;
          const name = entry.name || entry.Name;
          if (id != null && name) acc[id] = name;
          return acc;
        }, {});
        updateVehicleNameLookup([], rosterNames);
      } catch (err) {
        console.warn('Unable to refresh vehicle roster for name lookup', err);
      }
    }

    function formatVehicleLabel(ev) {
      const directLabel = ev?.vehicle_name || pickVehicleName(ev);
      if (directLabel) return directLabel;
      const id = ev.vehicle_id || ev.vehicle;
      if (!id) return '';
      const nameFromMap = vehicleNameById.get(String(id));
      if (nameFromMap) return nameFromMap;
      return `Vehicle ${id}`;
    }

    function formatMinutesSeconds(seconds) {
      if (seconds == null || Number.isNaN(Number(seconds))) return '';
      const total = Number(seconds);
      const minutes = Math.floor(total / 60);
      const secs = Math.round((total % 60) * 10) / 10;
      const paddedSeconds = secs < 10 ? `0${secs.toFixed(secs % 1 === 0 ? 0 : 1)}` : secs.toFixed(secs % 1 === 0 ? 0 : 1);
      return `${minutes}m ${paddedSeconds}s`;
    }

    function formatTime24(date) {
      return date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
    }

    function formatDateTime24(date) {
      return date.toLocaleDateString() + ' ' + formatTime24(date);
    }

    // Data point counting mode:
    // 'arrivals' = count arrivals only (each arrival = one bus visit)
    // 'individual' = count each arrival and departure as separate data points
    const DATA_POINT_COUNT_MODE = 'arrivals';

    function countDataPoints(events) {
      if (DATA_POINT_COUNT_MODE === 'individual') {
        return events.length;
      }
      // Arrivals mode: count only arrival events (each arrival = one bus visit)
      return events.filter(ev => ev.event_type === 'arrival').length;
    }

    function calculateHeadwayStats(events, headwaySelectEl) {
      const headwayValues = events
        .map(ev => getHeadwayValue(ev, headwaySelectEl))
        .filter(hw => hw != null && !Number.isNaN(Number(hw)) && Number(hw) > 0);

      const dwellValues = events
        .map(ev => ev.dwell_seconds)
        .filter(dw => dw != null && !Number.isNaN(Number(dw)) && Number(dw) >= 0);

      let average = null, longest = null, stdDev = null;
      if (headwayValues.length > 0) {
        const sum = headwayValues.reduce((acc, v) => acc + v, 0);
        average = sum / headwayValues.length;
        longest = Math.max(...headwayValues);
        const squaredDiffs = headwayValues.map(v => Math.pow(v - average, 2));
        const avgSquaredDiff = squaredDiffs.reduce((acc, v) => acc + v, 0) / headwayValues.length;
        stdDev = Math.sqrt(avgSquaredDiff);
      }

      let dwellAverage = null, dwellLongest = null, dwellStdDev = null;
      if (dwellValues.length > 0) {
        const dwellSum = dwellValues.reduce((acc, v) => acc + v, 0);
        dwellAverage = dwellSum / dwellValues.length;
        dwellLongest = Math.max(...dwellValues);
        const dwellSquaredDiffs = dwellValues.map(v => Math.pow(v - dwellAverage, 2));
        const dwellAvgSquaredDiff = dwellSquaredDiffs.reduce((acc, v) => acc + v, 0) / dwellValues.length;
        dwellStdDev = Math.sqrt(dwellAvgSquaredDiff);
      }

      return {
        average,
        longest,
        stdDev,
        dwellAverage,
        dwellLongest,
        dwellStdDev,
        dataPoints: countDataPoints(events),
        headwayCount: headwayValues.length,
        dwellCount: dwellValues.length,
      };
    }

    function formatStatsDisplay(stats) {
      const parts = [];

      // Headway stats
      if (stats.headwayCount > 0) {
        const avgDisplay = stats.average != null ? formatMinutesSeconds(stats.average) : 'N/A';
        const longestDisplay = stats.longest != null ? formatMinutesSeconds(stats.longest) : 'N/A';
        const stdDevDisplay = stats.stdDev != null ? formatMinutesSeconds(stats.stdDev) : 'N/A';
        parts.push(`<strong>Avg headway:</strong> ${avgDisplay} · <strong>Longest:</strong> ${longestDisplay} · <strong>Std dev:</strong> ${stdDevDisplay}`);
      }

      // Dwell stats
      if (stats.dwellCount > 0) {
        const dwellAvgDisplay = stats.dwellAverage != null ? formatMinutesSeconds(stats.dwellAverage) : 'N/A';
        const dwellLongestDisplay = stats.dwellLongest != null ? formatMinutesSeconds(stats.dwellLongest) : 'N/A';
        const dwellStdDevDisplay = stats.dwellStdDev != null ? formatMinutesSeconds(stats.dwellStdDev) : 'N/A';
        parts.push(`<strong>Avg dwell:</strong> ${dwellAvgDisplay} · <strong>Longest:</strong> ${dwellLongestDisplay} · <strong>Std dev:</strong> ${dwellStdDevDisplay}`);
      }

      parts.push(`<strong>Data points:</strong> ${stats.dataPoints}`);

      return parts.join('<br>');
    }

    function resolveHeadwayField(selectEl) {
      return selectEl?.value === 'departure_arrival'
        ? 'headway_departure_arrival'
        : 'headway_arrival_arrival';
    }

    function getHeadwayValue(ev, selectEl) {
      const field = resolveHeadwayField(selectEl);
      if (ev[field] != null) return ev[field];
      if (field !== 'headway_arrival_arrival' && ev.headway_arrival_arrival != null) return ev.headway_arrival_arrival;
      if (ev.headway_seconds != null) return ev.headway_seconds;
      return null;
    }

    function setStatus(message, isError = false) {
      statusEl.textContent = message;
      statusEl.style.color = isError ? '#fca5a5' : '#9fb7ff';
    }

    function populateRoutes() {
      routeSelect.innerHTML = '';
      const frag = document.createDocumentFragment();
      allRoutes.forEach(route => {
        const opt = document.createElement('option');
        const id = route.RouteID ?? route.RouteId ?? route.id;
        opt.value = id;
        opt.textContent = formatRouteLabel(route);
        frag.appendChild(opt);
      });
      routeSelect.appendChild(frag);
    }

    function filteredStops(filterRoutes = []) {
      const filterSet = new Set(filterRoutes);
      return allStops.filter(stop => {
        if (!filterSet.size) return true;
        const routes = stop._routeIds || [];
        return routes.some(r => filterSet.has(String(r)));
      });
    }

    function populateStops(filterRoutes = []) {
      stopSelect.innerHTML = '';
      const frag = document.createDocumentFragment();
      filteredStops(filterRoutes).forEach(stop => {
        const id = getStopId(stop);
        if (!id) return;
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = formatStopLabel(stop);
        frag.appendChild(opt);
      });
      stopSelect.appendChild(frag);
    }

    function getSelected(selectEl) {
      return Array.from(selectEl.selectedOptions).map(opt => opt.value).filter(Boolean);
    }

    function setDefaults() {
      const now = new Date();
      const toDate = now.toISOString().slice(0, 10);
      const toTime = now.toTimeString().slice(0, 5);
      const from = new Date(now.getTime() - 60 * 60 * 1000);
      document.getElementById('to-date').value = toDate;
      document.getElementById('to-time').value = toTime;
      document.getElementById('from-date').value = from.toISOString().slice(0, 10);
      document.getElementById('from-time').value = from.toTimeString().slice(0, 5);
    }

    async function loadMetadata() {
      try {
        const res = await fetch('/v1/testmap/transloc/metadata');
        if (!res.ok) throw new Error(`Metadata fetch failed (${res.status})`);
        const data = await res.json();
        allRoutes = Array.isArray(data.routes) ? data.routes : [];
        const stopMap = new Map();
        (Array.isArray(data.stops) ? data.stops : []).forEach(stop => {
          const candidateIds = collectStopIds(stop);
          const id = candidateIds[0];
          const key = getStopKey(stop);
          if (!key || !id) return;
          const routes = new Set([
            ...(stop.RouteIds || stop.RouteIDs || stop.RouteIds || []),
            ...(Array.isArray(stop.Routes) ? stop.Routes.map(r => r.RouteID ?? r.RouteId ?? r.id) : []),
            stop.RouteID ?? stop.RouteId ?? stop.RouteId,
          ].filter(Boolean).map(String));
          const existing = stopMap.get(key) || { ...stop, _routeIds: [], _allIds: [] };
          const mergedRoutes = new Set([...(existing._routeIds || []), ...routes]);
          const mergedIds = new Set([...(existing._allIds || []), ...candidateIds.map(String)]);
          const canonicalId = getStopId(existing) ?? id;
          stopMap.set(key, {
            ...existing,
            ...stop,
            StopID: canonicalId,
            _routeIds: Array.from(mergedRoutes),
            _allIds: Array.from(mergedIds),
          });
        });
        allStops = Array.from(stopMap.values()).sort((a, b) => {
          const aName = formatStopLabel(a).toLowerCase();
          const bName = formatStopLabel(b).toLowerCase();
          return aName.localeCompare(bName);
        });
        routeNameById = new Map(
          allRoutes
            .map(route => {
              const id = route.RouteID ?? route.RouteId ?? route.id;
              if (id == null) return null;
              return [String(id), formatRouteLabel(route)];
            })
            .filter(Boolean)
        );
        vehicleNameById = new Map();
        stopIdsByCanonical = new Map();
        stopNameById = new Map();
        allStops.forEach(stop => {
          const id = getStopId(stop);
          if (id == null) return;
          const name = stop.Name || stop.Description || stop.StopName || formatStopLabel(stop);
          const ids = stop._allIds?.length ? stop._allIds.map(String) : collectStopIds(stop).map(String);
          if (!ids.length) ids.push(String(id));
          stopIdsByCanonical.set(String(id), ids);
          ids.forEach(mappedId => stopNameById.set(mappedId, name));
        });
        populateRoutes();
        populateStops();
        setStatus('Routes and stops loaded. Choose filters and load headway.');
        refreshVehicleRoster();
      } catch (err) {
        console.error(err);
        setStatus('Unable to load routes/stops. Try refreshing.', true);
      }
    }

    function combineDateTime(dateInputId, timeInputId) {
      const dateVal = document.getElementById(dateInputId).value;
      const timeVal = document.getElementById(timeInputId).value || '00:00';
      if (!dateVal) {
        throw new Error('Please select both start and end dates.');
      }
      const dt = new Date(`${dateVal}T${timeVal}:00`);
      if (Number.isNaN(dt.getTime())) {
        throw new Error('Invalid date or time provided.');
      }
      return dt.toISOString();
    }

    function buildQuery(base, extraParams = {}) {
      const start = combineDateTime('from-date', 'from-time');
      const end = combineDateTime('to-date', 'to-time');
      if (end < start) {
        throw new Error('End time must be after start time.');
      }
      const routes = getSelected(routeSelect);
      const stops = getSelected(stopSelect)
        .flatMap(id => stopIdsByCanonical.get(String(id)) || [id]);
      const uniqueStops = Array.from(new Set(stops));
      const params = new URLSearchParams({ start, end });
      if (routes.length) params.set('route_ids', routes.join(','));
      if (uniqueStops.length) params.set('stop_ids', uniqueStops.join(','));
      Object.entries(extraParams).forEach(([key, value]) => {
        if (value === undefined || value === null || value === '') return;
        params.set(key, String(value));
      });
      return `${base}?${params.toString()}`;
    }

    function getHighlightThresholdSeconds() {
      const val = Number.parseFloat(highlightInput.value);
      if (Number.isNaN(val) || val <= 0) return null;
      return val * 60;
    }

    function renderTable(events) {
      if (!events.length) {
        resultsContainer.innerHTML = '<div class="empty-state">No headway events found for the selected window.</div>';
        summaryEl.textContent = '';
        return;
      }
      const highlightThresholdSeconds = getHighlightThresholdSeconds();
      const rows = events.map(ev => {
        const tsLocal = formatDateTime24(new Date(ev.timestamp));
        const headwaySeconds = getHeadwayValue(ev, headwayTypeSelect);
        const headway = formatMinutesSeconds(headwaySeconds);
        const dwell = formatMinutesSeconds(ev.dwell_seconds);
        const route = ev.route_name || getRouteName(ev.route_id || ev.route) || ev.route || '';
        const stop = ev.stop_name || getStopName(ev.address_id || ev.stop_id || ev.stop) || ev.stop || '';
        const vehicle = formatVehicleLabel(ev);
        const exceedsThreshold =
          highlightThresholdSeconds != null && headwaySeconds != null && Number(headwaySeconds) > highlightThresholdSeconds;
        const rowClass = exceedsThreshold ? ' class="highlight-row"' : '';
        return `<tr${rowClass}>
          <td>${tsLocal}</td>
          <td>${route}</td>
          <td>${stop}</td>
          <td>${vehicle}</td>
          <td>${ev.event_type}</td>
          <td>${headway}</td>
          <td>${dwell}</td>
        </tr>`;
      }).join('');
      resultsContainer.innerHTML = `<div style="overflow-x:auto;">
        <table>
          <thead>
            <tr>
              <th>Timestamp (local)</th>
              <th>Route</th>
              <th>Stop</th>
              <th>Vehicle</th>
              <th>Event</th>
              <th>Headway</th>
              <th>Dwell</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>`;
      const selection = [];
      const routeCount = getSelected(routeSelect).length;
      const stopCount = getSelected(stopSelect).length;
      if (routeCount) selection.push(`${routeCount} route${routeCount === 1 ? '' : 's'}`);
      if (stopCount) selection.push(`${stopCount} stop${stopCount === 1 ? '' : 's'}`);
      const stats = calculateHeadwayStats(events, headwayTypeSelect);
      summaryEl.innerHTML = `${events.length} event${events.length === 1 ? '' : 's'} loaded${selection.length ? ` for ${selection.join(' and ')}` : ''}.<br>${formatStatsDisplay(stats)}`;
    }

    async function fetchHeadway() {
      try {
        setStatus('Loading headway…');
        const url = buildQuery('/api/headway');
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Headway fetch failed (${res.status})`);
        const data = await res.json();
        const events = Array.isArray(data.events) ? data.events : [];
        updateVehicleNameLookup(events, data.vehicle_names);
        renderTable(events);
        setStatus('Headway loaded.');
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Failed to load headway.', true);
      }
    }

    function getRouteInitials() {
      const selectedRouteIds = getSelected(routeSelect);
      if (!selectedRouteIds.length) return '';
      const initials = selectedRouteIds.map(id => {
        const name = routeNameById.get(String(id)) || '';
        // Get first letter of each word
        return name.split(/\s+/).map(word => word.charAt(0).toUpperCase()).join('');
      }).join('-');
      return initials;
    }

    function buildExportFilename() {
      const fromDate = document.getElementById('from-date').value || '';
      const toDate = document.getElementById('to-date').value || '';
      const routeInitials = getRouteInitials();

      let filename = 'headway_export';
      if (routeInitials) filename += '_' + routeInitials;
      if (fromDate) filename += '_' + fromDate;
      if (toDate && toDate !== fromDate) filename += '_to_' + toDate;
      filename += '.csv';
      return filename;
    }

    async function exportCsv() {
      try {
        setStatus('Preparing CSV export…');
        const timezoneName = (() => {
          try {
            const { timeZone } = Intl.DateTimeFormat().resolvedOptions();
            return timeZone || undefined;
          } catch (err) {
            console.warn('Could not detect browser timezone', err);
            return undefined;
          }
        })();

        // Fetch events first to calculate stats
        const dataUrl = buildQuery('/api/headway');
        const dataRes = await fetch(dataUrl);
        if (!dataRes.ok) throw new Error(`Failed to fetch headway data (${dataRes.status})`);
        const data = await dataRes.json();
        const events = Array.isArray(data.events) ? data.events : [];
        const stats = calculateHeadwayStats(events, headwayTypeSelect);

        const url = buildQuery('/api/headway/export', {
          headway_type: headwayTypeSelect.value,
          timezone_name: timezoneName,
          stat_avg_headway: stats.average,
          stat_longest_headway: stats.longest,
          stat_std_dev: stats.stdDev,
          stat_avg_dwell: stats.dwellAverage,
          stat_longest_dwell: stats.dwellLongest,
          stat_dwell_std_dev: stats.dwellStdDev,
          stat_data_points: stats.dataPoints,
        });
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Headway export failed (${res.status})`);
        const blob = await res.blob();
        const dlUrl = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = dlUrl;
        link.download = buildExportFilename();
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(dlUrl);
        setStatus('CSV exported.');
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Unable to export right now.', true);
      }
    }

    function clearSelections() {
      routeSelect.selectedIndex = -1;
      stopSelect.selectedIndex = -1;
      populateStops();
      summaryEl.textContent = '';
      resultsContainer.innerHTML = '<div class="empty-state">Selections cleared. Choose filters and load headway.</div>';
      setStatus('Selections cleared.');
    }

    document.getElementById('load-btn').addEventListener('click', fetchHeadway);
    document.getElementById('export-btn').addEventListener('click', exportCsv);
    document.getElementById('clear-btn').addEventListener('click', clearSelections);
    routeSelect.addEventListener('change', () => {
      populateStops(getSelected(routeSelect));
    });

    setDefaults();
    loadMetadata();

    // Disclaimer modal
    const disclaimerModal = document.getElementById('disclaimer-modal');
    const disclaimerClose = document.getElementById('disclaimer-close');
    const showDisclaimer = document.getElementById('show-disclaimer');
    const DISCLAIMER_KEY = 'headway_disclaimer_dismissed';

    function dismissDisclaimer() {
      disclaimerModal.classList.add('hidden');
      try {
        localStorage.setItem(DISCLAIMER_KEY, '1');
      } catch (e) {}
    }

    // Check if already dismissed
    try {
      if (localStorage.getItem(DISCLAIMER_KEY)) {
        disclaimerModal.classList.add('hidden');
      }
    } catch (e) {}

    disclaimerClose.addEventListener('click', dismissDisclaimer);

    showDisclaimer.addEventListener('click', () => {
      disclaimerModal.classList.remove('hidden');
    });

    // Close modal on overlay click (but not modal content click)
    disclaimerModal.addEventListener('click', (e) => {
      if (e.target === disclaimerModal) {
        dismissDisclaimer();
      }
    });
  </script>
</body>
</html>
