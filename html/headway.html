<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Headway Explorer</title>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 0;
      background: #0d0d0d;
      color: #f5f5f5;
      line-height: 1.5;
    }
    header {
      background: linear-gradient(120deg, #12345b, #0f1f3a);
      padding: 1.5rem 2rem;
      color: #e6f0ff;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    header h1 {
      margin: 0;
      font-size: 1.8rem;
      letter-spacing: 0.02em;
    }
    header p {
      margin: 0.25rem 0 0;
      color: #b9d4ff;
    }
    main {
      padding: 2rem;
      display: grid;
      gap: 1.5rem;
    }
    .card {
      background: #161616;
      border: 1px solid #222;
      border-radius: 10px;
      padding: 1.25rem;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.25);
    }
    .card h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: 1.2rem;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem 1.5rem;
      align-items: start;
    }
    label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.4rem;
      color: #d9e2ff;
    }
    input, select, button {
      width: 100%;
      box-sizing: border-box;
      border-radius: 8px;
      border: 1px solid #2d2d2d;
      background: #0f0f0f;
      color: #f3f4f6;
      padding: 0.6rem 0.75rem;
      font-size: 0.95rem;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }
    select[multiple] {
      height: 12rem;
    }
    button {
      background: linear-gradient(120deg, #1f7aff, #16a1ff);
      border: none;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      box-shadow: 0 6px 18px rgba(31, 122, 255, 0.35);
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 28px rgba(31, 122, 255, 0.45);
    }
    button.secondary {
      background: #202020;
      border: 1px solid #2b2b2b;
      box-shadow: none;
    }
    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 0.5rem;
    }
    .status {
      margin-top: 0.75rem;
      color: #9fb7ff;
      font-size: 0.95rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      background: #0f0f0f;
      border-radius: 10px;
      overflow: hidden;
    }
    th, td {
      padding: 0.65rem 0.75rem;
      border-bottom: 1px solid #1f1f1f;
      text-align: left;
    }
    th {
      background: #111827;
      color: #e5edff;
      font-weight: 700;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    tr:nth-child(even) td { background: #131313; }
    tr:hover td { background: #1a1a1a; }
    .pill {
      display: inline-block;
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      background: #1f2937;
      color: #cde2ff;
      font-size: 0.8rem;
      border: 1px solid #253041;
      margin-left: 0.35rem;
    }
    .empty-state {
      padding: 1rem;
      background: #111;
      border: 1px dashed #2d2d2d;
      border-radius: 8px;
      color: #9ca3af;
      text-align: center;
    }
    @media (max-width: 640px) {
      select[multiple] { height: 10rem; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Headway Explorer</h1>
    <p>Select routes, stops, and a window to inspect recorded headway events.</p>
  </header>
  <main>
    <section class="card">
      <h2>Filters</h2>
      <div class="grid">
        <div>
          <label for="from-date">From date</label>
          <input type="date" id="from-date" />
        </div>
        <div>
          <label for="from-time">From time</label>
          <input type="time" id="from-time" step="60" />
        </div>
        <div>
          <label for="to-date">To date</label>
          <input type="date" id="to-date" />
        </div>
        <div>
          <label for="to-time">To time</label>
          <input type="time" id="to-time" step="60" />
        </div>
      </div>
      <div class="grid" style="margin-top: 1rem;">
        <div>
          <label for="route-select">Routes (select one or more)</label>
          <select id="route-select" multiple></select>
        </div>
        <div>
          <label for="stop-select">Stops (select one or more)</label>
          <select id="stop-select" multiple></select>
        </div>
      </div>
      <div class="actions">
        <button id="load-btn">Load headway</button>
        <button id="export-btn" class="secondary">Export CSV</button>
        <button id="clear-btn" class="secondary">Clear selections</button>
      </div>
      <div class="status" id="status">Loading routes and stops…</div>
    </section>

    <section class="card">
      <h2>Live headway</h2>
      <p style="margin-top: 0; color: #9ca3af;">Pick one route and one stop to watch arrivals in the last hour.</p>
      <div class="grid">
        <div>
          <label for="live-route">Route</label>
          <select id="live-route"></select>
        </div>
        <div>
          <label for="live-stop">Stop</label>
          <select id="live-stop"></select>
        </div>
      </div>
      <div class="actions">
        <button id="live-refresh-btn">Refresh live headway</button>
        <button id="live-toggle-btn" class="secondary">Start live view</button>
      </div>
      <div class="status" id="live-status">Select a route and stop to begin.</div>
      <div id="live-summary" class="status" style="margin-top: 0.4rem;"></div>
      <div id="live-results" style="margin-top: 0.75rem;">
        <div class="empty-state">Waiting for a selection.</div>
      </div>
    </section>

    <section class="card">
      <h2>Results</h2>
      <div id="summary" class="status"></div>
      <div id="results-container">
        <div class="empty-state">No data loaded yet.</div>
      </div>
    </section>
  </main>

  <script>
    const routeSelect = document.getElementById('route-select');
    const stopSelect = document.getElementById('stop-select');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');
    const resultsContainer = document.getElementById('results-container');
    const liveRouteSelect = document.getElementById('live-route');
    const liveStopSelect = document.getElementById('live-stop');
    const liveStatusEl = document.getElementById('live-status');
    const liveSummaryEl = document.getElementById('live-summary');
    const liveResultsEl = document.getElementById('live-results');

    let allRoutes = [];
    let allStops = [];
    let routeNameById = new Map();
    let stopNameById = new Map();
    let liveIntervalId = null;
    const LIVE_WINDOW_MS = 60 * 60 * 1000;
    const LIVE_REFRESH_MS = 30 * 1000;

    function formatRouteLabel(route) {
      const id = route.RouteID ?? route.RouteId ?? route.id ?? '';
      const name = route.RouteName || route.Description || route.LongName || route.ShortName || `Route ${id}`;
      const short = route.ShortName || route.InfoText;
      return short && short !== name ? `${name} (${short})` : name;
    }

    function getStopId(stop) {
      return stop.StopID ?? stop.StopId ?? stop.RouteStopID ?? stop.RouteStopId ?? stop.id ?? stop.stop_id ?? stop.Stop?.StopID ?? null;
    }

    function formatStopLabel(stop) {
      const id = getStopId(stop) ?? '';
      const name = stop.Name || stop.Description || stop.StopName || `Stop ${id}`;
      const routes = (stop.RouteIDs || stop.RouteIds || stop.RouteIds || stop.Routes || [])
        .map(r => typeof r === 'object' ? (r.RouteID ?? r.RouteId ?? r.id) : r)
        .filter(Boolean);
      return routes.length ? `${name} — ${routes.join(', ')}` : name;
    }

    function getRouteName(id) {
      if (!id) return '';
      const key = String(id);
      return routeNameById.get(key) || `Route ${key}`;
    }

    function getStopName(id) {
      if (!id) return '';
      const key = String(id);
      return stopNameById.get(key) || `Stop ${key}`;
    }

    function formatVehicleLabel(ev) {
      return (
        ev.vehicle_name ||
        ev.vehicle_label ||
        ev.vehicle ||
        ev.vehicle_fleet_no ||
        ev.vehicle_no ||
        ev.vehicle_id ||
        ''
      );
    }

    function formatMinutesSeconds(seconds) {
      if (seconds == null || Number.isNaN(Number(seconds))) return '';
      const total = Number(seconds);
      const minutes = Math.floor(total / 60);
      const secs = Math.round((total % 60) * 10) / 10;
      const paddedSeconds = secs < 10 ? `0${secs.toFixed(secs % 1 === 0 ? 0 : 1)}` : secs.toFixed(secs % 1 === 0 ? 0 : 1);
      return `${minutes}m ${paddedSeconds}s`;
    }

    function setStatus(message, isError = false) {
      statusEl.textContent = message;
      statusEl.style.color = isError ? '#fca5a5' : '#9fb7ff';
    }

    function populateRoutes() {
      routeSelect.innerHTML = '';
      liveRouteSelect.innerHTML = '<option value="">Select a route…</option>';
      const frag = document.createDocumentFragment();
      const liveFrag = document.createDocumentFragment();
      allRoutes.forEach(route => {
        const opt = document.createElement('option');
        const id = route.RouteID ?? route.RouteId ?? route.id;
        opt.value = id;
        opt.textContent = formatRouteLabel(route);
        frag.appendChild(opt.cloneNode(true));
        liveFrag.appendChild(opt);
      });
      routeSelect.appendChild(frag);
      liveRouteSelect.appendChild(liveFrag);
    }

    function filteredStops(filterRoutes = []) {
      const filterSet = new Set(filterRoutes);
      return allStops.filter(stop => {
        if (!filterSet.size) return true;
        const routes = stop._routeIds || [];
        return routes.some(r => filterSet.has(String(r)));
      });
    }

    function populateStops(filterRoutes = []) {
      stopSelect.innerHTML = '';
      const frag = document.createDocumentFragment();
      filteredStops(filterRoutes).forEach(stop => {
        const id = getStopId(stop);
        if (!id) return;
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = formatStopLabel(stop);
        frag.appendChild(opt);
      });
      stopSelect.appendChild(frag);
    }

    function populateLiveStops(routeId) {
      liveStopSelect.innerHTML = '<option value="">Select a stop…</option>';
      const frag = document.createDocumentFragment();
      filteredStops(routeId ? [routeId] : []).forEach(stop => {
        const id = getStopId(stop);
        if (!id) return;
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = formatStopLabel(stop);
        frag.appendChild(opt);
      });
      liveStopSelect.appendChild(frag);
    }

    function getSelected(selectEl) {
      return Array.from(selectEl.selectedOptions).map(opt => opt.value).filter(Boolean);
    }

    function setDefaults() {
      const now = new Date();
      const toDate = now.toISOString().slice(0, 10);
      const toTime = now.toTimeString().slice(0, 5);
      const from = new Date(now.getTime() - 60 * 60 * 1000);
      document.getElementById('to-date').value = toDate;
      document.getElementById('to-time').value = toTime;
      document.getElementById('from-date').value = from.toISOString().slice(0, 10);
      document.getElementById('from-time').value = from.toTimeString().slice(0, 5);
    }

    async function loadMetadata() {
      try {
        const res = await fetch('/v1/testmap/transloc/metadata');
        if (!res.ok) throw new Error(`Metadata fetch failed (${res.status})`);
        const data = await res.json();
        allRoutes = Array.isArray(data.routes) ? data.routes : [];
      const stopMap = new Map();
      (Array.isArray(data.stops) ? data.stops : []).forEach(stop => {
        const id = getStopId(stop);
          if (!id) return;
          const routes = new Set([
            ...(stop.RouteIds || stop.RouteIDs || stop.RouteIds || []),
            ...(Array.isArray(stop.Routes) ? stop.Routes.map(r => r.RouteID ?? r.RouteId ?? r.id) : []),
            stop.RouteID ?? stop.RouteId ?? stop.RouteId,
          ].filter(Boolean).map(String));
          const existing = stopMap.get(id) || { ...stop, _routeIds: [] };
          const merged = new Set([...(existing._routeIds || []), ...routes]);
          stopMap.set(id, { ...existing, ...stop, _routeIds: Array.from(merged) });
        });
      allStops = Array.from(stopMap.values()).sort((a, b) => {
        const aName = formatStopLabel(a).toLowerCase();
        const bName = formatStopLabel(b).toLowerCase();
        return aName.localeCompare(bName);
      });
      routeNameById = new Map(
        allRoutes
          .map(route => {
            const id = route.RouteID ?? route.RouteId ?? route.id;
            if (id == null) return null;
            return [String(id), formatRouteLabel(route)];
          })
          .filter(Boolean)
      );
      stopNameById = new Map(
        allStops
          .map(stop => {
            const id = getStopId(stop);
            if (id == null) return null;
            const name = stop.Name || stop.Description || stop.StopName;
            return [String(id), name || formatStopLabel(stop)];
          })
          .filter(Boolean)
      );
      populateRoutes();
      populateStops();
      populateLiveStops();
        setStatus('Routes and stops loaded. Choose filters and load headway.');
      } catch (err) {
        console.error(err);
        setStatus('Unable to load routes/stops. Try refreshing.', true);
      }
    }

    function combineDateTime(dateInputId, timeInputId) {
      const dateVal = document.getElementById(dateInputId).value;
      const timeVal = document.getElementById(timeInputId).value || '00:00';
      if (!dateVal) {
        throw new Error('Please select both start and end dates.');
      }
      const dt = new Date(`${dateVal}T${timeVal}:00`);
      if (Number.isNaN(dt.getTime())) {
        throw new Error('Invalid date or time provided.');
      }
      return dt.toISOString();
    }

    function buildQuery(base) {
      const start = combineDateTime('from-date', 'from-time');
      const end = combineDateTime('to-date', 'to-time');
      if (end < start) {
        throw new Error('End time must be after start time.');
      }
      const routes = getSelected(routeSelect);
      const stops = getSelected(stopSelect);
      const params = new URLSearchParams({ start, end });
      if (routes.length) params.set('route_ids', routes.join(','));
      if (stops.length) params.set('stop_ids', stops.join(','));
      return `${base}?${params.toString()}`;
    }

    function renderTable(events) {
      if (!events.length) {
        resultsContainer.innerHTML = '<div class="empty-state">No headway events found for the selected window.</div>';
        summaryEl.textContent = '';
        return;
      }
      const rows = events.map(ev => {
        const tsLocal = new Date(ev.timestamp).toLocaleString();
        const headway = formatMinutesSeconds(ev.headway_seconds);
        const dwell = formatMinutesSeconds(ev.dwell_seconds);
        const route = getRouteName(ev.route_id || ev.route) || ev.route_name || ev.route || '';
        const stop = getStopName(ev.stop_id || ev.stop) || ev.stop_name || ev.stop || '';
        const vehicle = formatVehicleLabel(ev);
        return `<tr>
          <td>${tsLocal}</td>
          <td>${route}</td>
          <td>${stop}</td>
          <td>${vehicle}</td>
          <td>${ev.event_type}</td>
          <td>${headway}</td>
          <td>${dwell}</td>
        </tr>`;
      }).join('');
      resultsContainer.innerHTML = `<div style="overflow-x:auto;">
        <table>
          <thead>
            <tr>
              <th>Timestamp (local)</th>
              <th>Route</th>
              <th>Stop</th>
              <th>Vehicle</th>
              <th>Event</th>
              <th>Headway</th>
              <th>Dwell</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>`;
      const selection = [];
      const routeCount = getSelected(routeSelect).length;
      const stopCount = getSelected(stopSelect).length;
      if (routeCount) selection.push(`${routeCount} route${routeCount === 1 ? '' : 's'}`);
      if (stopCount) selection.push(`${stopCount} stop${stopCount === 1 ? '' : 's'}`);
      summaryEl.textContent = `${events.length} event${events.length === 1 ? '' : 's'} loaded${selection.length ? ` for ${selection.join(' and ')}` : ''}.`;
    }

    function setLiveStatus(message, isError = false) {
      liveStatusEl.textContent = message;
      liveStatusEl.style.color = isError ? '#fca5a5' : '#9fb7ff';
    }

    function renderLiveResults(events) {
      if (!events.length) {
        liveResultsEl.innerHTML = '<div class="empty-state">No headway events recorded in the past hour for this stop.</div>';
        liveSummaryEl.textContent = '';
        return;
      }
      const arrivals = events
        .filter(ev => ev.event_type === 'arrival')
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      const latest = arrivals[0];
      if (latest) {
        const headway = latest.headway_seconds != null ? `${(latest.headway_seconds / 60).toFixed(1)} min` : 'N/A';
        const time = new Date(latest.timestamp).toLocaleTimeString();
        liveSummaryEl.textContent = `Latest arrival at ${time}. Headway: ${headway}.`;
      } else {
        liveSummaryEl.textContent = 'No arrivals recorded yet for this stop in the past hour.';
      }

      const recent = events
        .slice()
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, 10);
      const rows = recent.map(ev => {
        const tsLocal = new Date(ev.timestamp).toLocaleTimeString();
        const headway = ev.headway_seconds != null ? `${(ev.headway_seconds / 60).toFixed(1)} min` : '';
        const dwell = ev.dwell_seconds != null ? `${ev.dwell_seconds.toFixed(1)}s` : '';
        return `<tr>
          <td>${tsLocal}</td>
          <td>${ev.event_type}</td>
          <td>${headway}</td>
          <td>${dwell}</td>
        </tr>`;
      }).join('');

      liveResultsEl.innerHTML = `<div style="overflow-x:auto;">
        <table>
          <thead>
            <tr>
              <th>Time</th>
              <th>Event</th>
              <th>Headway</th>
              <th>Dwell</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>`;
    }

    async function fetchLiveHeadway() {
      const routeId = liveRouteSelect.value;
      const stopId = liveStopSelect.value;
      if (!routeId || !stopId) {
        setLiveStatus('Please pick a route and stop first.', true);
        liveResultsEl.innerHTML = '<div class="empty-state">Waiting for a route and stop selection.</div>';
        liveSummaryEl.textContent = '';
        return;
      }
      try {
        setLiveStatus('Loading live headway…');
        const now = new Date();
        const start = new Date(now.getTime() - LIVE_WINDOW_MS);
        const params = new URLSearchParams({
          start: start.toISOString(),
          end: now.toISOString(),
          route_ids: routeId,
          stop_ids: stopId,
        });
        const res = await fetch(`/api/headway?${params.toString()}`);
        if (!res.ok) throw new Error(`Live headway fetch failed (${res.status})`);
        const data = await res.json();
        const events = Array.isArray(data.events) ? data.events : [];
        renderLiveResults(events);
        setLiveStatus('Live headway updated.');
      } catch (err) {
        console.error(err);
        setLiveStatus(err.message || 'Could not load live headway.', true);
      }
    }

    function startLiveView() {
      if (liveIntervalId) {
        clearInterval(liveIntervalId);
      }
      liveIntervalId = setInterval(fetchLiveHeadway, LIVE_REFRESH_MS);
      fetchLiveHeadway();
      document.getElementById('live-toggle-btn').textContent = 'Stop live view';
      setLiveStatus('Live updates running every 30 seconds.');
    }

    function stopLiveView() {
      if (liveIntervalId) {
        clearInterval(liveIntervalId);
        liveIntervalId = null;
      }
      document.getElementById('live-toggle-btn').textContent = 'Start live view';
      setLiveStatus('Live updates paused.');
    }

    async function fetchHeadway() {
      try {
        setStatus('Loading headway…');
        const url = buildQuery('/api/headway');
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Headway fetch failed (${res.status})`);
        const data = await res.json();
        const events = Array.isArray(data.events) ? data.events : [];
        renderTable(events);
        setStatus('Headway loaded.');
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Failed to load headway.', true);
      }
    }

    function exportCsv() {
      try {
        const url = buildQuery('/api/headway/export');
        window.location.href = url;
      } catch (err) {
        setStatus(err.message || 'Unable to export right now.', true);
      }
    }

    function clearSelections() {
      routeSelect.selectedIndex = -1;
      stopSelect.selectedIndex = -1;
      populateStops();
      summaryEl.textContent = '';
      resultsContainer.innerHTML = '<div class="empty-state">Selections cleared. Choose filters and load headway.</div>';
      setStatus('Selections cleared.');
    }

    document.getElementById('load-btn').addEventListener('click', fetchHeadway);
    document.getElementById('export-btn').addEventListener('click', exportCsv);
    document.getElementById('clear-btn').addEventListener('click', clearSelections);
    routeSelect.addEventListener('change', () => {
      populateStops(getSelected(routeSelect));
    });
    liveRouteSelect.addEventListener('change', () => {
      populateLiveStops(liveRouteSelect.value);
      liveStopSelect.value = '';
      if (liveIntervalId) stopLiveView();
    });

    document.getElementById('live-refresh-btn').addEventListener('click', fetchLiveHeadway);
    document.getElementById('live-toggle-btn').addEventListener('click', () => {
      if (liveIntervalId) {
        stopLiveView();
      } else {
        if (!liveRouteSelect.value || !liveStopSelect.value) {
          setLiveStatus('Select both a route and stop to start live view.', true);
          return;
        }
        startLiveView();
      }
    });

    setDefaults();
    loadMetadata();
  </script>
</body>
</html>
