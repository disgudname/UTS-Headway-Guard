<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="UTSShield.png" />
  <link rel="apple-touch-icon" sizes="120x120" href="/media/apple-touch-icon-120.png" />
  <link rel="apple-touch-icon" sizes="152x152" href="/media/apple-touch-icon-152.png" />
  <link rel="apple-touch-icon" sizes="180x180" href="/media/apple-touch-icon-180.png" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Headway Explorer</title>
  <script defer src="/nav-bar.js"></script>
  <style>
    :root {
      color-scheme: light dark;
    }
    body {
      font-family: "Inter", "Segoe UI", system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 0;
      background: #0d0d0d;
      color: #f5f5f5;
      line-height: 1.5;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      background: linear-gradient(120deg, #12345b, #0f1f3a);
      padding: 1.5rem 0;
      color: #e6f0ff;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    .content-width {
      width: min(1200px, calc(100% - 2.5rem));
      margin: 0 auto;
      box-sizing: border-box;
    }
    .header-inner {
      padding: 0 0.5rem;
    }
    header h1 {
      margin: 0;
      font-size: 1.8rem;
      letter-spacing: 0.02em;
    }
    header p {
      margin: 0.25rem 0 0;
      color: #b9d4ff;
    }
    main {
      padding: 2rem 0;
      flex: 1;
      width: min(1200px, calc(100% - 2.5rem));
      margin: 0 auto;
      display: grid;
      gap: 1.5rem;
    }
    .card {
      background: #161616;
      border: 1px solid #222;
      border-radius: 10px;
      padding: 1.25rem;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.25);
    }
    .card h2 {
      margin-top: 0;
      margin-bottom: 0.5rem;
      font-size: 1.2rem;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem 1.5rem;
      align-items: start;
    }
    label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.4rem;
      color: #d9e2ff;
    }
    input, select, button {
      width: 100%;
      box-sizing: border-box;
      border-radius: 8px;
      border: 1px solid #2d2d2d;
      background: #0f0f0f;
      color: #f3f4f6;
      padding: 0.6rem 0.75rem;
      font-size: 0.95rem;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }
    select[multiple] {
      height: 12rem;
    }
    button {
      background: linear-gradient(120deg, #1f7aff, #16a1ff);
      border: none;
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      box-shadow: 0 6px 18px rgba(31, 122, 255, 0.35);
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 28px rgba(31, 122, 255, 0.45);
    }
    button.secondary {
      background: #202020;
      border: 1px solid #2b2b2b;
      box-shadow: none;
    }
    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin-top: 0.5rem;
    }
    .status {
      margin-top: 0.75rem;
      color: #9fb7ff;
      font-size: 0.95rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
      background: #0f0f0f;
      border-radius: 10px;
      overflow: hidden;
    }
    th, td {
      padding: 0.65rem 0.75rem;
      border-bottom: 1px solid #1f1f1f;
      text-align: left;
    }
    th {
      background: #111827;
      color: #e5edff;
      font-weight: 700;
      position: sticky;
      top: 0;
      z-index: 1;
    }
    tr:nth-child(even) td { background: #131313; }
    tr:hover td { background: #1a1a1a; }
    .pill {
      display: inline-block;
      padding: 0.1rem 0.45rem;
      border-radius: 999px;
      background: #1f2937;
      color: #cde2ff;
      font-size: 0.8rem;
      border: 1px solid #253041;
      margin-left: 0.35rem;
    }
    .empty-state {
      padding: 1rem;
      background: #111;
      border: 1px dashed #2d2d2d;
      border-radius: 8px;
      color: #9ca3af;
      text-align: center;
    }
    .highlight-row td {
      background: #3a0d0d;
      color: #ffdede;
    }
    .highlight-row:hover td {
      background: #4a1010;
    }
    @media (max-width: 640px) {
      select[multiple] { height: 10rem; }
    }
  </style>
</head>
<body>
  <header>
    <div class="content-width header-inner">
      <h1>Headway Explorer</h1>
      <p>Select routes, stops, and a window to inspect recorded headway events.</p>
    </div>
  </header>
  <main class="content-width">
    <section class="card">
      <h2>Filters</h2>
      <div class="grid">
        <div>
          <label for="from-date">From date</label>
          <input type="date" id="from-date" />
        </div>
        <div>
          <label for="from-time">From time</label>
          <input type="time" id="from-time" step="60" />
        </div>
        <div>
          <label for="to-date">To date</label>
          <input type="date" id="to-date" />
        </div>
        <div>
          <label for="to-time">To time</label>
          <input type="time" id="to-time" step="60" />
        </div>
      </div>
      <div class="grid" style="margin-top: 1rem;">
        <div>
          <label for="route-select">Routes (select one or more)</label>
          <select id="route-select" multiple></select>
        </div>
        <div>
          <label for="stop-select">Stops (select one or more)</label>
          <select id="stop-select" multiple></select>
        </div>
        <div>
          <label for="headway-type">Headway type</label>
          <select id="headway-type">
            <option value="arrival_arrival" selected>Arrival to arrival</option>
            <option value="departure_arrival">Departure to arrival</option>
          </select>
        </div>
        <div>
          <label for="highlight-threshold">Highlight Above (min)</label>
          <input type="number" id="highlight-threshold" min="0" step="1" placeholder="e.g. 15" />
        </div>
      </div>
      <div class="actions">
        <button id="load-btn">Load headway</button>
        <button id="export-btn" class="secondary">Export CSV</button>
        <button id="clear-btn" class="secondary">Clear selections</button>
      </div>
      <div class="status" id="status">Loading routes and stops…</div>
    </section>

    <section class="card">
      <h2>Live headway</h2>
      <p style="margin-top: 0; color: #9ca3af;">Pick one route and one stop to watch arrivals in the last hour.</p>
      <div class="grid">
        <div>
          <label for="live-route">Route</label>
          <select id="live-route"></select>
        </div>
        <div>
          <label for="live-stop">Stop</label>
          <select id="live-stop"></select>
        </div>
        <div>
          <label for="live-headway-type">Headway type</label>
          <select id="live-headway-type">
            <option value="arrival_arrival" selected>Arrival to arrival</option>
            <option value="departure_arrival">Departure to arrival</option>
          </select>
        </div>
      </div>
      <div class="actions">
        <button id="live-refresh-btn">Refresh live headway</button>
        <button id="live-toggle-btn" class="secondary">Start live view</button>
      </div>
      <div class="status" id="live-status">Select a route and stop to begin.</div>
      <div id="live-summary" class="status" style="margin-top: 0.4rem;"></div>
      <div id="live-results" style="margin-top: 0.75rem;">
        <div class="empty-state">Waiting for a selection.</div>
      </div>
    </section>

    <section class="card">
      <h2>Results</h2>
      <div id="summary" class="status"></div>
      <div id="results-container">
        <div class="empty-state">No data loaded yet.</div>
      </div>
    </section>
  </main>

  <script>
    const routeSelect = document.getElementById('route-select');
    const stopSelect = document.getElementById('stop-select');
    const statusEl = document.getElementById('status');
    const summaryEl = document.getElementById('summary');
    const resultsContainer = document.getElementById('results-container');
    const liveRouteSelect = document.getElementById('live-route');
    const liveStopSelect = document.getElementById('live-stop');
    const headwayTypeSelect = document.getElementById('headway-type');
    const liveHeadwayTypeSelect = document.getElementById('live-headway-type');
    const liveStatusEl = document.getElementById('live-status');
    const liveSummaryEl = document.getElementById('live-summary');
    const liveResultsEl = document.getElementById('live-results');
    const highlightInput = document.getElementById('highlight-threshold');

    let allRoutes = [];
    let allStops = [];
    let routeNameById = new Map();
    let stopNameById = new Map();
    let stopIdsByCanonical = new Map();
    let vehicleNameById = new Map();
    let liveIntervalId = null;
    const LIVE_WINDOW_MS = 60 * 60 * 1000;
    const LIVE_REFRESH_MS = 30 * 1000;

    function formatRouteLabel(route) {
      const id = route.RouteID ?? route.RouteId ?? route.id ?? '';
      const name = route.RouteName || route.Description || route.LongName || route.ShortName || `Route ${id}`;
      const short = route.ShortName || route.InfoText;
      return short && short !== name ? `${name} (${short})` : name;
    }

    function collectStopIds(stop) {
      return [
        stop.StopID,
        stop.StopId,
        stop.stop_id,
        stop.Stop?.StopID,
        stop.Stop?.StopId,
        stop.RouteStopID,
        stop.RouteStopId,
        stop.AddressID,
        stop.AddressId,
        stop.address_id,
        stop.id,
      ].filter(id => id !== undefined && id !== null);
    }

    function getStopId(stop) {
      const candidates = collectStopIds(stop);
      return candidates.length ? candidates[0] : null;
    }

    function normalizeStopName(stop) {
      const name = stop.Name || stop.Description || stop.StopName || '';
      return name.trim().toLowerCase();
    }

    function getStopCoords(stop) {
      const lat = stop.Latitude ?? stop.latitude ?? stop.lat ?? stop.StopLat ?? stop.StopLatitude ?? stop.Lat;
      const lon = stop.Longitude ?? stop.longitude ?? stop.lon ?? stop.Lon ?? stop.StopLon ?? stop.StopLongitude ?? stop.Lng;
      if (lat == null || lon == null || Number.isNaN(Number(lat)) || Number.isNaN(Number(lon))) return null;
      return { lat: Number(lat), lon: Number(lon) };
    }

    function getStopKey(stop) {
      const id = getStopId(stop);
      const name = normalizeStopName(stop);
      const coords = getStopCoords(stop);
      if (name && coords) return `${name}|${coords.lat.toFixed(5)},${coords.lon.toFixed(5)}`;
      if (coords) return `coords:${coords.lat.toFixed(5)},${coords.lon.toFixed(5)}`;
      if (name) return `name:${name}`;
      return id != null ? `id:${id}` : null;
    }

    function formatStopLabel(stop) {
      const id = getStopId(stop) ?? '';
      const name = stop.Name || stop.Description || stop.StopName || `Stop ${id}`;
      const routeIds = new Set([
        ...(stop.RouteIDs || stop.RouteIds || stop.RouteIds || stop.Routes || []),
        ...(stop._routeIds || []),
      ]
        .map(r => (typeof r === 'object' ? (r.RouteID ?? r.RouteId ?? r.id) : r))
        .filter(Boolean)
        .map(String));
      const routes = Array.from(routeIds);
      return routes.length ? `${name} — ${routes.join(', ')}` : name;
    }

    function getRouteName(id) {
      if (!id) return '';
      const key = String(id);
      return routeNameById.get(key) || `Route ${key}`;
    }

    function getStopName(id) {
      if (!id) return '';
      const key = String(id);
      return stopNameById.get(key) || `Stop ${key}`;
    }

    function pickVehicleName(record) {
      if (!record) return '';
      return (
        record.vehicle_name ||
        record.Name ||
        record.VehicleName ||
        record.vehicle_label ||
        record.vehicle_fleet_no ||
        record.vehicle_no ||
        ''
      );
    }

    function updateVehicleNameLookup(events = [], vehicleNames = null) {
      if (vehicleNames && typeof vehicleNames === 'object') {
        Object.entries(vehicleNames).forEach(([id, name]) => {
          if (id == null || !name) return;
          vehicleNameById.set(String(id), String(name));
        });
      }
      events.forEach(ev => {
        const id = ev.vehicle_id || ev.vehicle;
        const name = ev.vehicle_name || pickVehicleName(ev);
        if (id == null || !name) return;
        vehicleNameById.set(String(id), String(name));
      });
    }

    async function refreshVehicleRoster() {
      try {
        const res = await fetch('/v1/vehicles?include_stale=1&include_unassigned=1');
        if (!res.ok) throw new Error(`Vehicle roster fetch failed (${res.status})`);
        const data = await res.json();
        const rosterNames = (Array.isArray(data.vehicles) ? data.vehicles : []).reduce((acc, entry) => {
          const id = entry.VehicleID ?? entry.VehicleId ?? entry.id;
          const name = entry.name || entry.Name;
          if (id != null && name) acc[id] = name;
          return acc;
        }, {});
        updateVehicleNameLookup([], rosterNames);
      } catch (err) {
        console.warn('Unable to refresh vehicle roster for name lookup', err);
      }
    }

    function formatVehicleLabel(ev) {
      const directLabel = ev?.vehicle_name || pickVehicleName(ev);
      if (directLabel) return directLabel;
      const id = ev.vehicle_id || ev.vehicle;
      if (!id) return '';
      const nameFromMap = vehicleNameById.get(String(id));
      if (nameFromMap) return nameFromMap;
      return `Vehicle ${id}`;
    }

    function formatMinutesSeconds(seconds) {
      if (seconds == null || Number.isNaN(Number(seconds))) return '';
      const total = Number(seconds);
      const minutes = Math.floor(total / 60);
      const secs = Math.round((total % 60) * 10) / 10;
      const paddedSeconds = secs < 10 ? `0${secs.toFixed(secs % 1 === 0 ? 0 : 1)}` : secs.toFixed(secs % 1 === 0 ? 0 : 1);
      return `${minutes}m ${paddedSeconds}s`;
    }

    function resolveHeadwayField(selectEl) {
      return selectEl?.value === 'departure_arrival'
        ? 'headway_departure_arrival'
        : 'headway_arrival_arrival';
    }

    function getHeadwayValue(ev, selectEl) {
      const field = resolveHeadwayField(selectEl);
      if (ev[field] != null) return ev[field];
      if (field !== 'headway_arrival_arrival' && ev.headway_arrival_arrival != null) return ev.headway_arrival_arrival;
      if (ev.headway_seconds != null) return ev.headway_seconds;
      return null;
    }

    function setStatus(message, isError = false) {
      statusEl.textContent = message;
      statusEl.style.color = isError ? '#fca5a5' : '#9fb7ff';
    }

    function populateRoutes() {
      routeSelect.innerHTML = '';
      liveRouteSelect.innerHTML = '<option value="">Select a route…</option>';
      const frag = document.createDocumentFragment();
      const liveFrag = document.createDocumentFragment();
      allRoutes.forEach(route => {
        const opt = document.createElement('option');
        const id = route.RouteID ?? route.RouteId ?? route.id;
        opt.value = id;
        opt.textContent = formatRouteLabel(route);
        frag.appendChild(opt.cloneNode(true));
        liveFrag.appendChild(opt);
      });
      routeSelect.appendChild(frag);
      liveRouteSelect.appendChild(liveFrag);
    }

    function filteredStops(filterRoutes = []) {
      const filterSet = new Set(filterRoutes);
      return allStops.filter(stop => {
        if (!filterSet.size) return true;
        const routes = stop._routeIds || [];
        return routes.some(r => filterSet.has(String(r)));
      });
    }

    function populateStops(filterRoutes = []) {
      stopSelect.innerHTML = '';
      const frag = document.createDocumentFragment();
      filteredStops(filterRoutes).forEach(stop => {
        const id = getStopId(stop);
        if (!id) return;
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = formatStopLabel(stop);
        frag.appendChild(opt);
      });
      stopSelect.appendChild(frag);
    }

    function populateLiveStops(routeId) {
      liveStopSelect.innerHTML = '<option value="">Select a stop…</option>';
      const frag = document.createDocumentFragment();
      filteredStops(routeId ? [routeId] : []).forEach(stop => {
        const id = getStopId(stop);
        if (!id) return;
        const opt = document.createElement('option');
        opt.value = id;
        opt.textContent = formatStopLabel(stop);
        frag.appendChild(opt);
      });
      liveStopSelect.appendChild(frag);
    }

    function getSelected(selectEl) {
      return Array.from(selectEl.selectedOptions).map(opt => opt.value).filter(Boolean);
    }

    function setDefaults() {
      const now = new Date();
      const toDate = now.toISOString().slice(0, 10);
      const toTime = now.toTimeString().slice(0, 5);
      const from = new Date(now.getTime() - 60 * 60 * 1000);
      document.getElementById('to-date').value = toDate;
      document.getElementById('to-time').value = toTime;
      document.getElementById('from-date').value = from.toISOString().slice(0, 10);
      document.getElementById('from-time').value = from.toTimeString().slice(0, 5);
    }

    async function loadMetadata() {
      try {
        const res = await fetch('/v1/testmap/transloc/metadata');
        if (!res.ok) throw new Error(`Metadata fetch failed (${res.status})`);
        const data = await res.json();
        allRoutes = Array.isArray(data.routes) ? data.routes : [];
        const stopMap = new Map();
        (Array.isArray(data.stops) ? data.stops : []).forEach(stop => {
          const candidateIds = collectStopIds(stop);
          const id = candidateIds[0];
          const key = getStopKey(stop);
          if (!key || !id) return;
          const routes = new Set([
            ...(stop.RouteIds || stop.RouteIDs || stop.RouteIds || []),
            ...(Array.isArray(stop.Routes) ? stop.Routes.map(r => r.RouteID ?? r.RouteId ?? r.id) : []),
            stop.RouteID ?? stop.RouteId ?? stop.RouteId,
          ].filter(Boolean).map(String));
          const existing = stopMap.get(key) || { ...stop, _routeIds: [], _allIds: [] };
          const mergedRoutes = new Set([...(existing._routeIds || []), ...routes]);
          const mergedIds = new Set([...(existing._allIds || []), ...candidateIds.map(String)]);
          const canonicalId = getStopId(existing) ?? id;
          stopMap.set(key, {
            ...existing,
            ...stop,
            StopID: canonicalId,
            _routeIds: Array.from(mergedRoutes),
            _allIds: Array.from(mergedIds),
          });
        });
        allStops = Array.from(stopMap.values()).sort((a, b) => {
          const aName = formatStopLabel(a).toLowerCase();
          const bName = formatStopLabel(b).toLowerCase();
          return aName.localeCompare(bName);
        });
        routeNameById = new Map(
          allRoutes
            .map(route => {
              const id = route.RouteID ?? route.RouteId ?? route.id;
              if (id == null) return null;
              return [String(id), formatRouteLabel(route)];
            })
            .filter(Boolean)
        );
        vehicleNameById = new Map();
        stopIdsByCanonical = new Map();
        stopNameById = new Map();
        allStops.forEach(stop => {
          const id = getStopId(stop);
          if (id == null) return;
          const name = stop.Name || stop.Description || stop.StopName || formatStopLabel(stop);
          const ids = stop._allIds?.length ? stop._allIds.map(String) : collectStopIds(stop).map(String);
          if (!ids.length) ids.push(String(id));
          stopIdsByCanonical.set(String(id), ids);
          ids.forEach(mappedId => stopNameById.set(mappedId, name));
        });
        populateRoutes();
        populateStops();
        populateLiveStops();
        setStatus('Routes and stops loaded. Choose filters and load headway.');
        refreshVehicleRoster();
      } catch (err) {
        console.error(err);
        setStatus('Unable to load routes/stops. Try refreshing.', true);
      }
    }

    function combineDateTime(dateInputId, timeInputId) {
      const dateVal = document.getElementById(dateInputId).value;
      const timeVal = document.getElementById(timeInputId).value || '00:00';
      if (!dateVal) {
        throw new Error('Please select both start and end dates.');
      }
      const dt = new Date(`${dateVal}T${timeVal}:00`);
      if (Number.isNaN(dt.getTime())) {
        throw new Error('Invalid date or time provided.');
      }
      return dt.toISOString();
    }

    function buildQuery(base, extraParams = {}) {
      const start = combineDateTime('from-date', 'from-time');
      const end = combineDateTime('to-date', 'to-time');
      if (end < start) {
        throw new Error('End time must be after start time.');
      }
      const routes = getSelected(routeSelect);
      const stops = getSelected(stopSelect)
        .flatMap(id => stopIdsByCanonical.get(String(id)) || [id]);
      const uniqueStops = Array.from(new Set(stops));
      const params = new URLSearchParams({ start, end });
      if (routes.length) params.set('route_ids', routes.join(','));
      if (uniqueStops.length) params.set('stop_ids', uniqueStops.join(','));
      Object.entries(extraParams).forEach(([key, value]) => {
        if (value === undefined || value === null || value === '') return;
        params.set(key, String(value));
      });
      return `${base}?${params.toString()}`;
    }

    function getHighlightThresholdSeconds() {
      const val = Number.parseFloat(highlightInput.value);
      if (Number.isNaN(val) || val <= 0) return null;
      return val * 60;
    }

    function renderTable(events) {
      if (!events.length) {
        resultsContainer.innerHTML = '<div class="empty-state">No headway events found for the selected window.</div>';
        summaryEl.textContent = '';
        return;
      }
      const highlightThresholdSeconds = getHighlightThresholdSeconds();
      const rows = events.map(ev => {
        const tsLocal = new Date(ev.timestamp).toLocaleString();
        const headwaySeconds = getHeadwayValue(ev, headwayTypeSelect);
        const headway = formatMinutesSeconds(headwaySeconds);
        const dwell = formatMinutesSeconds(ev.dwell_seconds);
        const route = ev.route_name || getRouteName(ev.route_id || ev.route) || ev.route || '';
        const stop = ev.stop_name || getStopName(ev.address_id || ev.stop_id || ev.stop) || ev.stop || '';
        const vehicle = formatVehicleLabel(ev);
        const exceedsThreshold =
          highlightThresholdSeconds != null && headwaySeconds != null && Number(headwaySeconds) > highlightThresholdSeconds;
        const rowClass = exceedsThreshold ? ' class="highlight-row"' : '';
        return `<tr${rowClass}>
          <td>${tsLocal}</td>
          <td>${route}</td>
          <td>${stop}</td>
          <td>${vehicle}</td>
          <td>${ev.event_type}</td>
          <td>${headway}</td>
          <td>${dwell}</td>
        </tr>`;
      }).join('');
      resultsContainer.innerHTML = `<div style="overflow-x:auto;">
        <table>
          <thead>
            <tr>
              <th>Timestamp (local)</th>
              <th>Route</th>
              <th>Stop</th>
              <th>Vehicle</th>
              <th>Event</th>
              <th>Headway</th>
              <th>Dwell</th>
            </tr>
          </thead>
          <tbody>${rows}</tbody>
        </table>
      </div>`;
      const selection = [];
      const routeCount = getSelected(routeSelect).length;
      const stopCount = getSelected(stopSelect).length;
      if (routeCount) selection.push(`${routeCount} route${routeCount === 1 ? '' : 's'}`);
      if (stopCount) selection.push(`${stopCount} stop${stopCount === 1 ? '' : 's'}`);
      summaryEl.textContent = `${events.length} event${events.length === 1 ? '' : 's'} loaded${selection.length ? ` for ${selection.join(' and ')}` : ''}.`;
    }

    function setLiveStatus(message, isError = false) {
      liveStatusEl.textContent = message;
      liveStatusEl.style.color = isError ? '#fca5a5' : '#9fb7ff';
    }

    function renderLiveResults(events, etaInfo = null) {
      if (!events.length) {
        liveResultsEl.innerHTML = '<div class="empty-state">No headway events recorded in the past hour for this stop.</div>';
        liveSummaryEl.textContent = '';
        return;
      }
      const arrivals = events
        .filter(ev => ev.event_type === 'arrival')
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      const latest = arrivals[0];
      const summaryParts = [];
      if (latest) {
        const time = new Date(latest.timestamp).toLocaleTimeString();
        // Calculate average headway over the last hour
        const headwayValues = arrivals
          .map(ev => getHeadwayValue(ev, liveHeadwayTypeSelect))
          .filter(hw => hw != null && !Number.isNaN(hw));
        const avgHeadway = headwayValues.length > 0
          ? headwayValues.reduce((sum, hw) => sum + hw, 0) / headwayValues.length
          : null;
        const avgHeadwayDisplay = avgHeadway != null ? `${(avgHeadway / 60).toFixed(1)} min` : 'N/A';
        summaryParts.push(`Latest arrival at ${time}. Avg headway (1hr): ${avgHeadwayDisplay}.`);
      } else {
        summaryParts.push('No arrivals recorded yet for this stop in the past hour.');
      }

      if (etaInfo && etaInfo.secondsToArrival != null) {
        const etaMinutes = (etaInfo.secondsToArrival / 60).toFixed(1);
        const etaTime = new Date(etaInfo.arrivalTimeMs).toLocaleTimeString();
        if (latest) {
          const latestTs = new Date(latest.timestamp).getTime();
          const estimatedHeadwaySeconds = (etaInfo.arrivalTimeMs - latestTs) / 1000;
          const estimatedHeadway = estimatedHeadwaySeconds > 0 ? `${(estimatedHeadwaySeconds / 60).toFixed(1)} min` : null;
          const headwayPart = estimatedHeadway ? `Estimated current headway: ${estimatedHeadway}.` : 'Current headway estimate unavailable.';
          summaryParts.push(`${headwayPart} Next arrival in ${etaMinutes} min at ${etaTime}.`);
        } else {
          summaryParts.push(`Next arrival in ${etaMinutes} min at ${etaTime}.`);
        }
      }

      liveSummaryEl.textContent = summaryParts.join(' ');

      const recent = events
        .slice()
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, 10);
      const etaRow = etaInfo && etaInfo.arrivalTimeMs
        ? `<tr class="highlight-row">
          <td>${new Date(etaInfo.arrivalTimeMs).toLocaleTimeString()}</td>
          <td>ETA</td>
          <td></td>
          <td>${formatMinutesSeconds(etaInfo.estimatedHeadwaySeconds)}</td>
          <td></td>
        </tr>`
        : '';

      const rows = recent.map(ev => {
        const tsLocal = new Date(ev.timestamp).toLocaleTimeString();
        const headwaySeconds = getHeadwayValue(ev, liveHeadwayTypeSelect);
        const headway = formatMinutesSeconds(headwaySeconds);
        const dwell = formatMinutesSeconds(ev.dwell_seconds);
        const vehicle = formatVehicleLabel(ev);
        return `<tr>
          <td>${tsLocal}</td>
          <td>${ev.event_type}</td>
          <td>${vehicle}</td>
          <td>${headway}</td>
          <td>${dwell}</td>
        </tr>`;
      }).join('');

      liveResultsEl.innerHTML = `<div style="overflow-x:auto;">
        <table>
          <thead>
            <tr>
              <th>Time</th>
              <th>Event</th>
              <th>Vehicle</th>
              <th>Headway</th>
              <th>Dwell</th>
            </tr>
          </thead>
          <tbody>${etaRow}${rows}</tbody>
        </table>
      </div>`;
    }

    async function fetchLiveHeadway() {
      const routeId = liveRouteSelect.value;
      const stopId = liveStopSelect.value;
      if (!routeId || !stopId) {
        setLiveStatus('Please pick a route and stop first.', true);
        liveResultsEl.innerHTML = '<div class="empty-state">Waiting for a route and stop selection.</div>';
        liveSummaryEl.textContent = '';
        return;
      }
      try {
        setLiveStatus('Loading live headway…');
        const now = new Date();
        const start = new Date(now.getTime() - LIVE_WINDOW_MS);
        const stopIds = stopIdsByCanonical.get(String(stopId)) || [stopId];
        const headwayParams = new URLSearchParams({
          start: start.toISOString(),
          end: now.toISOString(),
          route_ids: routeId,
          stop_ids: stopIds.join(','),
        });
        const stopIdSet = new Set(stopIds.map(String));
        const [headwayRes, etaRes] = await Promise.all([
          fetch(`/api/headway?${headwayParams.toString()}`),
          fetch('/v1/transloc/stop_arrivals'),
        ]);
        if (!headwayRes.ok) throw new Error(`Live headway fetch failed (${headwayRes.status})`);
        const data = await headwayRes.json();
        const events = Array.isArray(data.events) ? data.events : [];
        updateVehicleNameLookup(events, data.vehicle_names);

        let etaInfo = null;
        if (etaRes.ok) {
          const etaPayload = await etaRes.json();
          const arrivals = Array.isArray(etaPayload?.Arrivals)
            ? etaPayload.Arrivals
            : Array.isArray(etaPayload)
              ? etaPayload
              : [];

          const parseArrivalTimeMs = arrival => {
            const raw = arrival?.EstimateTime || arrival?.Time;
            if (typeof raw === 'string') {
              const match = /\/Date\((\d+)\)\//.exec(raw);
              if (match) return Number(match[1]);
            }
            const parsed = Date.parse(raw);
            return Number.isFinite(parsed) ? parsed : null;
          };

          arrivals.forEach(stop => {
            const stopIdFromPayload = String(stop?.StopId ?? stop?.StopID ?? stop?.stop_id ?? '');
            if (stopIdSet.size && stopIdFromPayload && !stopIdSet.has(stopIdFromPayload)) return;
            const stopArrivals = Array.isArray(stop?.Arrivals) ? stop.Arrivals : Array.isArray(stop?.Times) ? stop.Times : [];
            stopArrivals.forEach(arrival => {
              const arrivalRouteId = arrival.RouteId ?? arrival.RouteID ?? stop.RouteId ?? stop.RouteID ?? arrival.route_id;
              const routeMatch = String(arrivalRouteId || '') === String(routeId);
              if (!routeMatch) return;
              let seconds = Number(arrival.SecondsToArrival ?? arrival.SecondsToDeparture ?? arrival.Seconds ?? arrival.seconds);
              const arrivalTimeMs = parseArrivalTimeMs(arrival);
              if (!Number.isFinite(seconds) && Number.isFinite(arrivalTimeMs)) {
                seconds = (arrivalTimeMs - Date.now()) / 1000;
              }
              if (!Number.isFinite(seconds)) return;
              const timeMs = Number.isFinite(arrivalTimeMs) ? arrivalTimeMs : Date.now() + seconds * 1000;
              if (!etaInfo || seconds < etaInfo.secondsToArrival) {
                etaInfo = {
                  secondsToArrival: seconds,
                  arrivalTimeMs: timeMs,
                };
              }
            });
          });
          if (etaInfo && events.length) {
            const latestArrival = events
              .filter(ev => ev.event_type === 'arrival')
              .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))[0];
            if (latestArrival) {
              etaInfo.estimatedHeadwaySeconds = Math.max(
                0,
                (etaInfo.arrivalTimeMs - new Date(latestArrival.timestamp).getTime()) / 1000,
              );
            }
          }
        }

        renderLiveResults(events, etaInfo);
        setLiveStatus('Live headway updated.');
      } catch (err) {
        console.error(err);
        setLiveStatus(err.message || 'Could not load live headway.', true);
      }
    }

    function startLiveView() {
      if (liveIntervalId) {
        clearInterval(liveIntervalId);
      }
      liveIntervalId = setInterval(fetchLiveHeadway, LIVE_REFRESH_MS);
      fetchLiveHeadway();
      document.getElementById('live-toggle-btn').textContent = 'Stop live view';
      setLiveStatus('Live updates running every 30 seconds.');
    }

    function stopLiveView() {
      if (liveIntervalId) {
        clearInterval(liveIntervalId);
        liveIntervalId = null;
      }
      document.getElementById('live-toggle-btn').textContent = 'Start live view';
      setLiveStatus('Live updates paused.');
    }

    async function fetchHeadway() {
      try {
        setStatus('Loading headway…');
        const url = buildQuery('/api/headway');
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Headway fetch failed (${res.status})`);
        const data = await res.json();
        const events = Array.isArray(data.events) ? data.events : [];
        updateVehicleNameLookup(events, data.vehicle_names);
        renderTable(events);
        setStatus('Headway loaded.');
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Failed to load headway.', true);
      }
    }

    function escapeCsv(value) {
      if (value == null) return '';
      const text = String(value);
      if (text.includes('"') || text.includes(',') || text.includes('\n')) {
        return `"${text.replace(/"/g, '""')}"`;
      }
      return text;
    }

    function formatSecondsCell(value) {
      if (value == null || Number.isNaN(Number(value))) return '';
      return Number(value).toFixed(3);
    }

    async function exportCsv() {
      try {
        setStatus('Preparing CSV export…');
        const url = buildQuery('/api/headway');
        const res = await fetch(url);
        if (!res.ok) throw new Error(`Headway fetch failed (${res.status})`);
        const data = await res.json();
        const events = Array.isArray(data.events) ? data.events : [];
        updateVehicleNameLookup(events, data.vehicle_names);
        const thresholdSeconds = getHighlightThresholdSeconds();
        const headwayField = resolveHeadwayField(headwayTypeSelect);

        const header = [
          'timestamp',
          'route_id',
          'route',
          'address_id',
          'stop',
          'bus',
          'block',
          'event',
          'arrival_type',
          'headway_arrival_arrival',
          'headway_departure_arrival',
          'dwell',
          'threshold',
        ];

        const rows = events.map(ev => {
          const exceeds = (() => {
            if (thresholdSeconds == null) return '';
            const val = ev[headwayField];
            if (val == null || Number.isNaN(Number(val))) return 'no';
            return Number(val) > thresholdSeconds ? 'yes' : 'no';
          })();
          return [
            ev.timestamp,
            ev.route_id || ev.route || '',
            ev.route_name || '',
            ev.address_id || '',
            ev.stop_name || '',
            formatVehicleLabel(ev),
            ev.block || '',
            ev.event_type,
            ev.arrival_type || '',
            formatSecondsCell(ev.headway_arrival_arrival),
            formatSecondsCell(ev.headway_departure_arrival),
            formatSecondsCell(ev.dwell_seconds),
            exceeds,
          ];
        });

        const csvText = [header, ...rows]
          .map(cols => cols.map(escapeCsv).join(','))
          .join('\n');
        const blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
        const dlUrl = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = dlUrl;
        link.download = 'headway_export.csv';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(dlUrl);
        setStatus('CSV exported.');
      } catch (err) {
        console.error(err);
        setStatus(err.message || 'Unable to export right now.', true);
      }
    }

    function clearSelections() {
      routeSelect.selectedIndex = -1;
      stopSelect.selectedIndex = -1;
      populateStops();
      summaryEl.textContent = '';
      resultsContainer.innerHTML = '<div class="empty-state">Selections cleared. Choose filters and load headway.</div>';
      setStatus('Selections cleared.');
    }

    document.getElementById('load-btn').addEventListener('click', fetchHeadway);
    document.getElementById('export-btn').addEventListener('click', exportCsv);
    document.getElementById('clear-btn').addEventListener('click', clearSelections);
    routeSelect.addEventListener('change', () => {
      populateStops(getSelected(routeSelect));
    });
    liveRouteSelect.addEventListener('change', () => {
      populateLiveStops(liveRouteSelect.value);
      liveStopSelect.value = '';
      if (liveIntervalId) stopLiveView();
    });

    document.getElementById('live-refresh-btn').addEventListener('click', fetchLiveHeadway);
    document.getElementById('live-toggle-btn').addEventListener('click', () => {
      if (liveIntervalId) {
        stopLiveView();
      } else {
        if (!liveRouteSelect.value || !liveStopSelect.value) {
          setLiveStatus('Select both a route and stop to start live view.', true);
          return;
        }
        startLiveView();
      }
    });

    setDefaults();
    loadMetadata();
  </script>
</body>
</html>
