<!DOCTYPE html>
<html>
  <head>
<link rel="icon" type="image/png" href="UTSShield.png" />
    <meta charset="utf-8" />
    <title>UTS Operations Dashboard Minimal Route Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
    <style>
      html, body {
        height: 100%;
        margin: 0;
      }
      #map {
        height: 100%;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script>
      (async () => {
        const params = new URLSearchParams(window.location.search);
        const forcedBaseURL = params.get('baseURL');
        const forcedRouteIdParam = params.get('routeId');
        const forcedRouteId = forcedRouteIdParam !== null ? Number(forcedRouteIdParam) : null;

        const DEFAULT_ROUTE_STROKE_WEIGHT = 6;
        const MIN_ROUTE_STROKE_WEIGHT = 3;
        const MAX_ROUTE_STROKE_WEIGHT = 12;
        const ROUTE_WEIGHT_ZOOM_DELTA_LIMIT = 3;
        const ROUTE_WEIGHT_STEP_PER_ZOOM = 0;

        let routeWeightReferenceZoom = null;
        let zoomStartValue = null;
        let routeLayer = null;

        function ensureContainerHasNoTransforms(element) {
          if (!element) return [];
          const cleared = [];
          element.style.transform = 'none';
          element.style.willChange = '';
          let current = element.parentElement;
          while (current && current !== document.body && current !== document.documentElement) {
            const computed = window.getComputedStyle(current);
            if (computed && computed.transform && computed.transform !== 'none') {
              cleared.push({ element: current.tagName, previousTransform: computed.transform });
              current.style.transform = 'none';
            }
            if (current.style && current.style.willChange) {
              cleared.push({ element: current.tagName, previousWillChange: current.style.willChange });
              current.style.willChange = '';
            }
            current = current.parentElement;
          }
          return cleared;
        }

        function auditPaneStyles(mapInstance, { sanitize = false } = {}) {
          const panes = mapInstance && mapInstance._panes ? mapInstance._panes : null;
          const results = [];
          if (!panes) {
            return results;
          }
          Object.entries(panes).forEach(([paneKey, paneElement]) => {
            if (!paneElement || !paneElement.style) return;
            const transform = paneElement.style.transform || '';
            const willChange = paneElement.style.willChange || '';
            const hasCustomTransform = /scale|rotate|matrix|skew/i.test(transform);
            const hasCustomWillChange = willChange && willChange !== 'auto';
            if (sanitize) {
              if (hasCustomTransform) {
                paneElement.style.transform = '';
              }
              if (hasCustomWillChange) {
                paneElement.style.willChange = '';
              }
            }
            results.push({
              pane: paneKey,
              transform,
              willChange,
              hasCustomTransform,
              hasCustomWillChange
            });
          });
          return results;
        }

        function mergeRouteLayerOptions(renderer, paneName, overrides = {}) {
          const base = {
            updateWhenZooming: false,
            updateWhenIdle: true
          };
          if (renderer) {
            base.renderer = renderer;
          }
          if (typeof paneName === 'string' && paneName) {
            base.pane = paneName;
          }
          return Object.assign(base, overrides || {});
        }

        function computeRouteStrokeWeight(zoom, referenceZoom = routeWeightReferenceZoom) {
          const baseWeight = DEFAULT_ROUTE_STROKE_WEIGHT;
          const minWeight = MIN_ROUTE_STROKE_WEIGHT;
          const maxWeight = MAX_ROUTE_STROKE_WEIGHT;
          if (!Number.isFinite(zoom)) {
            return Math.max(minWeight, Math.min(maxWeight, baseWeight));
          }
          const baselineZoom = Number.isFinite(referenceZoom) ? referenceZoom : zoom;
          const zoomDeltaRaw = zoom - baselineZoom;
          const limitedDelta = Math.max(-ROUTE_WEIGHT_ZOOM_DELTA_LIMIT, Math.min(ROUTE_WEIGHT_ZOOM_DELTA_LIMIT, zoomDeltaRaw));
          const computed = baseWeight + ROUTE_WEIGHT_STEP_PER_ZOOM * limitedDelta;
          if (!Number.isFinite(computed)) {
            return Math.max(minWeight, Math.min(maxWeight, baseWeight));
          }
          return Math.max(minWeight, Math.min(maxWeight, computed));
        }

        function setRouteWeightBaseline(zoom) {
          if (!Number.isFinite(zoom)) return;
          routeWeightReferenceZoom = zoom;
        }

        const mapElement = document.getElementById('map');
        const containerFixes = ensureContainerHasNoTransforms(mapElement);
        const map = L.map('map', { crs: L.CRS.EPSG3857 }).setView([38.03799212281404, -78.50981502838886], 15);
        const routePaneName = 'routesPane';
        map.createPane(routePaneName);
        const routesPane = map.getPane(routePaneName);
        if (routesPane) {
          routesPane.style.zIndex = 425;
          routesPane.style.pointerEvents = 'none';
        }
        const sharedRouteRenderer = L.svg({ padding: 0, pane: routePaneName });
        map.addLayer(sharedRouteRenderer);
        const paneAuditAfterInit = auditPaneStyles(map, { sanitize: true });
        console.debug('[minimal:init]', {
          containerFixes,
          sanitizedPaneStyles: paneAuditAfterInit.filter(entry => entry.hasCustomTransform || entry.hasCustomWillChange)
        });

        const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
        });
        tileLayer.addTo(map);

        function logZoomDiagnostics(stage, extra = {}) {
          const zoom = map.getZoom();
          const paneAudit = auditPaneStyles(map, { sanitize: false });
          const panesWithCustomStyles = paneAudit.filter(entry => entry.hasCustomTransform || entry.hasCustomWillChange);
          console.debug(`[minimal:${stage}]`, Object.assign({
            zoom,
            routeLayerCount: routeLayer ? 1 : 0,
            cachedPixelPointsReused: false,
            panesWithCustomStyles
          }, extra || {}));
        }

        function collectRoutePathTransformIssues() {
          const issues = [];
          if (typeof window === 'undefined') {
            return issues;
          }
          const path = routeLayer && routeLayer._path;
          if (!path) {
            return issues;
          }
          let parent = path.parentElement;
          while (parent && parent !== document.body && parent !== document.documentElement) {
            const inlineTransform = parent.style ? parent.style.transform || '' : '';
            let computedTransform = '';
            try {
              const computed = window.getComputedStyle(parent);
              if (computed && computed.transform && computed.transform !== 'none') {
                computedTransform = computed.transform;
              }
            } catch (error) {
              computedTransform = '';
            }
            const transformToCheck = inlineTransform || computedTransform;
            if (transformToCheck && transformToCheck !== 'none' && /scale|rotate|matrix|skew/i.test(transformToCheck)) {
              issues.push({
                parentTag: parent.tagName,
                transform: transformToCheck
              });
              break;
            }
            if (parent.classList && parent.classList.contains('leaflet-map-pane')) {
              break;
            }
            parent = parent.parentElement;
          }
          return issues;
        }

        map.on('zoomstart', () => {
          zoomStartValue = map.getZoom();
          logZoomDiagnostics('zoomstart', {
            oldZoom: zoomStartValue,
            newZoom: null
          });
        });

        map.on('zoom', event => {
          const targetZoom = typeof event?.zoom === 'number' ? event.zoom : map.getZoom();
          logZoomDiagnostics('zoom', { targetZoom });
        });

        map.on('zoomend', () => {
          const currentZoom = map.getZoom();
          if (!Number.isFinite(routeWeightReferenceZoom)) {
            setRouteWeightBaseline(currentZoom);
          }
          if (routeLayer && typeof routeLayer.setStyle === 'function') {
            const updatedWeight = computeRouteStrokeWeight(currentZoom);
            routeLayer.setStyle({ weight: updatedWeight });
            if (typeof routeLayer.redraw === 'function') {
              routeLayer.redraw();
            }
          }
          logZoomDiagnostics('zoomend', {
            oldZoom: zoomStartValue,
            newZoom: currentZoom,
            pathTransformIssues: collectRoutePathTransformIssues()
          });
          zoomStartValue = null;
        });

        function normalizeBaseUrl(value) {
          if (!value) return '';
          const trimmed = value.trim();
          if (trimmed === '') return '';
          if (trimmed.startsWith('http')) {
            return trimmed.replace(/^http:\/\//i, 'https://');
          }
          return `https://${trimmed}`;
        }

        async function resolveBaseURL() {
          if (forcedBaseURL) {
            return normalizeBaseUrl(forcedBaseURL);
          }
          try {
            const response = await fetch('https://admin.ridesystems.net/api/Clients/GetClients');
            const contentType = response.headers.get('content-type') || '';
            let clients = [];
            if (contentType.includes('application/json')) {
              clients = await response.json();
            } else {
              const text = await response.text();
              const parser = new DOMParser();
              const xml = parser.parseFromString(text, 'application/xml');
              clients = Array.from(xml.getElementsByTagName('Client')).map(node => ({
                Name: node.getElementsByTagName('Name')[0]?.textContent.trim(),
                WebAddress: node.getElementsByTagName('WebAddress')[0]?.textContent.trim()
              }));
            }
            const cleaned = clients
              .map(client => ({
                name: client.Name?.trim(),
                url: normalizeBaseUrl(client.WebAddress)
              }))
              .filter(entry => entry.name && entry.url);
            const uva = cleaned.find(entry => entry.name === 'University of Virginia');
            if (uva) {
              return uva.url;
            }
            return cleaned[0]?.url || '';
          } catch (error) {
            console.error('[minimal] Failed to resolve base URL', error);
            return '';
          }
        }

        const baseURL = await resolveBaseURL();
        if (!baseURL) {
          console.error('[minimal] No base URL available; aborting');
          return;
        }

        try {
          const routesResponse = await fetch(`${baseURL}/Services/JSONPRelay.svc/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=8882812681`);
          const routesData = await routesResponse.json();
          if (!Array.isArray(routesData)) {
            console.error('[minimal] Route response is not an array', routesData);
            return;
          }
          let chosenRoute = null;
          if (Number.isFinite(forcedRouteId)) {
            chosenRoute = routesData.find(route => Number(route.RouteID) === forcedRouteId);
          }
          if (!chosenRoute) {
            chosenRoute = routesData.find(route => route && route.EncodedPolyline);
          }
          if (!chosenRoute || !chosenRoute.EncodedPolyline) {
            console.error('[minimal] Unable to find a route with an encoded polyline');
            return;
          }
          const decoded = polyline.decode(chosenRoute.EncodedPolyline);
          const latLngPath = decoded.map(coords => L.latLng(coords[0], coords[1]));
          if (!Array.isArray(latLngPath) || latLngPath.length < 2) {
            console.error('[minimal] Decoded path is invalid');
            return;
          }
          const initialZoom = map.getZoom();
          if (Number.isFinite(initialZoom)) {
            setRouteWeightBaseline(initialZoom);
          }
          const routeColor = typeof chosenRoute.MapLineColor === 'string' && chosenRoute.MapLineColor.trim() !== ''
            ? chosenRoute.MapLineColor
            : '#000000';
          const initialWeight = computeRouteStrokeWeight(map.getZoom());
          routeLayer = L.polyline(latLngPath, mergeRouteLayerOptions(sharedRouteRenderer, routePaneName, {
            color: routeColor,
            weight: initialWeight,
            opacity: 1,
            lineCap: 'round',
            lineJoin: 'round'
          })).addTo(map);
          const bounds = routeLayer.getBounds();
          if (bounds && bounds.isValid && bounds.isValid()) {
            map.fitBounds(bounds, { padding: [20, 20] });
          }
          logZoomDiagnostics('loaded', {
            baseURL,
            routeId: chosenRoute.RouteID
          });
        } catch (error) {
          console.error('[minimal] Failed to load route data', error);
        }
      })();
    </script>
  </body>
</html>
