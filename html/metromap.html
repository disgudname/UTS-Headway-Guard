<!DOCTYPE html>
<html>
<head>
<link rel="icon" type="image/png" href="headwayguardicon.png" />
  <title>Metro Map - Headway Guard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
  <style>
    html, body, #metroMap {
      height: 100%;
      margin: 0;
      width: 100%;
    }
    #metroMap {
      background: #ffffff;
    }
  </style>
</head>
<body>
  <svg id="metroMap"></svg>
  <script>
    const MERGE_TOLERANCE = 4e-4;
    async function fetchActiveRouteShapes() {
      const resp = await fetch('/v1/routes');
      const data = await resp.json();
      const active = data.routes.filter(r => r.active_vehicles > 0);
      const shapes = await Promise.all(active.map(async (r) => {
        const s = await fetch(`/v1/routes/${r.id}/shape`).then(x => x.json());
        const pts = polyline.decode(s.polyline).map(p => ({ lat: p[0], lon: p[1] }));
        if (pts.length > 1) {
          const start = pts[0];
          const end = pts[pts.length - 1];
          if (Math.abs(start.lat - end.lat) + Math.abs(start.lon - end.lon) > 0) {
            pts[pts.length - 1] = { ...start };
          }
        }
        return {
          id: r.id,
          color: s.color,
          pts
        };
      }));
      return shapes;
    }

    // Lines are rendered using their native geometry without snapping to fixed angles.

    function keyForSeg(seg) {
      const r = v => Math.round(v * 1e5) / 1e5;
      const a = [r(seg.start.lat), r(seg.start.lon), r(seg.end.lat), r(seg.end.lon)];
      if (a[0] > a[2] || (a[0] === a[2] && a[1] > a[3])) {
        [a[0], a[1], a[2], a[3]] = [a[2], a[3], a[0], a[1]];
      }
      return a.join(',');
    }

    function prepareSegments(shapes) {
      const segs = {};
      const dist = (a, b) => Math.hypot(a.lon - b.lon, a.lat - b.lat);
      for (const route of shapes) {
        const pts = route.pts.map(p => ({ ...p }));
        for (let i = 1; i < pts.length; i++) {
          const seg = { start: pts[i - 1], end: pts[i] };
          let key = null;
          let reverse = false;
          for (const [k, s] of Object.entries(segs)) {
            if (dist(seg.start, s.start) < MERGE_TOLERANCE && dist(seg.end, s.end) < MERGE_TOLERANCE) {
              key = k; break;
            }
            if (dist(seg.start, s.end) < MERGE_TOLERANCE && dist(seg.end, s.start) < MERGE_TOLERANCE) {
              key = k; reverse = true; break;
            }
          }
          if (!key) {
            key = keyForSeg(seg);
            if (!segs[key]) segs[key] = { start: seg.start, end: seg.end, routes: [] };
          }
          const target = segs[key];
          pts[i] = reverse ? target.start : target.end;
          if (!target.routes.find(r => r.id === route.id)) {
            target.routes.push({ id: route.id, color: route.color });
          }
        }
      }
      return segs;
    }

    function project(lat, lon, box, width, height) {
      const x = (lon - box.minLon) / (box.maxLon - box.minLon) * width;
      const y = height - (lat - box.minLat) / (box.maxLat - box.minLat) * height;
      return [x, y];
    }

    function render(segs) {
      const svg = document.getElementById('metroMap');
      const width = svg.clientWidth || window.innerWidth;
      const height = svg.clientHeight || window.innerHeight;
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
      Object.values(segs).forEach(s => {
        minLat = Math.min(minLat, s.start.lat, s.end.lat);
        maxLat = Math.max(maxLat, s.start.lat, s.end.lat);
        minLon = Math.min(minLon, s.start.lon, s.end.lon);
        maxLon = Math.max(maxLon, s.start.lon, s.end.lon);
      });
      const box = { minLat, maxLat, minLon, maxLon };
      const STROKE_WIDTH = 6;
      const offset = STROKE_WIDTH;
      for (const seg of Object.values(segs)) {
        const [x1, y1] = project(seg.start.lat, seg.start.lon, box, width, height);
        const [x2, y2] = project(seg.end.lat, seg.end.lon, box, width, height);
        const dx = x2 - x1, dy = y2 - y1;
        const len = Math.hypot(dx, dy);
        const ux = dx / len, uy = dy / len;
        const px = -uy, py = ux;
        const routes = seg.routes;
        routes.forEach((r, idx) => {
          const off = (idx - (routes.length - 1) / 2) * offset;
          const sx1 = x1 + px * off;
          const sy1 = y1 + py * off;
          const sx2 = x2 + px * off;
          const sy2 = y2 + py * off;
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', sx1);
          line.setAttribute('y1', sy1);
          line.setAttribute('x2', sx2);
          line.setAttribute('y2', sy2);
          line.setAttribute('stroke', r.color || '#000');
          line.setAttribute('stroke-width', STROKE_WIDTH);
          line.setAttribute('stroke-linecap', 'round');
          svg.appendChild(line);
        });
      }
    }

    async function init() {
      const shapes = await fetchActiveRouteShapes();
      const segs = prepareSegments(shapes);
      render(segs);
    }
    init();
  </script>
</body>
</html>
