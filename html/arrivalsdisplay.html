<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" type="image/png" href="UTSShield.png" />
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Bus Arrival Predictions</title>
<style>
  @font-face { font-family: 'FGDC'; src: url('FGDC.ttf'); }
  body { font-family:'FGDC',sans-serif; margin:0; overflow:hidden; background:#232D4B; font-size:1.75em; padding-bottom:5rem; }
  header { position:relative; background:#232D4B; opacity:.9; text-align:center; width:100vw; }
  table { width:100%; margin:0; text-align:center; border-collapse:collapse; table-layout:fixed; }
  th,td { font-size:1.25em; border:none; text-transform:uppercase; padding:10px 0; margin:0; overflow:hidden; height:50px; width:33%; vertical-align:middle; }
  th { background:#E57200; color:#fff; }
  .capacity-bar-container { width:90%; height:20px; background:#ddd; border-radius:5px; overflow:hidden; position:relative; margin:0 auto; }
  .capacity-bar { height:100%; text-align:right; padding-right:5px; line-height:20px; color:#fff; border-radius:5px; }

  *{box-sizing:border-box;}
  @keyframes ticker{0%{transform:translate3d(0,0,0);visibility:visible;}100%{transform:translate3d(-100%,0,0);}}
  .ticker-wrap { position:fixed; bottom:80px; left:0; width:50%; overflow:hidden; height:4rem; background:rgba(0,0,0,.9); padding-left:0; box-sizing:content-box; display:none; }
  .ticker { display:inline-block; height:4rem; line-height:4rem; white-space:nowrap; padding-left:100%; padding-right:100%; box-sizing:content-box; animation: ticker 30s linear infinite; }
  .ticker__item { display:inline-block; padding:0 2rem; font-size:3rem; color:#fff; }
  .ticker__separator { display:inline-block; padding:0 1rem; font-size:2rem; color:#fff; }
  h1,h2,p{padding:0 5%;}

  .footer { position:fixed; bottom:0; width:100%; height:80px; background:#E57200; color:#fff; display:flex; justify-content:space-between; align-items:center; padding:0 20px; box-sizing:border-box; }
  .footer-left { font-size:3em; text-align:left; }
  .footer-right { text-align:right; font-size:1.2em; }

  /* Optional: primer button; harmless if autoplay policy is fixed */
  #audio-primer {
    position: fixed; top: 10px; right: 10px; z-index: 9999;
    background: #fff; color:#000; border:1px solid #ccc; border-radius:8px;
    padding: 6px 10px; font: 14px system-ui, sans-serif; cursor: pointer;
  }
  #audio-primer[hidden]{ display:none; }

  /* ===== Announcement Banner (overlays stop name) ===== */
  #header-inner { position: relative; padding: 10px 0; }
  #stop-name { color:#fff; font-size:3em; text-transform:uppercase; margin:0; transition: visibility .2s ease; }
  #announce-banner {
    position:absolute; inset:0;
    display:none; /* shown only while announcing */
    overflow:hidden;
    background:#232D4B; /* match header bg */
    z-index: 5;
  }
  #announce-track {
    position:absolute; top:50%; transform: translateY(-50%); /* X handled by animation */
    white-space: nowrap;
    will-change: transform;
  }
  #announce-text { color:#fff; font-size:3em; text-transform:uppercase; padding: 0 5%; display:inline-block; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.21.1/axios.min.js"></script>
<script>
/* ===================== Utilities ===================== */
let arrivalInterval, alertInterval, currentStopID;
function getParameterByName(name){ const p=new URLSearchParams(window.location.search); return p.get(name); }

/* ===================== Alerts (Ticker) ===================== */
async function fetchAlerts(){
  try{
    const showInactive=getParameterByName('showInactiveAlerts')==='true';
    const r=await axios.get('https://uva.transloc.com/Secure/Services/RoutesService.svc/GetMessagesPaged',{
      params:{showInactive,includeDeleted:false,messageTypeId:1,search:false,rows:10,page:1,sortIndex:'StartDateUtc',sortOrder:'asc'}
    });
    const msgs=r.data.Rows.map(a=>a.MessageText);
    updateTicker(msgs);
  }catch(e){ console.error("[alerts] error",e); }
}
function updateTicker(msgs){
  const wrap=document.querySelector('.ticker-wrap');
  const cont=document.getElementById('alerts-container');
  cont.innerHTML='';
  if(!msgs.length){ wrap.style.display='none'; return; }
  wrap.style.display='block';
  msgs.forEach((m,i)=>{
    const d=document.createElement('div'); d.className='ticker__item'; d.textContent=m; cont.appendChild(d);
    if(i<msgs.length-1){ const s=document.createElement('span'); s.className='ticker__separator'; s.textContent=' • '; cont.appendChild(s); }
  });
}

/* ===================== Data Fetch ===================== */
async function fetchArrivalTimes(stopID){
  try{
    const r=await axios.get('https://uva.transloc.com/Services/JSONPRelay.svc/GetStopArrivalTimes',{params:{APIKey:'8882812681',stopIDs:stopID}});
    if(r.data&&r.data.length>0){
      const stopName=r.data[0].StopDescription||'Bus Arrival Predictions';
      document.getElementById('stop-name').textContent=stopName.replace(/\(.*\)/,'').trim();
    }
    const vc=await fetchVehicleCapacities();
    updateArrivalTable(r.data,vc);
  }catch(e){ console.error("[arrivals] error",e); }
}
async function fetchVehicleCapacities(){
  try{
    const r=await axios.get('https://uva.transloc.com/Services/JSONPRelay.svc/GetVehicleCapacities',{params:{APIKey:'8882812681'}});
    return r.data;
  }catch(e){ console.error("[capacities] error",e); return []; }
}

/* ===================== VoicePicker (simple) ===================== */
const VoicePicker=(()=>{
  const STORE_KEY="preferredVoiceName";
  const ORDER=[
    "Google UK English Female",
    "Google US English",
    "Microsoft Zira - English (United States)",
    "Microsoft Mark - English (United States)",
    "Microsoft David - English (United States)"
  ];
  let ready=false, selected=null;

  function pick(voices){
    const override=new URLSearchParams(location.search).get("voice");
    if(override){ const v=voices.find(v=>v.name===override); if(v){ return v; } }
    const stored=localStorage.getItem(STORE_KEY);
    if(stored){ const v=voices.find(v=>v.name===stored); if(v){ return v; } }
    for(const name of ORDER){ const v=voices.find(v=>v.name===name); if(v) return v; }
    return voices.find(v=>/^en-(US|GB)/i.test(v.lang))||voices[0]||null;
  }
  function load(){ const voices = (window.speechSynthesis||{}).getVoices?.()||[]; return voices.length? pick(voices): null; }
  function init(){
    if(!("speechSynthesis" in window)){ return; }
    const attempt=()=>{ const v=load(); if(v){ selected=v; localStorage.setItem(STORE_KEY,v.name); ready=true; } };
    attempt();
    speechSynthesis.onvoiceschanged=()=>{ if(!ready) attempt(); };
  }
  return { init, get:()=>selected, isReady:()=>ready };
})();

/* ===================== Optional Audio Primer ===================== */
const AudioPrimer=(()=>{
  const KEY="audioPrimed";
  let primed=false, ctx=null;
  function isPrimed(){ return primed; }
  function showButton(){
    let btn=document.getElementById('audio-primer');
    if(!btn){ btn=document.createElement('button'); btn.id='audio-primer'; btn.textContent='Enable Audio'; document.body.appendChild(btn); }
    btn.hidden=false; btn.onclick=prime;
  }
  function hideButton(){ const btn=document.getElementById('audio-primer'); if(btn) btn.hidden=true; }
  function prime(){
    try{
      ctx = ctx || new (window.AudioContext||window.webkitAudioContext)();
      const o=ctx.createOscillator(); const g=ctx.createGain();
      o.connect(g); g.connect(ctx.destination); g.gain.value=0.001; o.frequency.value=440; o.start(); setTimeout(()=>o.stop(),60);
      try { speechSynthesis.cancel(); speechSynthesis.resume(); } catch(e){}
      const u=new SpeechSynthesisUtterance("Audio enabled."); const v=VoicePicker.get(); if(v) u.voice=v; speechSynthesis.speak(u);
      primed=true; localStorage.setItem(KEY,"1"); hideButton();
    }catch(e){}
  }
  function init(){
    primed = localStorage.getItem(KEY)==="1";
    if(!primed) showButton(); else hideButton();
  }
  return { init, isPrimed };
})();

/* ===================== Announcement Banner (pixel-based; gates the queue) ===================== */
const AnnounceBanner = (()=>{
  // Adjust speed (px/s)
  const SPEED_PX_PER_S = 380;

  const elBanner = () => document.getElementById('announce-banner');
  const elTrack  = () => document.getElementById('announce-track');
  const elText   = () => document.getElementById('announce-text');
  const elStop   = () => document.getElementById('stop-name');

  let anim = null;
  let running = false;

  function sanitize(s){
    return (s||"").replace(/,/g,'').replace(/\s+/g,' ').trim();
  }
  async function waitFonts(){
    try{ if(document.fonts && document.fonts.ready){ await document.fonts.ready; } }catch(e){}
  }
  function show(){ const b=elBanner(); if(!b) return; b.style.display='block'; elStop().style.visibility='hidden'; }
  function hide(){ const b=elBanner(); if(!b) return; b.style.display='none';  elStop().style.visibility='visible'; }

  async function start(rawText){
    const b=elBanner(), t=elTrack(), tx=elText();
    if(!b||!t||!tx) return;

    const text = sanitize(rawText);
    if(!text) return;

    // Cancel prior anim if any (we only call start when queue decides it's our turn)
    if(anim){ try{ anim.cancel(); }catch{} anim=null; }

    tx.textContent = text;
    show();

    await waitFonts();
    await new Promise(r=>requestAnimationFrame(()=>requestAnimationFrame(r)));

    const wrapW = b.getBoundingClientRect().width || 1;
    const textW = tx.getBoundingClientRect().width || 1;
    const distance = wrapW + textW;
    const duration = Math.max(distance / SPEED_PX_PER_S, 1.5) * 1000;

    t.style.transform = 'translateY(-50%)';
    running = true;

    anim = t.animate(
      [{ transform:`translate(${wrapW}px, -50%)` },
       { transform:`translate(${-textW}px, -50%)` }],
      { duration, iterations:1, easing:'linear', fill:'forwards' }
    );

    return new Promise(resolve=>{
      const cleanup = ()=>{ running=false; hide(); anim=null; resolve(); };
      anim.onfinish = cleanup;
      anim.oncancel = cleanup;
    });
  }

  function isRunning(){ return running; }

  return { start, isRunning };
})();

/* ===================== Speech Queue (delays next until banner finishes) ===================== */
const SpeechQueue=(()=>{
  const q=[]; let speaking=false; let draining=false;

  function speak(text){
    q.push(text);
    drain();
  }

  async function drain(){
    if(draining) return;
    draining = true;
    try{
      // Gate on both: no overlap
      if(speaking || AnnounceBanner.isRunning()) return;

      const next = q.shift();
      if(!next) return;

      // 1) Start the banner and wait a tiny tick so it becomes visible
      const bannerPromise = AnnounceBanner.start(next);

      // 2) Start TTS
      const u = new SpeechSynthesisUtterance(next);
      const v = VoicePicker.get(); if(v) u.voice=v;
      u.rate=1.0; u.pitch=1.0; u.volume=1.0;

      const speechDone = new Promise(res=>{
        u.onend = ()=>{ speaking=false; res(); };
        u.onerror=()=>{ speaking=false; res(); };
      });
      speaking = true;
      try{ speechSynthesis.resume?.(); }catch(e){}
      try{ speechSynthesis.speak(u); }catch(e){ speaking=false; }

      // 3) Wait for BOTH: speech + banner scroll completion
      try{ await Promise.all([speechDone, bannerPromise]); }catch(e){ /* ignore */ }

      // 4) Move to the next only AFTER banner has ended
    } finally {
      draining = false;
      // If more are queued, try again
      if(q.length && !speaking && !AnnounceBanner.isRunning()){
        // Give the browser a breath
        setTimeout(drain, 0);
      }
    }
  }

  // Watchdog to recover if speech stalls but banner ended
  setInterval(()=>{
    if(typeof speechSynthesis!=="undefined"){
      if(speechSynthesis.paused){ try{ speechSynthesis.resume(); }catch(e){} }
      if(!AnnounceBanner.isRunning() && !speaking && q.length){
        drain();
      }
    }
  }, 8000);

  return { speak };
})();

/* ===================== Announcement Engine — leader-only thresholds + precise “missed bus” ===================== */
const Announcement=(()=>{
  // Tunables
  const THRESHOLDS = [10,5,1];
  const WINDOW_MIN = 0.5;            // ±30s threshold window
  const REARM_JUMP_MIN = 6;          // ETA jump later by >=6m → re-arm 10/5
  const NEW_LAP_AFTER_MIN = 8;       // If ETA was ≤1.5 then jumps to ≥8 → new lap
  const COOLDOWN_MS = 2 * 60 * 1000; // per-vehicle-threshold cooldown
  const STATE_TTL_MS = 8 * 60 * 60 * 1000;

  const perVeh = Object.create(null); // `${vehId}@${stop}` -> { lastEta, announced:{10,5,1}, cooldown:{10,5,1}, ts }
  const perRoute = Object.create(null); // route -> { leaderId, lastEta, ts }

  function stopKey(){ return currentStopID || 'stop'; }
  function vehKey(id){ return `${id||'nv'}@${stopKey()}`; }

  function sayThreshold(route, th){
    let msg="";
    if(th===10) msg = `The next, ${route}, bus, will arrive in, approximately ten minutes.`;
    else if(th===5) msg = `The next, ${route}, bus, will arrive in, approximately five minutes.`;
    else if(th===1) msg = `The next, ${route}, bus, is approaching the station. Please stand away from the platform edge.`;
    if(msg) SpeechQueue.speak(msg);
  }
  function sayNextEta(route, minutes){
    const txt = minutes <= 1 ? "less than one minute" : `${minutes} minutes`;
    SpeechQueue.speak(`The next, ${route}, bus, will arrive in, approximately ${txt}.`);
  }

  function prune(now){
    const cutoff = now - STATE_TTL_MS;
    for(const k in perVeh){ if(perVeh[k].ts < cutoff) delete perVeh[k]; }
    for(const r in perRoute){ if(perRoute[r].ts < cutoff) delete perRoute[r]; }
  }

  function processThresholdsForLeader(v){ // v: {vehicleId, route, etaMin}
    const now = Date.now();
    const vk = vehKey(v.vehicleId);
    let s = perVeh[vk];
    if(!s){
      s = perVeh[vk] = { lastEta: v.etaMin, announced:{10:false,5:false,1:false}, cooldown:{10:0,5:0,1:0}, ts: now };
    }
    s.ts = now;

    // New lap re-arm
    if(s.lastEta <= 1.5 && v.etaMin >= NEW_LAP_AFTER_MIN){
      s.announced = {10:false,5:false,1:false};
      s.cooldown  = {10:0,5:0,1:0};
    }

    // Holding/layover jump → re-arm 10/5
    if(v.etaMin - s.lastEta >= REARM_JUMP_MIN){
      s.announced[10]=false; s.cooldown[10]=0;
      s.announced[5]=false;  s.cooldown[5]=0;
      // 1-minute remains once per lap
    }

    // Thresholds (leader-only) with strict downward crossing
    THRESHOLDS.forEach(th=>{
      if(s.announced[th]) return;
      if(now < s.cooldown[th]) return;

      const strictCross = (s.lastEta >= th + 1) && (v.etaMin <= th + WINDOW_MIN);
      if(strictCross){
        sayThreshold(v.route, th);
        s.announced[th] = true;
        s.cooldown[th]  = now + COOLDOWN_MS;
      }
    });

    s.lastEta = v.etaMin;
  }

  function handle(list){
    if(!list || !list.length) return;
    const now = Date.now();
    prune(now);

    // Build per-route sorted lists (ascending ETA)
    const byRoute = new Map(); // route -> [{vehicleId, eta, route}]
    for(const a of list){
      const route = (a.routeDescription || 'Route').toString();
      if(a.vehicleId==null) continue;
      if(!byRoute.has(route)) byRoute.set(route, []);
      byRoute.get(route).push({ vehicleId:a.vehicleId, eta:a.minutesUntilArrival, route });
    }
    for(const arr of byRoute.values()) arr.sort((x,y)=>x.eta - y.eta);

    // Process each route
    for(const [route, arr] of byRoute.entries()){
      const leader = arr[0];
      const prev = perRoute[route];

      // Thresholds for current leader only
      if(leader) processThresholdsForLeader({ vehicleId: leader.vehicleId, route, etaMin: leader.eta });

      // Departure logic (swap or lap)
      if(prev){
        let departed = false;
        let departedId = prev.leaderId;

        if(leader){
          // Leader swap
          if(prev.leaderId != null && String(leader.vehicleId) !== String(prev.leaderId)){
            departed = true;
          }
          // Same leader but ETA jumped up after near-zero -> new lap
          else if(prev.leaderId != null && String(leader.vehicleId) === String(prev.leaderId)) {
            if(prev.lastEta <= 1.5 && leader.eta >= NEW_LAP_AFTER_MIN){
              departed = true;
            }
          }
        } else if(prev.leaderId != null){
          departed = true;
        }

        if(departed && departedId != null){
          const candidates = arr.filter(v => String(v.vehicleId) !== String(departedId));
          let nextMinutes = null;

          if(candidates.length){ nextMinutes = candidates[0].eta; }
          else if(leader){ nextMinutes = leader.eta; }

          if(nextMinutes != null){ sayNextEta(route, nextMinutes); }
        }
      }

      // Update route snapshot
      perRoute[route] = { leaderId: leader ? leader.vehicleId : null, lastEta: leader ? leader.eta : Infinity, ts: now };
    }
  }

  return { handle };
})();

/* ===================== Render Table (includes vehicleId) ===================== */
function updateArrivalTable(data, vc){
  const body=document.getElementById('arrival-body');
  body.innerHTML='';
  if(data && data.length>0){
    const rows=[];
    data.forEach(arr=>{
      if(arr.Times && arr.Times.length){
        arr.Times.forEach(t=>{
          if(t.Seconds!==null && t.VehicleId!==undefined){
            const cap=vc.find(x=>x.VehicleID===t.VehicleId);
            if(cap){
              rows.push({
                vehicleId: t.VehicleId,
                routeDescription: arr.RouteDescription==='Night Pilot' ? arr.RouteDescription : (arr.RouteDescription||'N/A').replace(/\.$/, ''),
                color: arr.Color||'#0072BC',
                minutesUntilArrival: Math.ceil(t.Seconds/60),
                capacityPercentage: Math.round(cap.Percentage*100)
              });
            }
          }
        });
      }
    });

    rows.sort((a,b)=>a.minutesUntilArrival-b.minutesUntilArrival);

    // Announcements AFTER full snapshot
    Announcement.handle(rows);

    // Render top 10
    rows.slice(0,10).forEach(r=>{
      const textColor=getContrastColor(r.color);
      const capColor=r.capacityPercentage>=62?'#FF0000':'#4CAF50';
      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td>
          <span style="display:inline-block;padding:5px 15px;border-radius:25px;background-color:${r.color};color:${textColor};${r.routeDescription.toLowerCase()==='night pilot'?'border:2px solid white;':''}">
            ${r.routeDescription}
          </span>
        </td>
        <td style="color:#fff;">${r.minutesUntilArrival} min</td>
        <td>
          <div class="capacity-bar-container">
            <div class="capacity-bar" style="width:${r.capacityPercentage}%;background-color:${capColor};"></div>
          </div>
        </td>`;
      body.appendChild(tr);
    });
  }else{
    const tr=document.createElement('tr');
    tr.innerHTML='<td colspan="3" style="color:#fff;text-align:center;padding:15px 0;">No upcoming arrivals found.</td>';
    body.appendChild(tr);
  }
}

/* ===================== Helpers ===================== */
function getContrastColor(hex){ hex=hex.replace('#',''); const r=parseInt(hex.substring(0,2),16),g=parseInt(hex.substring(2,4),16),b=parseInt(hex.substring(4,6),16); const lum=(0.299*r+0.587*g+0.114*b)/255; return lum>0.565?'black':'white'; }

function getStopIDFromQuery(){
  const stopParam=(getParameterByName('stopid')||getParameterByName('stopID')||'').trim();
  return stopParam||null;
}

function showMissingStopMessage(){
  const body=document.getElementById('arrival-body');
  if(body){
    body.innerHTML='<tr><td colspan="3" style="color:#fff;text-align:center;padding:15px 0;">Add ?stopid=YOUR_STOP_ID to the URL to load arrivals.</td></tr>';
  }
  const header=document.getElementById('stop-name');
  if(header){
    header.textContent='STOP ID REQUIRED';
  }
}

function initStop(){
  const stop=getStopIDFromQuery();
  if(!stop){
    showMissingStopMessage();
    return;
  }
  currentStopID=stop;
  fetchArrivalTimes(currentStopID);
  arrivalInterval=setInterval(()=>{ if(currentStopID) fetchArrivalTimes(currentStopID); },30000);
}

/* ===================== Boot ===================== */
document.addEventListener('DOMContentLoaded',()=>{
  VoicePicker.init();
  AudioPrimer.init(); // harmless if autoplay already allowed

  initStop();

  fetchAlerts();
  alertInterval=setInterval(fetchAlerts,15000);

  window.addEventListener('focus', ()=>{ try{ speechSynthesis.resume(); }catch(e){} });
});
</script>
</head>
<body>
  <button id="audio-primer" hidden>Enable Audio</button>

  <header>
    <div id="header-inner">
      <!-- Normal stop name -->
      <h1 id="stop-name">BUS PREDICTIONS UNAVAILABLE</h1>

      <!-- Announcement banner overlay -->
      <div id="announce-banner">
        <div id="announce-track">
          <span id="announce-text"></span>
        </div>
      </div>
    </div>
  </header>

  <div style="width:50%; height:calc(100vh - 160px); float:left; display:block;">
    <table id="arrival-table" style="table-layout:fixed;">
      <thead>
        <tr style="background:#E57200;">
          <th style="color:#fff;">Route</th>
          <th style="color:#fff;">ETA</th>
          <th style="color:#fff;">Capacity</th>
        </tr>
      </thead>
      <tbody id="arrival-body">
        <tr><td colspan="3" style="height:50px; line-height:50px; text-align:center; padding:15px 0;">Arrival estimates currently unavailable</td></tr>
      </tbody>
    </table>
  </div>

  <div style="width:50%; height:calc(100vh - 160px); float:right; display:block;">
    <iframe src="/map?kioskMode=true&adminMode=false" style="width:100%; height:100%; border:none;"></iframe>
  </div>

  <div class="ticker-wrap"><div class="ticker" id="alerts-container"></div></div>

  <div class="footer">
    <div class="footer-left">UNIVERSITY TRANSIT SERVICE</div>
    <div class="footer-right">
      <div>PARKING.VIRGINIA.EDU</div>
      <div>434.924.7711</div>
    </div>
  </div>
</body>
</html>


