<!doctype html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="/media/favicon.ico" />
<link rel="apple-touch-icon" sizes="120x120" href="/media/apple-touch-icon-120.png" />
<link rel="apple-touch-icon" sizes="152x152" href="/media/apple-touch-icon-152.png" />
<link rel="apple-touch-icon" sizes="180x180" href="/media/apple-touch-icon-180.png" />
  <meta charset="utf-8" />
  <title>PulsePoint Incidents — Decrypted Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 24px; }
    h1 { margin: 0 0 8px; font-size: 20px; }
    .controls { display: flex; gap: 8px; align-items: center; margin: 12px 0 16px; flex-wrap: wrap; }
    input[type="text"] { padding: 8px; min-width: 280px; }
    button { padding: 8px 12px; cursor: pointer; }
    table { width: 100%; border-collapse: collapse; font-size: 14px; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
    th { background: #fafafa; cursor: pointer; position: sticky; top: 0; }
    .muted { color: #666; font-size: 12px; }
    .status { margin: 8px 0; }
    .pill { display:inline-block; padding:2px 6px; border-radius: 12px; background:#f2f2f2; font-size:12px; }
    .marker-cell { width: 44px; text-align: center; }
    .marker-cell img { max-width: 32px; height: auto; display: inline-block; }
  </style>
</head>
<body>
  <h1>PulsePoint Incidents — Decrypted Viewer</h1>
  <div class="muted">Source: <code>/v1/pulsepoint/incidents</code></div>

  <div class="controls">
    <input id="search" type="text" placeholder="Filter (address, type, ID, units…)" />
    <button id="refresh">Refresh</button>
    <button id="downloadCsv">Download CSV</button>
    <span id="count" class="muted"></span>
  </div>

  <div id="status" class="status muted"></div>

  <table id="grid">
    <thead>
      <tr>
        <th class="marker-col">Marker</th>
        <th data-key="_category">Category</th>
        <th data-key="ID">ID</th>
        <th data-key="PulsePointIncidentCallType">Type</th>
        <th data-key="FullDisplayAddress">Address</th>
        <th data-key="CallReceivedDateTime">Received</th>
        <th data-key="AgencyID">Agency</th>
        <th data-key="Latitude">Lat</th>
        <th data-key="Longitude">Lon</th>
        <th data-key="_units">Units</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

<script>
(async function () {
  const ENDPOINT = "/v1/pulsepoint/incidents";
  const INCIDENT_LIST_ICON_BASE_URL = '/v1/pulsepoint/respond_icons/';

  const $status   = document.getElementById("status");
  const $tbody    = document.querySelector("#grid tbody");
  const $search   = document.getElementById("search");
  const $count    = document.getElementById("count");
  const $refresh  = document.getElementById("refresh");
  const $download = document.getElementById("downloadCsv");

  // Add a tiny debug area
  const $debug = document.createElement("pre");
  $debug.className = "muted";
  $debug.style.whiteSpace = "pre-wrap";
  $debug.style.maxHeight = "200px";
  $debug.style.overflow = "auto";
  $debug.style.border = "1px solid #eee";
  $debug.style.padding = "8px";
  $debug.style.margin = "12px 0";
  $debug.textContent = "Debug output will appear here.";
  document.body.insertBefore($debug, document.getElementById("grid"));

  function setStatus(msg){ $status.textContent = msg || ""; }

  async function fetchIncidents() {
    const res = await fetch(ENDPOINT, { method: "GET", mode: "cors", cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return res.json();
  }


  function looksIncidentish(obj){
    if (!obj || typeof obj !== "object") return false;
    const keys = Object.keys(obj);
    // Heuristics: has any of these fields
    const hits = ["ID","FullDisplayAddress","PulsePointIncidentCallType","CallReceivedDateTime","Latitude","Longitude"]
      .filter(k => k in obj).length;
    return hits >= 2;
  }

  function normaliseIncidents(root) {
    // Preferred shape: { incidents: { active:[], recent:[], alerts:[] } }
    const out = [];

    const inc = root && root.incidents;
    const categories = [["active","active"],["recent","recent"],["alerts","alerts"]];
    let pulled = 0;

    if (inc && typeof inc === "object") {
      for (const [catKey, label] of categories) {
        const arr = Array.isArray(inc[catKey]) ? inc[catKey] : [];
        arr.forEach(rec => out.push(decorate(rec, label)));
        pulled += arr.length;
      }
      if (pulled) return out;
    }

    // Fallbacks:

    // A) Some feeds put incidents under e.g. { data: { incidents: [...] } }
    for (const k1 of Object.keys(root || {})) {
      const v1 = root[k1];
      if (Array.isArray(v1) && v1.every(looksIncidentish)) {
        v1.forEach(rec => out.push(decorate(rec, k1)));
      } else if (v1 && typeof v1 === "object") {
        for (const k2 of Object.keys(v1)) {
          const v2 = v1[k2];
          if (Array.isArray(v2) && v2.every(looksIncidentish)) {
            v2.forEach(rec => out.push(decorate(rec, k2)));
          }
        }
      }
    }
    if (out.length) return out;

    // B) Brute-force: find ANY array of incident-like objects anywhere
    (function dig(x, label="misc"){
      if (!x) return;
      if (Array.isArray(x) && x.length && looksIncidentish(x[0])) {
        x.forEach(rec => out.push(decorate(rec, label)));
        return;
      }
      if (typeof x === "object") {
        for (const k of Object.keys(x)) dig(x[k], k);
      }
    })(root);

    return out;
  }

  function decorate(rec, category){
    const copy = { ...rec, _category: category };
    if (Array.isArray(copy.Unit)) {
      copy._units = copy.Unit.map(u => {
        const id = u.UnitID || u.Unit || "";
        const st = u.PulsePointDispatchStatus || u.Status || "";
        return st ? `${id} (${st})` : id;
      }).join(", ");
    } else {
      copy._units = "";
    }
    const markerCategory = (category || "").toLowerCase();
    const markerType = inferMarkerType(copy);
    const markerUrl = buildMarkerUrl(markerType, markerCategory);
    copy._markerType = markerType;
    copy._markerCategory = markerUrl ? markerCategory : "";
    copy._markerUrl = markerUrl;
    copy._markerAlt = markerUrl ? markerAltText(markerType, markerCategory, copy.PulsePointIncidentCallType) : "";
    return copy;
  }

  function inferMarkerType(rec) {
    const candidates = [
      rec.PulsePointIncidentCallTypePrimaryCode,
      rec.PulsePointIncidentCallTypeCode,
      rec.PulsePointIncidentCallTypeID,
      rec.PulsePointIncidentTypeCode,
      rec.PulsePointIncidentType,
      rec.CallTypeCode,
      rec.TypeCode,
      rec.CallType,
      rec.Type,
      rec.IncidentType,
      rec.PulsePointIncidentCallType
    ];
    for (const value of candidates) {
      if (value == null) continue;
      const raw = typeof value === "number" ? value.toString() : String(value);
      const trimmed = raw.trim();
      if (!trimmed) continue;
      if (/^[A-Za-z0-9]{1,6}$/.test(trimmed)) return trimmed.toUpperCase();
      const firstToken = trimmed.split(/[\s/-]+/)[0];
      if (firstToken && /^[A-Za-z0-9]{1,4}$/.test(firstToken)) return firstToken.toUpperCase();
      const words = trimmed.match(/[A-Za-z0-9]+/g);
      if (words && words.length >= 2) {
        const acronym = words.map(w => w[0]).join("");
        if (acronym && /^[A-Za-z0-9]{1,4}$/.test(acronym)) return acronym.toUpperCase();
      }
    }
    return "";
  }

  function buildMarkerUrl(type, category) {
    const cat = (category || "").toLowerCase();
    if (!type || (cat !== "active" && cat !== "recent")) return "";
    return `${INCIDENT_LIST_ICON_BASE_URL}${type.toLowerCase()}_map_${cat}.png`;
  }

  function markerAltText(type, category, fallback) {
    const parts = [];
    if (type) parts.push(type);
    if (category) parts.push(category);
    if (!parts.length && fallback) parts.push(fallback);
    if (!parts.length) return "Marker icon";
    parts.push("marker icon");
    return parts.join(" ");
  }

  // ---------- Rendering / UX ----------
  let ROWS = [];
  let sortKey = "CallReceivedDateTime";
  let sortDir = -1;

  function render(rows) {
    $tbody.innerHTML = rows.map(r => `
      <tr>
        <td class="marker-cell">${markerCell(r)}</td>
        <td><span class="pill">${esc(r._category)}</span></td>
        <td>${esc(r.ID)}</td>
        <td>${esc(r.PulsePointIncidentCallType)}</td>
        <td>${esc(r.FullDisplayAddress)}</td>
        <td>${esc(r.CallReceivedDateTime)}</td>
        <td>${esc(r.AgencyID)}</td>
        <td>${esc(r.Latitude)}</td>
        <td>${esc(r.Longitude)}</td>
        <td>${esc(r._units)}</td>
      </tr>
    `).join("");
    $count.textContent = rows.length ? `${rows.length} rows` : "No rows";
  }

  function esc(v){ return String(v ?? "").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

  function markerCell(row) {
    if (!row._markerUrl) return "";
    const altText = row._markerAlt || markerAltText(row._markerType, row._markerCategory, row.PulsePointIncidentCallType);
    return `<img src="${esc(row._markerUrl)}" alt="${esc(altText)}" title="${esc(altText)}" loading="lazy" />`;
  }

  function applyFilter() {
    const q = $search.value.trim().toLowerCase();
    let filtered = ROWS;
    if (q) {
      filtered = ROWS.filter(r => {
        const hay = [
          r.ID, r.PulsePointIncidentCallType, r.FullDisplayAddress,
          r.CallReceivedDateTime, r.AgencyID, r._units, r._markerType
        ].map(v => (v||"").toString().toLowerCase()).join(" ");
        return hay.includes(q);
      });
    }
    filtered.sort((a,b) => {
      const av = (a[sortKey] ?? "").toString();
      const bv = (b[sortKey] ?? "").toString();
      return av < bv ? -1*sortDir : av > bv ? 1*sortDir : 0;
    });
    render(filtered);
  }

  document.querySelectorAll("#grid th[data-key]").forEach(th => {
    th.addEventListener("click", () => {
      const key = th.getAttribute("data-key");
      if (key === sortKey) sortDir *= -1; else { sortKey = key; sortDir = 1; }
      applyFilter();
    });
  });

  $search.addEventListener("input", applyFilter);

  $download.addEventListener("click", () => {
    const headers = ["Marker","Category","ID","Type","Address","Received","Agency","Latitude","Longitude","Units"];
    const rows = ROWS.map(r => [
      r._markerUrl, r._category, r.ID, r.PulsePointIncidentCallType, r.FullDisplayAddress,
      r.CallReceivedDateTime, r.AgencyID, r.Latitude, r.Longitude, r._units
    ].map(s => csvCell(s)).join(","));
    const blob = new Blob([[headers.join(",")].concat(rows).join("\n")], {type:"text/csv;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "incidents.csv";
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(a.href);
  });
  function csvCell(v){ const s=(v??"").toString().replace(/"/g,'""'); return /[",\n]/.test(s)?`"${s}"`:s; }

  $refresh.addEventListener("click", load);

  await load();

  async function load() {
    try {
      setStatus("Fetching incidents…");
      const data = await fetchIncidents();

      // Debug: show preview and some structure
      const rawPreview = JSON.stringify(data, null, 2) || "";
      const preview = rawPreview.slice(0, 600);
      let stats = "";
      try {
        const k = data && typeof data === "object" ? Object.keys(data) : [];
        stats = `Parsed type: ${typeof data}; top keys: ${k.slice(0,12).join(", ")}`;
      } catch {}
      $debug.textContent = `Preview:\n${preview}\n\n${stats}`;

      const rows = normaliseIncidents(data);
      ROWS = rows;
      setStatus(rows.length ? "" : "No incidents found.");
      applyFilter();
    } catch (err) {
      console.error(err);
      setStatus("Error: " + (err && err.message ? err.message : String(err)));
      $debug.textContent = (err && err.stack) ? err.stack : String(err);
    }
  }
})();
</script>

</body>
</html>
