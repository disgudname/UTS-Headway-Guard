<!doctype html>
<html>
<head>
<link rel="icon" type="image/png" href="/media/favicon.ico" />
<link rel="apple-touch-icon" sizes="180x180" href="/media/apple-touch-icon-180.png" />
<meta charset="utf-8" />
<title>Traffic Camera Dashboard</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  @font-face{font-family:'FGDC';src:url('/fonts/FGDC.ttf') format('truetype');font-weight:normal;font-style:normal;}
  :root{--bg:#232D4B;--bg-dark:#1A2140;--ink:#FFFFFF;--muted:#9fb0c9;--accent:#E57200;--panel:rgba(26,33,64,0.72);--panel-border:rgba(229,114,0,0.4);}
  *{box-sizing:border-box;}
  body{margin:0;min-height:100vh;background:radial-gradient(circle at top left,rgba(229,114,0,0.18),transparent 40%),linear-gradient(160deg,var(--bg) 0%,var(--bg-dark) 60%,#11162a 100%);color:var(--ink);font:16px/1.45 'FGDC',sans-serif;display:flex;flex-direction:column;}
  header{display:flex;align-items:center;justify-content:space-between;padding:16px 24px;background:var(--panel);border-bottom:1px solid var(--panel-border);}
  .title{font-size:22px;letter-spacing:0.04em;text-transform:uppercase;}
  .controls{display:flex;align-items:center;gap:16px;flex-wrap:wrap;}
  .grid-selector{display:flex;align-items:center;gap:8px;}
  .grid-label{font-size:14px;color:var(--muted);}
  .grid-input{width:50px;background:rgba(17,22,42,0.8);border:1px solid rgba(229,114,0,0.4);border-radius:6px;padding:6px 8px;color:var(--ink);font:inherit;font-size:14px;text-align:center;}
  .grid-input:focus{outline:none;border-color:var(--accent);}
  .grid-x{color:var(--muted);font-size:14px;}
  .back-link{color:var(--muted);text-decoration:none;font-size:14px;transition:color 0.2s;}
  .back-link:hover{color:var(--ink);}
  .camera-grid{flex:1;display:grid;gap:8px;padding:8px;overflow:auto;}
  .camera-cell{background:var(--panel);border:1px solid var(--panel-border);border-radius:12px;display:flex;flex-direction:column;overflow:hidden;min-height:0;}
  .camera-header{display:flex;align-items:center;gap:8px;padding:8px 12px;background:rgba(0,0,0,0.2);border-bottom:1px solid rgba(255,255,255,0.1);}
  .camera-name{flex:1;font-size:12px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
  .camera-name.has-camera{color:var(--ink);}
  .camera-state-badge{font-size:11px;padding:3px 8px;border-radius:4px;background:rgba(229,114,0,0.4);color:#fff;font-weight:bold;letter-spacing:0.05em;}
  .camera-btn{background:rgba(17,22,42,0.8);border:1px solid rgba(229,114,0,0.4);border-radius:6px;padding:4px 10px;color:var(--ink);font:inherit;font-size:12px;cursor:pointer;transition:background 0.2s,border-color 0.2s;white-space:nowrap;}
  .camera-btn:hover{background:rgba(229,114,0,0.18);border-color:rgba(229,114,0,0.7);}
  .camera-btn.clear{padding:4px 8px;color:var(--muted);}
  .camera-btn.clear:hover{color:#fca5a5;}
  .camera-video-container{flex:1;display:flex;align-items:center;justify-content:center;background:#000;position:relative;min-height:0;}
  .camera-video{width:100%;height:100%;object-fit:contain;}
  .camera-placeholder{color:var(--muted);font-size:14px;text-align:center;padding:20px;}
  .camera-error{color:#fca5a5;font-size:13px;text-align:center;padding:20px;}
  .camera-loading{color:var(--muted);font-size:13px;}
  .status-bar{padding:8px 24px;background:var(--panel);border-top:1px solid var(--panel-border);font-size:13px;color:var(--muted);display:flex;justify-content:space-between;}

  /* Map Modal */
  .modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:1000;}
  .modal-overlay.active{display:flex;}
  .modal{background:var(--bg-dark);border:1px solid var(--panel-border);border-radius:16px;width:90vw;height:85vh;max-width:1200px;display:flex;flex-direction:column;overflow:hidden;}
  .modal-header{display:flex;align-items:center;justify-content:space-between;padding:16px 20px;background:var(--panel);border-bottom:1px solid var(--panel-border);}
  .modal-title{font-size:18px;letter-spacing:0.03em;}
  .modal-close{background:none;border:none;color:var(--muted);font-size:24px;cursor:pointer;padding:4px 8px;line-height:1;}
  .modal-close:hover{color:var(--ink);}
  .modal-body{flex:1;position:relative;overflow:hidden;}
  #picker-map{width:100%;height:100%;}
  .modal-footer{padding:12px 20px;background:var(--panel);border-top:1px solid var(--panel-border);display:flex;justify-content:space-between;align-items:center;}
  .modal-hint{font-size:13px;color:var(--muted);}
  .modal-actions{display:flex;gap:10px;}
  .modal-btn{background:rgba(17,22,42,0.8);border:1px solid rgba(229,114,0,0.4);border-radius:8px;padding:8px 16px;color:var(--ink);font:inherit;font-size:14px;cursor:pointer;transition:background 0.2s,border-color 0.2s;}
  .modal-btn:hover{background:rgba(229,114,0,0.18);border-color:rgba(229,114,0,0.7);}

  /* State selector in modal */
  .modal-state-row{display:flex;align-items:center;gap:12px;padding:12px 20px;background:rgba(0,0,0,0.2);border-bottom:1px solid rgba(255,255,255,0.1);}
  .state-select{background:rgba(17,22,42,0.8);border:1px solid rgba(229,114,0,0.4);border-radius:6px;padding:8px 12px;color:var(--ink);font:inherit;font-size:14px;cursor:pointer;min-width:200px;}
  .state-select:focus{outline:none;border-color:var(--accent);}
  .state-select option{background:#1A2140;color:var(--ink);}

  /* Dropdown picker (for states without coords) */
  .dropdown-picker{display:none;flex-direction:column;height:100%;overflow:hidden;}
  .dropdown-picker.active{display:flex;}
  .map-picker{display:none;height:100%;}
  .map-picker.active{display:block;}
  .camera-dropdown-container{flex:1;overflow-y:auto;padding:16px 20px;}
  .camera-dropdown{width:100%;background:rgba(17,22,42,0.8);border:1px solid rgba(229,114,0,0.4);border-radius:8px;padding:10px 14px;color:var(--ink);font:inherit;font-size:14px;cursor:pointer;}
  .camera-dropdown:focus{outline:none;border-color:var(--accent);}
  .camera-dropdown option{background:#1A2140;color:var(--ink);padding:4px 0;}
  .camera-dropdown optgroup{color:var(--accent);font-weight:bold;}

  @media(max-width:768px){
    header{flex-direction:column;gap:12px;padding:12px 16px;}
    .controls{justify-content:center;}
    .camera-grid{gap:6px;padding:6px;}
    .modal{width:95vw;height:90vh;}
  }
</style>
</head>
<body>
<header>
  <div class="title">Traffic Camera Dashboard</div>
  <div class="controls">
    <div class="grid-selector">
      <span class="grid-label">Grid:</span>
      <input type="number" class="grid-input" id="grid-cols" min="1" max="8" value="4">
      <span class="grid-x">x</span>
      <input type="number" class="grid-input" id="grid-rows" min="1" max="8" value="4">
    </div>
    <a href="/" class="back-link">Back to Dashboard</a>
  </div>
</header>

<div class="camera-grid" id="camera-grid"></div>

<div class="status-bar">
  <span id="camera-count">Loading cameras...</span>
  <span id="last-update"></span>
</div>

<!-- Camera Picker Modal -->
<div class="modal-overlay" id="map-modal">
  <div class="modal">
    <div class="modal-header">
      <div class="modal-title">Select Camera</div>
      <button class="modal-close" id="modal-close">&times;</button>
    </div>
    <div class="modal-state-row">
      <span class="grid-label">State:</span>
      <select class="state-select" id="picker-state">
        <option value="VA">Virginia (VDOT 511)</option>
        <option value="MD">Maryland (CHART)</option>
        <option value="TN">Tennessee (TDOT)</option>
        <option value="AR">Arkansas (IDrive)</option>
        <option value="WV">West Virginia (WV511)</option>
      </select>
    </div>
    <div class="modal-body">
      <div class="map-picker active" id="map-picker">
        <div id="picker-map"></div>
      </div>
      <div class="dropdown-picker" id="dropdown-picker">
        <div class="camera-dropdown-container">
          <select class="camera-dropdown" id="camera-dropdown" size="20">
            <option value="">Loading cameras...</option>
          </select>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <div class="modal-hint" id="modal-hint">Click to select. <span style="color:#E57200">Orange</span> = available, <span style="color:#6366f1">Purple</span> = in use, <span style="color:#22c55e">Green</span> = current</div>
      <div class="modal-actions">
        <button class="modal-btn" id="modal-cancel">Cancel</button>
        <button class="modal-btn" id="modal-select" style="display:none">Select</button>
      </div>
    </div>
  </div>
</div>

<script>
(function(){
  const STORAGE_KEY = 'traffic_cams_config';
  const VA_API = 'https://511.vdot.virginia.gov/services/map/layers/map/cams';
  const WV_API = '/api/wv511/cameras';
  const MD_API = '/api/mdchart/cameras';
  const TN_API = '/api/tndot/cameras';
  const AR_API = '/api/ardot/cameras';

  // State configurations with default map centers (avoids bad data throwing off fitBounds)
  const STATES = {
    VA: { name: 'Virginia', hasCoords: true, api: VA_API, center: [37.5, -78.8], zoom: 7 },
    MD: { name: 'Maryland', hasCoords: true, api: MD_API, center: [39.0, -76.7], zoom: 8 },
    TN: { name: 'Tennessee', hasCoords: true, api: TN_API, center: [35.8, -86.4], zoom: 7 },
    AR: { name: 'Arkansas', hasCoords: true, api: AR_API, center: [34.8, -92.2], zoom: 7 },
    WV: { name: 'West Virginia', hasCoords: false, api: WV_API }
  };

  let camerasByState = { VA: [], MD: [], TN: [], AR: [], WV: [] };
  let camerasById = {};
  let gridCols = 4;
  let gridRows = 4;
  let selections = {}; // { cellIndex: { state, id } }
  let hlsPlayers = {};

  // Map picker state
  let pickerMap = null;
  let pickerMarkers = null;
  let activeCellIndex = null;
  let activePickerState = 'VA';

  // Load saved config
  function loadConfig(){
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if(saved){
        const config = JSON.parse(saved);
        gridCols = config.gridCols || config.gridSize || 4;
        gridRows = config.gridRows || config.gridSize || 4;
        selections = config.selections || {};
      }
    } catch(e){}
  }

  // Save config
  function saveConfig(){
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify({
        gridCols,
        gridRows,
        selections
      }));
    } catch(e){}
  }

  // Fetch VA cameras
  async function fetchVACameras(){
    try {
      const resp = await fetch(VA_API);
      if(!resp.ok) throw new Error('Failed to fetch VA cameras');
      const data = await resp.json();
      camerasByState.VA = (data.features || [])
        .filter(f => f.properties && f.properties.active !== false && f.geometry && f.geometry.coordinates)
        .map(f => ({
          id: f.properties.id,
          state: 'VA',
          name: f.properties.name,
          description: f.properties.description || f.properties.name,
          route: f.properties.route,
          https_url: f.properties.https_url,
          lat: parseFloat(f.geometry.coordinates[1]),
          lng: parseFloat(f.geometry.coordinates[0])
        }))
        .filter(c => !isNaN(c.lat) && !isNaN(c.lng));

      camerasByState.VA.forEach(c => { camerasById[`VA:${c.id}`] = c; });
      return camerasByState.VA;
    } catch(err){
      console.error('Error fetching VA cameras:', err);
      return [];
    }
  }

  // Fetch WV cameras
  async function fetchWVCameras(){
    try {
      const resp = await fetch(WV_API);
      if(!resp.ok) throw new Error('Failed to fetch WV cameras');
      const data = await resp.json();
      camerasByState.WV = (data.cameras || []).map(c => ({
        ...c,
        state: 'WV'
      }));

      camerasByState.WV.forEach(c => { camerasById[`WV:${c.id}`] = c; });
      return camerasByState.WV;
    } catch(err){
      console.error('Error fetching WV cameras:', err);
      return [];
    }
  }

  // Fetch MD cameras
  async function fetchMDCameras(){
    try {
      const resp = await fetch(MD_API);
      if(!resp.ok) throw new Error('Failed to fetch MD cameras');
      const data = await resp.json();
      camerasByState.MD = (data.cameras || []).map(c => ({
        ...c,
        state: 'MD'
      }));

      camerasByState.MD.forEach(c => { camerasById[`MD:${c.id}`] = c; });
      return camerasByState.MD;
    } catch(err){
      console.error('Error fetching MD cameras:', err);
      return [];
    }
  }

  // Fetch TN cameras
  async function fetchTNCameras(){
    try {
      const resp = await fetch(TN_API);
      if(!resp.ok) throw new Error('Failed to fetch TN cameras');
      const data = await resp.json();
      camerasByState.TN = (data.cameras || []).map(c => ({
        ...c,
        state: 'TN'
      }));

      camerasByState.TN.forEach(c => { camerasById[`TN:${c.id}`] = c; });
      return camerasByState.TN;
    } catch(err){
      console.error('Error fetching TN cameras:', err);
      return [];
    }
  }

  // Fetch AR cameras
  async function fetchARCameras(){
    try {
      const resp = await fetch(AR_API);
      if(!resp.ok) throw new Error('Failed to fetch AR cameras');
      const data = await resp.json();
      camerasByState.AR = (data.cameras || []).map(c => ({
        ...c,
        state: 'AR'
      }));

      camerasByState.AR.forEach(c => { camerasById[`AR:${c.id}`] = c; });
      return camerasByState.AR;
    } catch(err){
      console.error('Error fetching AR cameras:', err);
      return [];
    }
  }

  // Fetch all cameras
  async function fetchAllCameras(){
    const [va, md, tn, ar, wv] = await Promise.all([fetchVACameras(), fetchMDCameras(), fetchTNCameras(), fetchARCameras(), fetchWVCameras()]);
    const totalCount = va.length + md.length + tn.length + ar.length + wv.length;
    document.getElementById('camera-count').textContent = `${totalCount} cameras (VA: ${va.length}, MD: ${md.length}, TN: ${tn.length}, AR: ${ar.length}, WV: ${wv.length})`;
    document.getElementById('last-update').textContent = `Updated: ${new Date().toLocaleTimeString()}`;
  }

  // Get camera by state and id
  function getCamera(state, id){
    return camerasById[`${state}:${id}`];
  }

  // Destroy HLS player for a cell
  function destroyPlayer(cellIndex){
    if(hlsPlayers[cellIndex]){
      hlsPlayers[cellIndex].destroy();
      delete hlsPlayers[cellIndex];
    }
  }

  // Start video for a camera
  function startVideo(cellIndex, camera){
    const container = document.querySelector(`[data-cell="${cellIndex}"] .camera-video-container`);
    if(!container) return;

    destroyPlayer(cellIndex);

    if(!camera || !camera.https_url){
      container.innerHTML = '<div class="camera-placeholder">Click "Select" to choose a camera</div>';
      return;
    }

    container.innerHTML = '<div class="camera-loading">Loading stream...</div>';

    const video = document.createElement('video');
    video.className = 'camera-video';
    video.muted = true;
    video.autoplay = true;
    video.playsInline = true;

    if(Hls.isSupported()){
      const hls = new Hls({
        enableWorker: true,
        lowLatencyMode: true,
        backBufferLength: 30
      });

      hls.loadSource(camera.https_url);
      hls.attachMedia(video);

      hls.on(Hls.Events.MANIFEST_PARSED, () => {
        container.innerHTML = '';
        container.appendChild(video);
        video.play().catch(() => {});
      });

      hls.on(Hls.Events.ERROR, (event, data) => {
        if(data.fatal){
          container.innerHTML = `<div class="camera-error">Stream unavailable<br><small>${camera.description}</small></div>`;
          destroyPlayer(cellIndex);
        }
      });

      hlsPlayers[cellIndex] = hls;
    } else if(video.canPlayType('application/vnd.apple.mpegurl')){
      video.src = camera.https_url;
      video.addEventListener('loadedmetadata', () => {
        container.innerHTML = '';
        container.appendChild(video);
        video.play().catch(() => {});
      });
      video.addEventListener('error', () => {
        container.innerHTML = `<div class="camera-error">Stream unavailable<br><small>${camera.description}</small></div>`;
      });
    } else {
      container.innerHTML = '<div class="camera-error">HLS not supported in this browser</div>';
    }
  }

  // Update cell header to show camera name
  function updateCellHeader(cellIndex, camera){
    const nameEl = document.querySelector(`[data-cell="${cellIndex}"] .camera-name`);
    const badgeEl = document.querySelector(`[data-cell="${cellIndex}"] .camera-state-badge`);
    const clearBtn = document.querySelector(`[data-cell="${cellIndex}"] .camera-btn.clear`);
    if(nameEl){
      if(camera){
        nameEl.textContent = camera.description;
        nameEl.classList.add('has-camera');
      } else {
        nameEl.textContent = 'No camera selected';
        nameEl.classList.remove('has-camera');
      }
    }
    if(badgeEl){
      badgeEl.style.display = camera ? '' : 'none';
      if(camera) badgeEl.textContent = camera.state;
    }
    if(clearBtn){
      clearBtn.style.display = camera ? '' : 'none';
    }
  }

  // Select camera for a cell
  function selectCamera(cellIndex, state, cameraId){
    if(state && cameraId){
      selections[cellIndex] = { state, id: cameraId };
      const camera = getCamera(state, cameraId);
      updateCellHeader(cellIndex, camera);
      startVideo(cellIndex, camera);
    } else {
      delete selections[cellIndex];
      updateCellHeader(cellIndex, null);
      destroyPlayer(cellIndex);
      const container = document.querySelector(`[data-cell="${cellIndex}"] .camera-video-container`);
      if(container){
        container.innerHTML = '<div class="camera-placeholder">Click "Select" to choose a camera</div>';
      }
    }
    saveConfig();
  }

  // Render the grid
  function renderGrid(){
    const grid = document.getElementById('camera-grid');
    const totalCells = gridCols * gridRows;

    Object.keys(hlsPlayers).forEach(key => destroyPlayer(key));

    grid.style.gridTemplateColumns = `repeat(${gridCols}, 1fr)`;
    grid.style.gridTemplateRows = `repeat(${gridRows}, 1fr)`;

    let html = '';
    for(let i = 0; i < totalCells; i++){
      const sel = selections[i];
      const camera = sel ? getCamera(sel.state, sel.id) : null;
      const cameraName = camera ? camera.description : 'No camera selected';
      const hasCamera = camera ? 'has-camera' : '';
      const clearDisplay = camera ? '' : 'style="display:none"';
      const badgeDisplay = camera ? '' : 'style="display:none"';
      const badgeText = camera ? camera.state : '';

      html += `
        <div class="camera-cell" data-cell="${i}">
          <div class="camera-header">
            <span class="camera-state-badge" ${badgeDisplay}>${badgeText}</span>
            <span class="camera-name ${hasCamera}">${cameraName}</span>
            <button class="camera-btn clear" data-clear="${i}" ${clearDisplay} title="Clear">X</button>
            <button class="camera-btn" data-pick="${i}">Select</button>
          </div>
          <div class="camera-video-container">
            <div class="camera-placeholder">Click "Select" to choose a camera</div>
          </div>
        </div>
      `;
    }

    grid.innerHTML = html;

    for(let i = 0; i < totalCells; i++){
      const sel = selections[i];
      if(sel){
        const camera = getCamera(sel.state, sel.id);
        if(camera) startVideo(i, camera);
      }
    }

    document.querySelectorAll('[data-pick]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const cellIndex = parseInt(e.target.dataset.pick, 10);
        openPicker(cellIndex);
      });
    });

    document.querySelectorAll('[data-clear]').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const cellIndex = parseInt(e.target.dataset.clear, 10);
        selectCamera(cellIndex, null, null);
      });
    });
  }

  // Initialize map picker
  function initMapPicker(){
    pickerMap = L.map('picker-map').setView([37.5, -78.8], 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(pickerMap);
    pickerMarkers = L.layerGroup().addTo(pickerMap);
  }

  // Update picker state (show map or dropdown)
  function updatePickerMode(state){
    activePickerState = state;
    const mapPicker = document.getElementById('map-picker');
    const dropdownPicker = document.getElementById('dropdown-picker');
    const hint = document.getElementById('modal-hint');
    const selectBtn = document.getElementById('modal-select');

    if(STATES[state].hasCoords){
      mapPicker.classList.add('active');
      dropdownPicker.classList.remove('active');
      hint.innerHTML = 'Click to select. <span style="color:#E57200">Orange</span> = available, <span style="color:#6366f1">Purple</span> = in use, <span style="color:#22c55e">Green</span> = current';
      selectBtn.style.display = 'none';
      setTimeout(() => pickerMap.invalidateSize(), 100);
      populateMapMarkers();
    } else {
      mapPicker.classList.remove('active');
      dropdownPicker.classList.add('active');
      hint.textContent = 'This state doesn\'t share camera locations, so no map view - pick from the list instead';
      selectBtn.style.display = '';
      populateDropdown();
    }
  }

  // Populate map markers for states with coordinates (VA, MD)
  function populateMapMarkers(){
    pickerMarkers.clearLayers();

    const state = activePickerState;
    const cameras = camerasByState[state] || [];

    const usedCameraIds = new Set();
    Object.entries(selections).forEach(([idx, sel]) => {
      if(parseInt(idx, 10) !== activeCellIndex && sel && sel.state === state){
        usedCameraIds.add(sel.id);
      }
    });

    const currentSel = selections[activeCellIndex];
    const currentId = (currentSel && currentSel.state === state) ? currentSel.id : null;

    cameras.forEach(cam => {
      const isUsed = usedCameraIds.has(cam.id);
      const isCurrentSelection = cam.id === currentId;

      const marker = L.circleMarker([cam.lat, cam.lng], {
        radius: isUsed ? 8 : 6,
        fillColor: isCurrentSelection ? '#22c55e' : (isUsed ? '#6366f1' : '#E57200'),
        color: '#fff',
        weight: isUsed ? 2 : 1,
        opacity: 1,
        fillOpacity: isUsed ? 0.9 : 0.8
      });

      const label = isCurrentSelection
        ? `${cam.description} (current)`
        : (isUsed ? `${cam.description} (in use)` : cam.description);

      marker.bindTooltip(label, { direction: 'top', offset: [0, -8] });

      marker.on('click', () => {
        selectCamera(activeCellIndex, state, cam.id);
        closePicker();
      });

      pickerMarkers.addLayer(marker);
    });

    // Center on current selection, or use state default center
    if(currentId){
      const cam = getCamera(state, currentId);
      if(cam) pickerMap.setView([cam.lat, cam.lng], 12);
    } else {
      const stateConfig = STATES[state];
      if(stateConfig && stateConfig.center){
        pickerMap.setView(stateConfig.center, stateConfig.zoom || 7);
      }
    }
  }

  // Populate dropdown for WV
  function populateDropdown(){
    const dropdown = document.getElementById('camera-dropdown');
    const cameras = camerasByState[activePickerState] || [];

    const usedCameraIds = new Set();
    Object.entries(selections).forEach(([idx, sel]) => {
      if(parseInt(idx, 10) !== activeCellIndex && sel && sel.state === activePickerState){
        usedCameraIds.add(sel.id);
      }
    });

    const currentSel = selections[activeCellIndex];
    const currentId = (currentSel && currentSel.state === activePickerState) ? currentSel.id : null;

    // Group by route
    const byRoute = {};
    cameras.forEach(cam => {
      const route = cam.route || 'Other';
      if(!byRoute[route]) byRoute[route] = [];
      byRoute[route].push(cam);
    });

    let html = '<option value="">-- Select Camera --</option>';
    Object.keys(byRoute).sort().forEach(route => {
      html += `<optgroup label="${route}">`;
      byRoute[route].forEach(cam => {
        const isUsed = usedCameraIds.has(cam.id);
        const isCurrent = cam.id === currentId;
        const suffix = isCurrent ? ' (current)' : (isUsed ? ' (in use)' : '');
        const selected = isCurrent ? 'selected' : '';
        html += `<option value="${cam.id}" ${selected}>${cam.description}${suffix}</option>`;
      });
      html += '</optgroup>';
    });

    dropdown.innerHTML = html;
  }

  // Open picker modal
  function openPicker(cellIndex){
    activeCellIndex = cellIndex;
    const modal = document.getElementById('map-modal');
    modal.classList.add('active');

    // Set initial state based on current selection or default to VA
    const currentSel = selections[cellIndex];
    const initialState = currentSel ? currentSel.state : 'VA';
    document.getElementById('picker-state').value = initialState;
    updatePickerMode(initialState);
  }

  // Close picker modal
  function closePicker(){
    const modal = document.getElementById('map-modal');
    modal.classList.remove('active');
    activeCellIndex = null;
  }

  // Update grid input values
  function updateGridInputs(){
    document.getElementById('grid-cols').value = gridCols;
    document.getElementById('grid-rows').value = gridRows;
  }

  // Initialize
  async function init(){
    loadConfig();
    updateGridInputs();

    const colsInput = document.getElementById('grid-cols');
    const rowsInput = document.getElementById('grid-rows');

    function handleGridChange(){
      const newCols = Math.max(1, Math.min(8, parseInt(colsInput.value, 10) || 1));
      const newRows = Math.max(1, Math.min(8, parseInt(rowsInput.value, 10) || 1));
      if(newCols !== gridCols || newRows !== gridRows){
        gridCols = newCols;
        gridRows = newRows;
        updateGridInputs();
        saveConfig();
        renderGrid();
      }
    }

    colsInput.addEventListener('change', handleGridChange);
    rowsInput.addEventListener('change', handleGridChange);

    // Modal handlers
    document.getElementById('modal-close').addEventListener('click', closePicker);
    document.getElementById('modal-cancel').addEventListener('click', closePicker);
    document.getElementById('map-modal').addEventListener('click', (e) => {
      if(e.target.id === 'map-modal') closePicker();
    });

    // State selector change
    document.getElementById('picker-state').addEventListener('change', (e) => {
      updatePickerMode(e.target.value);
    });

    // Dropdown select button
    document.getElementById('modal-select').addEventListener('click', () => {
      const dropdown = document.getElementById('camera-dropdown');
      const cameraId = dropdown.value;
      if(cameraId){
        selectCamera(activeCellIndex, activePickerState, cameraId);
      }
      closePicker();
    });

    // Dropdown double-click to select
    document.getElementById('camera-dropdown').addEventListener('dblclick', () => {
      const dropdown = document.getElementById('camera-dropdown');
      const cameraId = dropdown.value;
      if(cameraId){
        selectCamera(activeCellIndex, activePickerState, cameraId);
        closePicker();
      }
    });

    // Initialize map
    initMapPicker();

    // Fetch all cameras and render
    await fetchAllCameras();
    renderGrid();

    // Refresh camera lists every 5 minutes
    setInterval(fetchAllCameras, 300000);

    // When tab regains focus, seek all streams to live edge
    document.addEventListener('visibilitychange', () => {
      if(document.visibilityState === 'visible'){
        Object.entries(hlsPlayers).forEach(([cellIndex, hls]) => {
          if(hls && hls.media){
            // Seek to live edge
            const livePos = hls.liveSyncPosition;
            if(livePos && isFinite(livePos)){
              hls.media.currentTime = livePos;
            }
            // Ensure playback resumes
            hls.media.play().catch(() => {});
          }
        });
      }
    });
  }

  init();
})();
</script>
</body>
</html>
