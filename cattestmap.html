<!DOCTYPE html>
<html>
  <head>
    <title>Live Map - Headway Guard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
    <script src="https://unpkg.com/rbush@3.0.1/rbush.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/crypto-js.min.js"></script>
    <style>
      .custom-popup {
        position: absolute;
        background: linear-gradient(135deg, var(--navy), var(--navy-dark));
        border: 3px solid rgba(255, 255, 255, 0.92);
        border-radius: 16px;
        padding: 12px 14px;
        pointer-events: auto;
        transform: translate(-50%, -100%);
        white-space: nowrap;
        z-index: 1000;
        color: #f8fafc;
        text-transform: uppercase;
        font-family: 'FGDC', sans-serif;
        font-size: 14px;
        letter-spacing: 0.35px;
        box-shadow: 0 18px 36px rgba(15, 23, 42, 0.38);
      }
      .custom-popup-arrow {
        position: absolute;
        left: 50%;
        bottom: -10px;
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid rgba(255, 255, 255, 0.92);
        transform: translateX(-50%);
      }
      .custom-popup-close {
        position: absolute;
        bottom: 5px;
        right: 5px;
        cursor: pointer;
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        color: #1f1300;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        font-size: 13px;
        box-shadow: 0 10px 20px rgba(229, 114, 0, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .custom-popup-close:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(229, 114, 0, 0.4);
      }
      .incident-popup {
        min-width: 280px;
        max-width: 340px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        color: #f8fafc;
        text-transform: none;
        font-family: 'FGDC', sans-serif;
        letter-spacing: 0.3px;
        white-space: normal;
      }
      .incident-popup__header {
        display: flex;
        align-items: flex-start;
        gap: 14px;
      }
      .incident-popup__details {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .incident-popup__icon {
        width: 60px;
        height: 60px;
        border-radius: 16px;
        background: #ffffff;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.08), 0 12px 24px rgba(15, 23, 42, 0.35);
        flex-shrink: 0;
      }
      .incident-popup__icon img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
      }
      .incident-popup__icon-fallback {
        font-size: 24px;
        font-weight: 800;
        letter-spacing: 2px;
        color: rgba(15, 23, 42, 0.75);
      }
      .incident-popup__title {
        font-size: 18px;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 1.4px;
        margin-bottom: 4px;
      }
      .incident-popup__meta {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 13px;
        opacity: 0.92;
      }
      .incident-popup__meta-line {
        display: flex;
        align-items: center;
        gap: 6px;
        line-height: 1.3;
      }
      .incident-popup__section {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .incident-popup__section-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1.1px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.78);
      }
      .incident-popup__routes-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 13px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.92);
        overflow-wrap: anywhere;
      }
      .incident-popup__route {
        display: inline-flex;
        align-items: center;
        padding: 2px 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.35);
        color: rgba(248, 250, 252, 0.92);
        font-weight: 600;
        letter-spacing: 0.4px;
      }
      .incident-popup__units {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .incident-popup__unit-status-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .incident-popup__unit-status-group + .incident-popup__unit-status-group {
        padding-top: 6px;
        border-top: 1px solid rgba(255, 255, 255, 0.14);
      }
      .incident-popup__unit-status-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.82);
      }
      .incident-popup__unit-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .incident-popup .incident-unit {
        display: inline-flex;
        align-items: center;
        font-size: 12px;
        font-weight: 700;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.55);
        color: rgba(248, 250, 252, 0.92);
        letter-spacing: 0.35px;
      }
      .cat-vehicle-icon {
        width: 0;
        height: 0;
      }
      .cat-vehicle-marker {
        --cat-marker-size: 38px;
        --cat-marker-color: #0f172a;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        width: var(--cat-marker-size);
        height: var(--cat-marker-size);
        border-radius: 50%;
        background: var(--cat-marker-color);
        color: #fff7ed;
        border: 3px solid rgba(255, 255, 255, 0.9);
        box-shadow: 0 12px 24px rgba(15, 23, 42, 0.45);
        font-family: 'FGDC', sans-serif;
        font-weight: 800;
        letter-spacing: 0.6px;
        text-transform: uppercase;
        font-size: 14px;
      }
      .cat-vehicle-marker__label {
        display: block;
        padding: 0 4px;
        text-align: center;
      }
      .cat-vehicle-tooltip {
        background: rgba(15, 23, 42, 0.92);
        color: #f8fafc;
        border-radius: 10px;
        padding: 8px 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        font-family: 'FGDC', sans-serif;
        font-size: 13px;
        letter-spacing: 0.35px;
        text-transform: none;
        box-shadow: 0 10px 20px rgba(15, 23, 42, 0.4);
      }
      .cat-vehicle-tooltip strong {
        display: block;
        font-size: 13px;
        margin-bottom: 4px;
        letter-spacing: 0.45px;
      }
      .cat-vehicle-tooltip__etas {
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .route-pill {
        display: inline-block;
        padding: 5px 12px;
        border-radius: 999px;
        color: #1f1300;
        font-weight: bold;
        margin-top: 10px;
        text-align: center;
        border: none;
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        box-shadow: 0 12px 24px var(--route-pill-shadow-color, rgba(229, 114, 0, 0.35));
      }
      .stop-marker-container {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        line-height: 0;
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      .stop-marker-outer {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        width: var(--stop-marker-size, 24px);
        height: var(--stop-marker-size, 24px);
        border-radius: 50%;
        border: 2px solid var(--stop-marker-border-color, rgba(15,23,42,0.55));
        background: var(--stop-marker-gradient, #ffffff);
        box-shadow: 0 0 0 var(--stop-marker-outline-size, 0px) var(--stop-marker-outline-color, transparent),
                    0 12px 24px rgba(15,23,42,0.28);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .stop-marker-container:hover .stop-marker-outer,
      .stop-marker-container:focus-visible .stop-marker-outer {
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 0 0 var(--stop-marker-outline-size, 0px) var(--stop-marker-outline-color, transparent),
                    0 18px 32px rgba(15,23,42,0.32);
      }
      .stop-entry + .stop-entry {
        margin-top: 12px;
        padding-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
      }
      .stop-entry-title {
        display: block;
        font-weight: bold;
        margin-bottom: 4px;
      }
      .stop-entry-id {
        display: block;
        font-size: 12px;
        opacity: 0.9;
        margin-bottom: 6px;
      }
      .bus-marker {
        background: transparent;
        border: 0;
        padding: 0;
        line-height: 0;
        pointer-events: none;
      }
      .bus-marker__root {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        cursor: default;
        touch-action: none;
        user-select: none;
        overflow: visible;
      }
      .bus-label-icon {
        pointer-events: none !important;
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        padding: 0 !important;
      }
      .bus-marker__svg {
        display: block;
        width: 100%;
        height: 100%;
        overflow: visible;
        transition: transform 0.2s ease, filter 0.2s ease;
        transform-box: view-box;
        transform-origin: 50% 50%;
        will-change: transform;
        pointer-events: none;
        position: relative;
        z-index: 1;
      }
      .bus-marker__svg .st1 {
        paint-order: stroke fill;
        transition: fill 0.2s ease, fill-opacity 0.2s ease;
        pointer-events: auto;
      }
      .bus-marker__svg .st0 {
        transition: fill 0.2s ease;
        pointer-events: auto;
      }
      .bus-marker__svg #halo {
        pointer-events: none;
      }
      .bus-marker__root.is-stale .bus-marker__svg {
        opacity: 0.6;
      }
      .bus-marker__root.is-hover .bus-marker__svg {
        filter: drop-shadow(0 3px 8px rgba(15, 23, 42, 0.35));
      }
      .bus-marker__root.is-selected .bus-marker__svg {
        filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.68));
      }
      .bus-marker__root.is-selected.is-hover .bus-marker__svg {
        filter: drop-shadow(0 3px 12px rgba(15, 23, 42, 0.35)) drop-shadow(0 0 7px rgba(255, 255, 255, 0.72));
      }
      .incident-halo-icon {
        pointer-events: none !important;
      }
      .incident-halo-icon .incident-halo {
        position: absolute;
        left: 50%;
        top: 50%;
        width: var(--incident-halo-diameter, 128px);
        height: var(--incident-halo-diameter, 128px);
        margin-left: calc(-0.5 * var(--incident-halo-diameter, 128px));
        margin-top: calc(-0.5 * var(--incident-halo-diameter, 128px));
        border-radius: 50%;
        background: radial-gradient(circle, rgba(var(--incident-halo-color-rgb, 255, 90, 60), var(--incident-halo-base-opacity, 0.5)) 0%, rgba(var(--incident-halo-color-rgb, 255, 90, 60), 0) 72%);
        opacity: var(--incident-halo-base-opacity, 0.5);
        transform: scale(var(--incident-halo-start-scale, 0.25));
        transform-origin: 50% 50%;
        pointer-events: none;
        will-change: transform, opacity;
        filter: blur(0.2px);
      }
      .incident-halo--animated {
        animation: incident-halo-pulse var(--incident-halo-duration, 1600ms) cubic-bezier(0.25, 1, 0.5, 1) infinite;
      }
      .incident-halo--static {
        transform: scale(1);
        opacity: var(--incident-halo-base-opacity, 0.5);
      }
      @keyframes incident-halo-pulse {
        0% {
          transform: scale(var(--incident-halo-start-scale, 0.25));
          opacity: var(--incident-halo-base-opacity, 0.5);
        }
        70% {
          opacity: var(--incident-halo-base-opacity, 0.5);
        }
        100% {
          transform: scale(1);
          opacity: 0;
        }
      }
      @media (prefers-reduced-motion: reduce) {
        .incident-halo--animated {
          animation: none;
          transform: scale(1);
          opacity: var(--incident-halo-base-opacity, 0.5);
        }
      }
      @font-face {
        font-family: 'FGDC';
        src: url('FGDC.ttf') format('truetype');
      }
      :root {
        --navy: #232D4B;
        --navy-dark: #1b274a;
        --navy-darker: #1a2441;
        --panel-surface: linear-gradient(180deg, rgba(255, 255, 255, 0.96), rgba(245, 248, 255, 0.96));
        --panel-border-color: rgba(35, 45, 75, 0.12);
        --panel-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
        --panel-highlight: rgba(35, 45, 75, 0.06);
        --panel-text-color: #1f2937;
        --panel-heading-color: #232D4B;
        --panel-muted-text: #4b5563;
        --accent: #E57200;
        --accent-bright: #ff9c3e;
        --accent-soft: rgba(229, 114, 0, 0.28);
      }
      body {
        font-family: 'FGDC', sans-serif;
        font-size: 14px;
        color: var(--panel-text-color);
      }
      #map {
        height: 100%;
        width: 100%;
      }
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      .loading-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgba(71, 85, 105, 0.55);
        color: #f1f5f9;
        font-family: 'FGDC', sans-serif;
        font-size: 18px;
        letter-spacing: 0.3rem;
        text-transform: uppercase;
        z-index: 3000;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.25s ease, visibility 0.25s ease;
        backdrop-filter: blur(2px);
      }
      .loading-overlay.is-visible {
        opacity: 1;
        visibility: visible;
        pointer-events: all;
      }
      .loading-overlay__inner {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }
      .loading-overlay__spinner {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: 4px solid rgba(241, 245, 249, 0.35);
        border-top-color: #f8fafc;
        animation: loading-overlay-spin 1s linear infinite;
      }
      .loading-overlay__text {
        font-size: 16px;
        letter-spacing: 0.35rem;
      }
      @keyframes loading-overlay-spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      /* Route Selector styling */
      .selector-panel {
        width: 340px;
        position: fixed;
        top: 10px;
        z-index: 1100;
        background: var(--panel-surface);
        border-radius: 18px;
        border: 1px solid var(--panel-border-color);
        box-shadow: var(--panel-shadow);
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        backdrop-filter: blur(12px);
        transition: transform 0.35s ease, box-shadow 0.3s ease, opacity 0.3s ease;
        font-size: 16px;
        color: var(--panel-text-color);
      }
      #routeSelector {
        right: 10px;
      }
      #controlPanel {
        left: 10px;
      }
      #routeSelector.hidden {
        transform: translateX(calc(100% + 24px));
        opacity: 0;
        pointer-events: none;
      }
      #controlPanel.hidden {
        transform: translateX(calc(-100% - 24px));
        opacity: 0;
        pointer-events: none;
      }
      .selector-panel .selector-header {
        background: linear-gradient(135deg, var(--navy), var(--navy-dark));
        color: #f8fafc;
        padding: 16px 20px 18px;
        box-shadow: inset 0 -1px 0 rgba(255, 255, 255, 0.08);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .selector-panel .selector-header-text {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .selector-panel .selector-logo {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px;
        border-radius: 12px;
        background: #ffffff;
        border: 1px solid rgba(35, 45, 75, 0.15);
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
      }
      .selector-panel .selector-logo img {
        display: block;
        max-width: 100%;
        max-height: 120px;
        height: auto;
      }
      .selector-panel .selector-title {
        margin: 0;
        font-size: 22px;
        letter-spacing: 0.4px;
      }
      .selector-panel .selector-subtitle {
        margin-top: 6px;
        font-size: 13px;
        opacity: 0.75;
        letter-spacing: 0.3px;
      }
      .selector-panel .selector-content {
        flex: 1;
        min-height: 0;
        overflow-y: auto;
        padding: 18px 20px 22px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }
      .selector-panel .incident-alert-block {
        background: linear-gradient(135deg, rgba(254, 226, 226, 0.92), rgba(254, 202, 202, 0.78));
        border: 1px solid rgba(220, 38, 38, 0.35);
        border-radius: 18px;
        padding: 18px 20px;
        box-shadow: 0 18px 32px rgba(220, 38, 38, 0.18);
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .selector-panel .incident-alert__header {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .selector-panel .incident-alert__title {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.4px;
        color: rgba(136, 19, 19, 0.95);
      }
      .selector-panel .incident-alert__subtitle {
        margin: 0;
        font-size: 13px;
        line-height: 1.4;
        color: rgba(127, 29, 29, 0.85);
      }
      .selector-panel .incident-alert__list {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      /* ===== Demo incident preview styles (remove when demo is retired) ===== */
      .selector-panel .demo-incident-section {
        border: 3px dashed rgba(236, 72, 153, 0.65);
        border-radius: 18px;
        padding: 18px 20px;
        background: repeating-linear-gradient(135deg, rgba(250, 204, 21, 0.38), rgba(250, 204, 21, 0.38) 16px, rgba(244, 63, 94, 0.45) 16px, rgba(244, 63, 94, 0.45) 32px);
        box-shadow: 0 18px 32px rgba(190, 24, 93, 0.25);
        text-align: center;
      }
      .demo-incident-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        padding: 12px 16px;
        font-size: 15px;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #0f172a;
        background: linear-gradient(135deg, #f97316, #ec4899);
        border: 4px solid #0f172a;
        border-radius: 14px;
        cursor: pointer;
        box-shadow: 0 10px 18px rgba(15, 23, 42, 0.35);
        transition: transform 0.12s ease, box-shadow 0.12s ease;
      }
      .demo-incident-button:hover {
        transform: translateY(-2px) rotate(-1.5deg);
        box-shadow: 0 16px 26px rgba(15, 23, 42, 0.45);
      }
      .demo-incident-button:active {
        transform: translateY(1px) scale(0.97) rotate(1.5deg);
      }
      .demo-incident-button.is-active {
        background: linear-gradient(135deg, #22d3ee, #a855f7);
      }
      .selector-panel .demo-incident-note {
        margin-top: 10px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: rgba(15, 23, 42, 0.82);
      }
      .selector-panel .incident-alert__item {
        display: flex;
        align-items: flex-start;
        gap: 14px;
      }
      .selector-panel .incident-alert__item-button {
        appearance: none;
        background: transparent;
        border: 1px solid transparent;
        border-radius: 16px;
        padding: 8px 12px;
        width: 100%;
        text-align: left;
        display: flex;
        align-items: flex-start;
        gap: 14px;
        cursor: pointer;
        font: inherit;
        color: inherit;
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .selector-panel .incident-alert__item-button:hover,
      .selector-panel .incident-alert__item-button:focus-visible {
        background: rgba(255, 255, 255, 0.6);
        border-color: rgba(136, 19, 19, 0.25);
        box-shadow: 0 10px 24px rgba(136, 19, 19, 0.15);
        outline: none;
      }
      .selector-panel .incident-alert__item-button:focus-visible .incident-alert__type {
        text-decoration: underline;
      }
      .selector-panel .incident-alert__media {
        flex: 0 0 auto;
        width: 60px;
        height: 60px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.82);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: inset 0 0 0 1px rgba(220, 38, 38, 0.25);
      }
      .selector-panel .incident-alert__media img {
        display: block;
        max-width: 48px;
        max-height: 48px;
      }
      .selector-panel .incident-alert__content {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .selector-panel .incident-alert__type {
        font-size: 17px;
        font-weight: 700;
        letter-spacing: 0.4px;
        color: rgba(136, 19, 19, 0.95);
      }
      .selector-panel .incident-alert__meta {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 13px;
        color: rgba(120, 53, 15, 0.95);
      }
      .selector-panel .incident-alert__location {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 13px;
        color: rgba(124, 45, 18, 0.95);
        overflow-wrap: anywhere;
      }
      .selector-panel .incident-alert__location-label {
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 12px;
        color: rgba(136, 19, 19, 0.9);
      }
      .selector-panel .incident-alert__location-text {
        font-weight: 600;
      }
      .selector-panel .incident-alert__received {
        font-weight: 600;
      }
      .selector-panel .incident-alert__routes-line {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 13px;
        color: rgba(124, 45, 18, 0.95);
      }
      .selector-panel .incident-alert__routes-list {
        font-weight: 600;
        overflow-wrap: anywhere;
      }
      .selector-panel .incident-alert__routes-label,
      .selector-panel .incident-alert__units-label {
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 12px;
        color: rgba(136, 19, 19, 0.9);
      }
      .selector-panel .incident-alert__units {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-start;
      }
      .selector-panel .incident-alert__units-label {
        display: block;
      }
      .selector-panel .incident-alert__unit-status-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 100%;
      }
      .selector-panel .incident-alert__unit-status-group + .incident-alert__unit-status-group {
        padding-top: 6px;
        border-top: 1px solid rgba(136, 19, 19, 0.2);
      }
      .selector-panel .incident-alert__unit-status-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: 700;
        color: rgba(136, 19, 19, 0.9);
      }
      .selector-panel .incident-alert__unit-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .selector-panel .incident-unit {
        display: inline-flex;
        align-items: center;
        font-size: 12px;
        font-weight: 700;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(255, 255, 255, 0.82);
        color: rgba(30, 41, 59, 0.85);
        letter-spacing: 0.3px;
      }
      .selector-panel .selector-content::-webkit-scrollbar {
        width: 8px;
      }
      .selector-panel .selector-content::-webkit-scrollbar-track {
        background: rgba(35, 45, 75, 0.08);
        border-radius: 12px;
      }
      .selector-panel .selector-content::-webkit-scrollbar-thumb {
        background: rgba(35, 45, 75, 0.35);
        border-radius: 12px;
      }
      .selector-panel .selector-content::-webkit-scrollbar-thumb:hover {
        background: rgba(229, 114, 0, 0.6);
      }
      .selector-panel .selector-group {
        background: var(--panel-highlight);
        border-radius: 14px;
        padding: 14px 16px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .selector-panel .radar-control-group .radar-control {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .selector-panel .radar-control-group .radar-control-label {
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1.2px;
        color: rgba(35, 45, 75, 0.65);
      }
      .selector-panel .radar-opacity-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }
      .selector-panel .radar-opacity-value {
        font-size: 14px;
        font-weight: 700;
        min-width: 48px;
        text-align: right;
        color: rgba(35, 45, 75, 0.85);
      }
      .selector-panel .radar-control-group input[type="range"] {
        width: 100%;
        -webkit-appearance: none;
        appearance: none;
        height: 6px;
        border-radius: 999px;
        background: rgba(35, 45, 75, 0.18);
        outline: none;
      }
      .selector-panel .radar-control-group input[type="range"]::-webkit-slider-runnable-track {
        height: 6px;
        border-radius: 999px;
        background: rgba(35, 45, 75, 0.18);
      }
      .selector-panel .radar-control-group input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 2px 6px rgba(229, 114, 0, 0.45);
        cursor: pointer;
        border: none;
      }
      .selector-panel .radar-control-group input[type="range"]::-moz-range-track {
        height: 6px;
        border-radius: 999px;
        background: rgba(35, 45, 75, 0.18);
      }
      .selector-panel .radar-control-group input[type="range"]::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: var(--accent);
        box-shadow: 0 2px 6px rgba(229, 114, 0, 0.45);
        cursor: pointer;
        border: none;
      }
      .selector-panel .radar-status-message {
        font-size: 12px;
        letter-spacing: 0.3px;
        color: rgba(185, 28, 28, 0.85);
      }
      .selector-panel .radar-toggle {
        align-self: flex-start;
      }
      .selector-panel .radar-toggle[disabled] {
        cursor: not-allowed;
        opacity: 0.55;
      }
      .selector-panel .service-alerts-group {
        gap: 12px;
      }
      .selector-panel .service-alerts-toggle {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: space-between;
        text-align: left;
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.16), rgba(79, 70, 229, 0.18));
        border: 1px solid rgba(67, 56, 202, 0.28);
        color: var(--panel-text-color);
        box-shadow: 0 10px 18px rgba(37, 99, 235, 0.18);
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .selector-panel .service-alerts-toggle:hover {
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.22), rgba(79, 70, 229, 0.26));
        border-color: rgba(67, 56, 202, 0.36);
        box-shadow: 0 14px 24px rgba(37, 99, 235, 0.25);
      }
      .selector-panel .service-alerts-toggle.is-expanded {
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.26), rgba(59, 130, 246, 0.3));
        border-color: rgba(59, 130, 246, 0.45);
        box-shadow: 0 16px 26px rgba(59, 130, 246, 0.3);
      }
      .selector-panel .service-alerts-toggle.has-active-alerts {
        background: linear-gradient(135deg, rgba(13, 148, 136, 0.24), rgba(14, 116, 144, 0.26));
        border-color: rgba(13, 148, 136, 0.42);
        box-shadow: 0 16px 26px rgba(13, 148, 136, 0.25);
      }
      .selector-panel .service-alerts-toggle.has-active-alerts:hover {
        background: linear-gradient(135deg, rgba(13, 148, 136, 0.28), rgba(14, 116, 144, 0.32));
        border-color: rgba(13, 148, 136, 0.5);
      }
      .selector-panel .service-alerts-toggle.has-error {
        background: linear-gradient(135deg, rgba(248, 113, 113, 0.2), rgba(220, 38, 38, 0.22));
        border-color: rgba(220, 38, 38, 0.42);
        box-shadow: 0 12px 22px rgba(220, 38, 38, 0.22);
      }
      .selector-panel .service-alerts-toggle.has-error:hover {
        background: linear-gradient(135deg, rgba(248, 113, 113, 0.24), rgba(220, 38, 38, 0.28));
        border-color: rgba(220, 38, 38, 0.5);
      }
      .selector-panel .service-alerts-toggle.is-loading {
        cursor: progress;
      }
      .selector-panel .service-alerts-toggle__text {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 4px;
      }
      .selector-panel .service-alerts-toggle__label {
        font-size: 15px;
        font-weight: 700;
        letter-spacing: 1.1px;
        text-transform: uppercase;
        color: rgba(30, 41, 59, 0.92);
      }
      .selector-panel .service-alerts-toggle__status {
        font-size: 13px;
        letter-spacing: 0.35px;
        color: rgba(30, 64, 175, 0.85);
      }
      .selector-panel .service-alerts-toggle.has-error .service-alerts-toggle__status {
        color: rgba(185, 28, 28, 0.9);
        font-weight: 600;
      }
      .selector-panel .service-alerts-toggle.is-loading .service-alerts-toggle__status {
        color: rgba(30, 41, 59, 0.7);
      }
      .selector-panel .service-alerts-toggle.has-active-alerts .service-alerts-toggle__status {
        color: rgba(13, 148, 136, 0.95);
        font-weight: 700;
      }
      .selector-panel .service-alerts-toggle__chevron {
        flex: 0 0 auto;
        width: 28px;
        height: 28px;
        border-radius: 999px;
        background: rgba(30, 41, 59, 0.12);
        color: rgba(30, 41, 59, 0.7);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 13px;
        transition: background 0.2s ease, color 0.2s ease;
      }
      .selector-panel .service-alerts-toggle:hover .service-alerts-toggle__chevron {
        background: rgba(30, 41, 59, 0.18);
      }
      .selector-panel .service-alerts-toggle__chevron::before {
        content: '\25BC';
      }
      .selector-panel .service-alerts-toggle.is-expanded .service-alerts-toggle__chevron::before {
        content: '\25B2';
      }
      .selector-panel .service-alerts-panel {
        border-radius: 12px;
        border: 1px solid rgba(67, 56, 202, 0.26);
        background: rgba(255, 255, 255, 0.9);
        padding: 16px 18px;
        box-shadow: 0 14px 28px rgba(37, 99, 235, 0.18);
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .selector-panel .service-alerts-panel[hidden] {
        display: none;
      }
      .selector-panel .service-alerts-panel.is-empty {
        padding: 0;
        border: none;
        box-shadow: none;
        background: transparent;
        gap: 0;
        min-height: 0;
      }
      .selector-panel .service-alerts-panel.is-loading {
        opacity: 0.75;
      }
      .selector-panel .service-alerts-panel.has-error {
        border-color: rgba(220, 38, 38, 0.32);
        box-shadow: 0 12px 24px rgba(220, 38, 38, 0.2);
      }
      .selector-panel .service-alerts-panel .service-alerts-state {
        font-size: 14px;
        letter-spacing: 0.3px;
        color: rgba(30, 41, 59, 0.82);
        line-height: 1.4;
      }
      .selector-panel .service-alerts-panel .service-alerts-state--loading {
        color: rgba(37, 99, 235, 0.85);
        font-weight: 600;
      }
      .selector-panel .service-alerts-panel .service-alerts-state--error {
        color: rgba(185, 28, 28, 0.9);
        font-weight: 600;
      }
      .selector-panel .service-alerts-list {
        margin: 0;
        padding: 0;
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .selector-panel .service-alerts-item {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 14px 16px;
        border-radius: 12px;
        background: rgba(37, 99, 235, 0.08);
        border: 1px solid rgba(67, 56, 202, 0.22);
      }
      .selector-panel .service-alerts-item.is-inactive {
        opacity: 0.75;
      }
      .selector-panel .service-alerts-item__header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }
      .selector-panel .service-alerts-item__title {
        font-size: 15px;
        font-weight: 700;
        letter-spacing: 0.45px;
        color: rgba(30, 41, 59, 0.95);
      }
      .selector-panel .service-alerts-item__status {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        padding: 4px 10px;
        border-radius: 999px;
        background: rgba(37, 99, 235, 0.16);
        color: rgba(30, 64, 175, 0.9);
        font-weight: 700;
        white-space: nowrap;
      }
      .selector-panel .service-alerts-item.is-inactive .service-alerts-item__status {
        background: rgba(248, 113, 113, 0.18);
        color: rgba(185, 28, 28, 0.9);
      }
      .selector-panel .service-alerts-item__message {
        font-size: 14px;
        line-height: 1.55;
        color: rgba(30, 41, 59, 0.85);
        white-space: pre-line;
      }
      .selector-panel .service-alerts-item__meta {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .selector-panel .service-alerts-item__meta-row {
        display: flex;
        gap: 8px;
        font-size: 12px;
        letter-spacing: 0.3px;
        color: rgba(37, 99, 235, 0.9);
      }
      .selector-panel .service-alerts-item__meta-label {
        font-weight: 700;
        text-transform: uppercase;
        color: rgba(30, 64, 175, 0.88);
      }
      .selector-panel .service-alerts-item__meta-value {
        flex: 1;
        font-weight: 600;
        color: rgba(30, 41, 59, 0.85);
        overflow-wrap: anywhere;
      }
      .selector-panel .selector-label {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1.6px;
        color: rgba(35, 45, 75, 0.75);
      }
      .selector-panel .selector-control {
        position: relative;
      }
      .selector-panel .selector-control::after {
        content: '\25BC';
        position: absolute;
        right: 16px;
        top: 50%;
        transform: translateY(-50%);
        pointer-events: none;
        font-size: 12px;
        color: rgba(35, 45, 75, 0.65);
        opacity: 0.6;
      }
      .selector-panel select {
        width: 100%;
        padding: 10px 42px 10px 14px;
        border-radius: 12px;
        border: 1px solid rgba(35, 45, 75, 0.25);
        background: rgba(255, 255, 255, 0.92);
        box-shadow: 0 6px 18px rgba(17, 24, 39, 0.1);
        font-size: 16px;
        font-family: 'FGDC', sans-serif;
        color: var(--panel-text-color);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
      }
      .selector-panel select:focus {
        outline: none;
        border-color: rgba(229, 114, 0, 0.8);
        box-shadow: 0 0 0 3px rgba(229, 114, 0, 0.2);
      }
      .selector-panel .selector-section {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .selector-panel .selector-section-heading {
        display: flex;
        align-items: flex-start;
        flex-wrap: wrap;
        gap: 12px;
        width: 100%;
      }
      .selector-panel .selector-section-heading h3 {
        margin: 0;
        font-size: 18px;
        color: #232D4B;
        flex: 1 1 100%;
      }
      .selector-panel .selector-actions {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 10px;
        width: 100%;
        flex: 1 1 100%;
        margin-top: 4px;
      }
      .selector-panel .selector-actions .pill-button {
        width: 100%;
      }
      .selector-panel .route-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .selector-panel label.route-option {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 12px 14px;
        background: var(--panel-highlight);
        border-radius: 14px;
        border: 1px solid transparent;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background-color 0.2s ease;
        cursor: pointer;
      }
      .selector-panel label.route-option:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 26px rgba(15, 23, 42, 0.12);
        border-color: rgba(35, 45, 75, 0.25);
      }
      .selector-panel label.route-option.is-active {
        background: rgba(229, 114, 0, 0.14);
        border-color: rgba(229, 114, 0, 0.55);
        box-shadow: 0 16px 32px rgba(229, 114, 0, 0.24);
      }
      .selector-panel label.route-option--out {
        background: rgba(35, 45, 75, 0.08);
      }
      .selector-panel label.route-option input[type="checkbox"] {
        margin-top: 2px;
        width: 18px;
        height: 18px;
        accent-color: var(--accent);
        flex-shrink: 0;
        cursor: pointer;
      }
      .selector-panel label.route-option input[type="checkbox"]:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px rgba(229, 114, 0, 0.3);
        border-radius: 4px;
      }
      .selector-panel .route-option-swatch {
        display: inline-flex;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        margin-top: 2px;
        border: 2px solid rgba(255, 255, 255, 0.9);
        box-shadow: 0 0 0 1px rgba(35, 45, 75, 0.2);
        flex-shrink: 0;
      }
      .selector-panel label.route-option input[type="checkbox"]:checked + .route-option-swatch {
        transform: scale(1.1);
        box-shadow: 0 0 0 2px rgba(229, 114, 0, 0.4);
      }
      .selector-panel .route-option-text {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 15px;
        line-height: 1.3;
      }
      .selector-panel .route-option-name {
        font-weight: 600;
        color: #111827;
        letter-spacing: 0.2px;
      }
      .selector-panel .route-option-detail {
        font-size: 12px;
        color: var(--panel-muted-text);
      }
      .selector-panel button {
        border: none;
        border-radius: 999px;
        padding: 10px 16px;
        font-size: 15px;
        font-family: 'FGDC', sans-serif;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, color 0.2s ease;
        background: rgba(35, 45, 75, 0.1);
        color: #1b2540;
        border: 1px solid rgba(35, 45, 75, 0.18);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      .selector-panel button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(35, 45, 75, 0.18);
        background: rgba(35, 45, 75, 0.18);
      }
      .selector-panel button:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px rgba(229, 114, 0, 0.35);
      }
      .selector-panel button:active {
        transform: translateY(0);
      }
      .selector-panel .toggle-indicator {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-left: 8px;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 12px;
        letter-spacing: 0.8px;
        text-transform: uppercase;
        background: rgba(35, 45, 75, 0.12);
        color: rgba(35, 45, 75, 0.78);
      }
      .selector-panel button.is-active .toggle-indicator {
        background: rgba(229, 114, 0, 0.2);
        color: #1f2937;
      }
      .selector-panel button.accent {
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        color: #1f1300;
        border-color: rgba(229, 114, 0, 0.35);
        box-shadow: 0 12px 24px rgba(229, 114, 0, 0.28);
      }
      .selector-panel button.accent:hover {
        box-shadow: 0 16px 30px rgba(229, 114, 0, 0.36);
        background: linear-gradient(135deg, #f4841a, #ffad55);
      }
      .selector-panel .pill-button {
        font-size: 16px;
        padding: 12px 20px;
        letter-spacing: 0.3px;
      }
      .selector-panel .display-mode-group {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 10px;
      }
      .selector-panel .display-mode-button {
        width: 100%;
      }
      .selector-panel .display-mode-button.is-active {
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        color: #1f1300;
        border-color: rgba(229, 114, 0, 0.35);
        box-shadow: 0 12px 24px rgba(229, 114, 0, 0.28);
      }
      .selector-panel .display-mode-button.is-active:hover {
        box-shadow: 0 16px 30px rgba(229, 114, 0, 0.36);
        background: linear-gradient(135deg, #f4841a, #ffad55);
      }
      .selector-panel .full-width {
        width: 100%;
      }
      .panel-toggle {
        position: fixed;
        top: 50%;
        width: 34px;
        height: 70px;
        background: linear-gradient(180deg, var(--navy), var(--navy-darker));
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transform: translateY(-50%);
        z-index: 1150;
        text-align: center;
        font-size: 22px;
        user-select: none;
        transition: left 0.3s ease, right 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
        color: #f8fafc;
        box-shadow: 0 12px 28px rgba(15, 23, 42, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 0 4px;
      }
      .panel-toggle.is-hidden-mobile {
        display: none;
      }
      .panel-toggle--right {
        right: 0;
        border-top-left-radius: 14px;
        border-bottom-left-radius: 14px;
      }
      .panel-toggle--left {
        left: 0;
        border-top-right-radius: 14px;
        border-bottom-right-radius: 14px;
      }
      .panel-toggle:hover {
        background: linear-gradient(180deg, #2d3a5e, #253355);
        box-shadow: 0 16px 32px rgba(15, 23, 42, 0.3);
      }
      .panel-toggle:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--accent-soft), 0 16px 32px rgba(15, 23, 42, 0.3);
      }
      .panel-toggle__arrow {
        pointer-events: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 100%;
      }
      #routeLegend {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1100;
        background: var(--panel-surface);
        padding: 12px 14px 16px;
        border-radius: 16px;
        border: 1px solid var(--panel-border-color);
        box-shadow: var(--panel-shadow);
        max-width: 240px;
        display: none;
        max-height: 70vh;
        overflow-y: auto;
        font-size: 16px;
        color: var(--panel-text-color);
        backdrop-filter: blur(12px);
        transition: transform 0.3s ease, opacity 0.3s ease, box-shadow 0.3s ease;
        scrollbar-width: thin;
        scrollbar-color: rgba(35, 45, 75, 0.35) rgba(35, 45, 75, 0.08);
      }
      #routeLegend::-webkit-scrollbar {
        width: 8px;
      }
      #routeLegend::-webkit-scrollbar-track {
        background: rgba(35, 45, 75, 0.08);
        border-radius: 12px;
      }
      #routeLegend::-webkit-scrollbar-thumb {
        background: rgba(35, 45, 75, 0.35);
        border-radius: 12px;
      }
      #routeLegend .legend-title {
        font-weight: 600;
        margin: 0 0 12px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: var(--panel-heading-color);
        font-size: 18px;
      }
      #routeLegend .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        background: var(--panel-highlight);
        border-radius: 12px;
        border: 1px solid transparent;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      }
      #routeLegend .legend-item + .legend-item {
        margin-top: 10px;
      }
      #routeLegend .legend-item:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 26px rgba(15, 23, 42, 0.14);
        border-color: rgba(35, 45, 75, 0.2);
      }
      #routeLegend .legend-color {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.9);
        box-shadow: 0 0 0 1px rgba(35, 45, 75, 0.2);
        flex-shrink: 0;
      }
      #routeLegend .legend-text {
        display: flex;
        flex-direction: column;
        gap: 3px;
        min-width: 0;
        flex: 1;
      }
      #routeLegend .legend-name {
        font-weight: 600;
        letter-spacing: 0.2px;
        color: var(--panel-heading-color);
        overflow-wrap: anywhere;
      }
      #routeLegend .legend-description {
        font-size: 13px;
        color: var(--panel-muted-text);
        overflow-wrap: anywhere;
      }
      @media (max-width: 600px) {
        .selector-panel {
          width: calc(100% - 32px);
          top: 16px;
        }
        #routeSelector {
          right: 16px;
        }
        #controlPanel {
          left: 16px;
        }
        #routeSelector.hidden {
          transform: translateX(calc(100% + 20px));
        }
        #controlPanel.hidden {
          transform: translateX(calc(-100% - 20px));
        }
        .selector-panel .selector-content {
          padding: 16px;
        }
        .selector-panel .selector-title {
          font-size: 20px;
        }
        .selector-panel .selector-subtitle {
          font-size: 12px;
        }
        .selector-panel .selector-section-heading h3 {
          font-size: 16px;
        }
        .selector-panel .incident-alert__item {
          flex-direction: column;
        }
        .selector-panel .incident-alert__media {
          width: 56px;
          height: 56px;
        }
        .selector-panel .incident-alert__meta {
          gap: 6px;
        }
        .selector-panel .incident-alert__routes-line {
          gap: 4px;
        }
        .selector-panel button {
          font-size: 14px;
        }
        .selector-panel .pill-button {
          font-size: 16px;
        }
        .panel-toggle {
          width: 40px;
          height: 80px;
          font-size: 28px;
        }
        #routeLegend {
          left: 16px;
          right: 16px;
          top: auto;
          bottom: 88px;
          max-width: none;
          max-height: 45vh;
        }
        .credit {
          bottom: 16px;
          right: 16px;
          left: auto;
          font-size: 12px;
          padding: 8px 14px;
          letter-spacing: 0.2px;
        }
        .cookie-banner {
          padding: 14px 16px;
        }
      }
      .credit {
        position: fixed;
        bottom: 16px;
        right: 16px;
        font-size: 13px;
        color: rgba(35, 45, 75, 0.8);
        background: var(--panel-surface);
        border-radius: 999px;
        padding: 10px 16px;
        border: 1px solid var(--panel-border-color);
        box-shadow: 0 16px 30px rgba(15, 23, 42, 0.2);
        letter-spacing: 0.25px;
        text-transform: uppercase;
        backdrop-filter: blur(10px);
        pointer-events: none;
      }
      .cookie-banner {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, rgba(35, 45, 75, 0.95), rgba(27, 39, 74, 0.95));
        color: #f8fafc;
        padding: 16px 20px;
        font-size: 14px;
        z-index: 1200;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 14px;
        flex-wrap: wrap;
        box-shadow: 0 -16px 36px rgba(15, 23, 42, 0.4);
        backdrop-filter: blur(14px);
        letter-spacing: 0.25px;
        text-align: center;
        border-top: 1px solid rgba(255, 255, 255, 0.12);
      }
      .cookie-banner button {
        margin-left: 0;
        border: none;
        border-radius: 999px;
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        color: #1f1300;
        padding: 10px 20px;
        font-family: 'FGDC', sans-serif;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 12px 24px rgba(229, 114, 0, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .cookie-banner button:hover {
        transform: translateY(-1px);
        box-shadow: 0 16px 30px rgba(229, 114, 0, 0.42);
      }
      .cookie-banner button:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--accent-soft), 0 16px 30px rgba(229, 114, 0, 0.42);
      }
    </style>
    <script>
      // Manually set these variables.
      // adminMode: true for admin view (with speed/block bubbles and unit numbers).
      //            Can be disabled via URL param `adminMode=false`.
      //            In public mode (adminMode=false) the route selector is still shown
      //            but only for routes that are public-facing.
      // kioskMode: true to hide the route selector/tab and suppress vehicle overlays for a public display.
      // adminKioskMode: true to hide the route selector/tab while retaining admin overlays (previous kiosk behavior).
      // displayMode selects whether admin overlays show speed, block numbers, or neither.
      if (typeof window !== 'undefined' && typeof window.usp === 'undefined') {
        let searchParams = null;
        if (typeof URLSearchParams === 'function' && typeof window.location === 'object' && typeof window.location.search === 'string') {
          try {
            searchParams = new URLSearchParams(window.location.search || '');
          } catch (error) {
            searchParams = null;
          }
        }
        window.usp = {
          has(name) {
            if (!searchParams) return false;
            return searchParams.has(name);
          },
          getInt(name, defaultValue = 0) {
            if (!searchParams) return defaultValue;
            const raw = searchParams.get(name);
            if (raw === null) return defaultValue;
            const parsed = Number.parseInt(raw, 10);
            return Number.isFinite(parsed) ? parsed : defaultValue;
          }
        };
      }

      const DISPLAY_MODES = Object.freeze({
        SPEED: 'speed',
        BLOCK: 'block',
        NONE: 'none'
      });
      let adminMode = true; // shows unit numbers and speed/block bubbles
      let kioskMode = false;
      let adminKioskMode = false;
      let displayMode = DISPLAY_MODES.BLOCK;

      const PANEL_COLLAPSE_BREAKPOINT = 600;

      const enableOverlapDashRendering = true;

      function adminFeaturesAllowed() {
        return (adminMode && !kioskMode) || adminKioskMode;
      }

      const RADAR_PRODUCTS = Object.freeze({
        BASE: 'base',
        COMPOSITE: 'composite'
      });
      const RADAR_PRODUCT_ORDER = Object.freeze([RADAR_PRODUCTS.BASE, RADAR_PRODUCTS.COMPOSITE]);
      const RADAR_PRODUCT_INFO = Object.freeze({
        [RADAR_PRODUCTS.BASE]: {
          label: "Base Reflectivity (0.5 Tilt)",
          urlTemplate: "https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/{z}/{x}/{y}.png",
          cacheBustingStrategy: "none"
        },
        [RADAR_PRODUCTS.COMPOSITE]: {
          label: "Composite Reflectivity",
          urlTemplate: "https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0r-900913/{z}/{x}/{y}.png",
          cacheBustingStrategy: "none"
        }
      });
      const RADAR_DEFAULT_PRODUCT = RADAR_PRODUCTS.BASE;
      const RADAR_DEFAULT_OPACITY = 0.5;
      const RADAR_MIN_OPACITY = 0.3;
      const RADAR_MAX_OPACITY = 0.8;
      const RADAR_REFRESH_INTERVAL_MS = 5 * 60 * 1000;
      const RADAR_SESSION_STORAGE_KEY = "hg.radar.state";
      const RADAR_UNAVAILABLE_MESSAGE = "Radar temporarily unavailable.";
      const RADAR_CONSECUTIVE_ERROR_THRESHOLD = 3;
      const RADAR_PANE_NAME = "radarPane";
      const RADAR_CACHE_BUST_PLACEHOLDER = "{cacheBust}";

      let showRadar = false;
      let radarConfiguredProduct = RADAR_DEFAULT_PRODUCT;
      let radarConfiguredOpacity = RADAR_DEFAULT_OPACITY;

      let radarEnabled = false;
      let radarProduct = RADAR_DEFAULT_PRODUCT;
      let radarOpacity = RADAR_DEFAULT_OPACITY;
      let radarLayer = null;
      let radarLayerProduct = null;
      let radarRefreshTimerId = null;
      let radarCacheBustKey = "";
      let radarTileErrorCount = 0;
      let radarTemporarilyUnavailable = false;
      let radarLastFailedUrl = "";
      let radarSuppressedForErrors = false;
      let radarSuppressionTimeoutId = null;

      function isRadarInteractiveMode() {
        return !kioskMode && !adminKioskMode;
      }

      function normalizeRadarProduct(value) {
        if (typeof value !== 'string') {
          return RADAR_DEFAULT_PRODUCT;
        }
        const key = value.trim().toLowerCase();
        return Object.prototype.hasOwnProperty.call(RADAR_PRODUCT_INFO, key) ? key : RADAR_DEFAULT_PRODUCT;
      }

      function clampRadarOpacity(value) {
        const numeric = Number.parseFloat(value);
        if (!Number.isFinite(numeric)) {
          return RADAR_DEFAULT_OPACITY;
        }
        return Math.min(RADAR_MAX_OPACITY, Math.max(RADAR_MIN_OPACITY, numeric));
      }

      function formatRadarOpacity(value) {
        const numeric = Number.parseFloat(value);
        if (!Number.isFinite(numeric)) {
          return `${Math.round(RADAR_DEFAULT_OPACITY * 100)}%`;
        }
        const percentage = Math.round(Math.min(1, Math.max(0, numeric)) * 100);
        return `${percentage}%`;
      }

      function buildRadarCacheBustKey(date = new Date()) {
        const year = date.getUTCFullYear();
        const month = String(date.getUTCMonth() + 1).padStart(2, "0");
        const day = String(date.getUTCDate()).padStart(2, "0");
        const hours = String(date.getUTCHours()).padStart(2, "0");
        const minutes = String(date.getUTCMinutes()).padStart(2, "0");
        return `${year}${month}${day}${hours}${minutes}`;
      }

      function removeCacheBustPlaceholder(template) {
        if (typeof template !== "string" || !template.includes(RADAR_CACHE_BUST_PLACEHOLDER)) {
          return template;
        }
        return template.split(RADAR_CACHE_BUST_PLACEHOLDER).join("");
      }

      function getRadarTileUrlTemplate(productKey, cacheBustKey) {
        const info = RADAR_PRODUCT_INFO[productKey] || RADAR_PRODUCT_INFO[RADAR_DEFAULT_PRODUCT];
        if (!info || typeof info.urlTemplate !== "string" || !info.urlTemplate) {
          return "";
        }
        const template = info.urlTemplate;
        const strategy = info.cacheBustingStrategy || "query";
        if (!cacheBustKey || strategy === "none") {
          return removeCacheBustPlaceholder(template);
        }
        if (strategy === "path" && template.includes(RADAR_CACHE_BUST_PLACEHOLDER)) {
          return template.split(RADAR_CACHE_BUST_PLACEHOLDER).join(cacheBustKey);
        }
        const separator = template.includes("?") ? "&" : "?";
        return `${template}${separator}t=${encodeURIComponent(cacheBustKey)}`;
      }

      function loadRadarSessionState() {
        if (!isRadarInteractiveMode()) {
          return null;
        }
        try {
          if (typeof window === "undefined" || !window.sessionStorage) {
            return null;
          }
          const stored = window.sessionStorage.getItem(RADAR_SESSION_STORAGE_KEY);
          if (!stored) {
            return null;
          }
          const parsed = JSON.parse(stored);
          if (!parsed || typeof parsed !== "object") {
            return null;
          }
          return {
            enabled: parsed.enabled === true,
            product: normalizeRadarProduct(parsed.product),
            opacity: clampRadarOpacity(parsed.opacity)
          };
        } catch (error) {
          console.warn("Failed to load radar session state:", error);
          return null;
        }
      }

      function saveRadarSessionState() {
        if (!isRadarInteractiveMode()) {
          return;
        }
        try {
          if (typeof window === "undefined" || !window.sessionStorage) {
            return;
          }
          const payload = {
            enabled: !!radarEnabled,
            product: radarProduct,
            opacity: radarOpacity
          };
          window.sessionStorage.setItem(RADAR_SESSION_STORAGE_KEY, JSON.stringify(payload));
        } catch (error) {
          console.warn("Failed to save radar session state:", error);
        }
      }

      function initializeRadarPreferences() {
        radarConfiguredProduct = normalizeRadarProduct(radarConfiguredProduct);
        radarConfiguredOpacity = clampRadarOpacity(radarConfiguredOpacity);
        radarProduct = radarConfiguredProduct;
        radarOpacity = radarConfiguredOpacity;
        radarEnabled = false;
        radarTemporarilyUnavailable = false;
        radarTileErrorCount = 0;
        radarLastFailedUrl = "";
        radarSuppressedForErrors = false;
        if (radarSuppressionTimeoutId !== null) {
          clearTimeout(radarSuppressionTimeoutId);
          radarSuppressionTimeoutId = null;
        }
        if (!adminFeaturesAllowed()) {
          radarEnabled = false;
          return;
        }
        if (adminKioskMode) {
          radarEnabled = true;
        } else if (kioskMode) {
          radarEnabled = !!showRadar;
        } else {
          const storedState = loadRadarSessionState();
          if (storedState) {
            radarEnabled = !!storedState.enabled;
            radarProduct = storedState.product;
            radarOpacity = storedState.opacity;
          }
        }
      }

      function createRadarTileLayer(productKey) {
        const normalizedProduct = normalizeRadarProduct(productKey);
        const template = getRadarTileUrlTemplate(normalizedProduct, radarCacheBustKey);
        if (!template) {
          return null;
        }
        const layer = L.tileLayer(template, {
          pane: RADAR_PANE_NAME,
          opacity: radarOpacity,
          attribution: "Radar tiles  NOAA/NWS.",
          updateWhenIdle: true,
          updateWhenZooming: true,
          keepBuffer: 0,
          crossOrigin: true
        });
        layer.on("tileload", handleRadarTileLoad);
        layer.on("tileerror", handleRadarTileError);
        return layer;
      }

      function applyRadarState() {
        if (!adminFeaturesAllowed()) {
          removeRadarLayer();
          return;
        }
        if (!map) {
          return;
        }
        const shouldDisplay = radarEnabled && !radarTemporarilyUnavailable && !radarSuppressedForErrors;
        if (!shouldDisplay) {
          removeRadarLayer();
          return;
        }
        radarProduct = normalizeRadarProduct(radarProduct);
        radarOpacity = clampRadarOpacity(radarOpacity);
        if (!radarLayer) {
          radarCacheBustKey = buildRadarCacheBustKey();
          const layer = createRadarTileLayer(radarProduct);
          if (!layer) {
            return;
          }
          radarLayer = layer;
          radarLayerProduct = radarProduct;
          radarLayer.setOpacity(radarOpacity);
          radarLayer.addTo(map);
        } else {
          if (radarLayerProduct !== radarProduct) {
            radarLayerProduct = radarProduct;
            radarCacheBustKey = buildRadarCacheBustKey();
            const template = getRadarTileUrlTemplate(radarProduct, radarCacheBustKey);
            if (template) {
              radarLayer.setUrl(template);
            }
          }
          radarLayer.setOpacity(radarOpacity);
        }
        restartRadarRefreshTimer();
      }

      function removeRadarLayer() {
        if (radarLayer) {
          radarLayer.off("tileload", handleRadarTileLoad);
          radarLayer.off("tileerror", handleRadarTileError);
          if (map) {
            map.removeLayer(radarLayer);
          }
          radarLayer = null;
        }
        radarLayerProduct = null;
        radarCacheBustKey = "";
        clearRadarRefreshTimer();
      }

      function refreshRadarTiles() {
        if (!map || !radarLayer) {
          return;
        }
        radarLayerProduct = normalizeRadarProduct(radarProduct);
        radarCacheBustKey = buildRadarCacheBustKey();
        const template = getRadarTileUrlTemplate(radarLayerProduct, radarCacheBustKey);
        if (template) {
          radarLayer.setUrl(template);
        }
      }

      function startRadarRefreshTimer() {
        if (radarRefreshTimerId !== null) {
          return;
        }
        radarRefreshTimerId = window.setInterval(() => {
          refreshRadarTiles();
        }, RADAR_REFRESH_INTERVAL_MS);
      }

      function clearRadarRefreshTimer() {
        if (radarRefreshTimerId !== null) {
          clearInterval(radarRefreshTimerId);
          radarRefreshTimerId = null;
        }
      }

      function restartRadarRefreshTimer() {
        clearRadarRefreshTimer();
        if (radarLayer && radarEnabled && !radarTemporarilyUnavailable && !radarSuppressedForErrors) {
          startRadarRefreshTimer();
        }
      }

      function handleRadarTileLoad() {
        radarTileErrorCount = 0;
      }

      function handleRadarTileError(event) {
        const tile = event && event.tile ? event.tile : null;
        const url = tile && (tile.src || tile.currentSrc) ? (tile.src || tile.currentSrc) : getRadarTileUrlTemplate(radarLayerProduct || radarProduct, radarCacheBustKey);
        if (url) {
          radarLastFailedUrl = url;
        }
        console.error("Radar tile fetch failed:", radarLastFailedUrl || "Unknown URL");
        radarTileErrorCount += 1;
        if (radarTileErrorCount < RADAR_CONSECUTIVE_ERROR_THRESHOLD) {
          return;
        }
        radarTileErrorCount = 0;
        if (isRadarInteractiveMode()) {
          radarTemporarilyUnavailable = true;
          radarEnabled = false;
          removeRadarLayer();
          saveRadarSessionState();
          refreshRadarControlsUI();
        } else {
          radarSuppressedForErrors = true;
          removeRadarLayer();
          scheduleRadarSuppressionRecovery();
        }
      }

      function scheduleRadarSuppressionRecovery() {
        if (radarSuppressionTimeoutId !== null) {
          clearTimeout(radarSuppressionTimeoutId);
        }
        radarSuppressionTimeoutId = window.setTimeout(() => {
          radarSuppressionTimeoutId = null;
          radarSuppressedForErrors = false;
          radarTileErrorCount = 0;
          if (radarEnabled) {
            applyRadarState();
          }
        }, RADAR_REFRESH_INTERVAL_MS);
      }

      function setRadarEnabled(nextEnabled) {
        const allowRadar = adminFeaturesAllowed();
        const shouldEnable = allowRadar && !!nextEnabled;
        if (shouldEnable && radarTemporarilyUnavailable) {
          refreshRadarControlsUI();
          return;
        }
        if (radarEnabled === shouldEnable) {
          refreshRadarControlsUI();
          return;
        }
        radarEnabled = shouldEnable;
        if (!radarEnabled) {
          removeRadarLayer();
          radarSuppressedForErrors = false;
          radarTileErrorCount = 0;
          radarCacheBustKey = "";
          if (radarSuppressionTimeoutId !== null) {
            clearTimeout(radarSuppressionTimeoutId);
            radarSuppressionTimeoutId = null;
          }
        }
        applyRadarState();
        if (isRadarInteractiveMode()) {
          saveRadarSessionState();
        }
        refreshRadarControlsUI();
      }

      function setRadarProduct(nextProduct) {
        if (!adminFeaturesAllowed()) {
          refreshRadarControlsUI();
          return;
        }
        const normalized = normalizeRadarProduct(nextProduct);
        const productChanged = radarProduct !== normalized;
        radarProduct = normalized;
        radarTileErrorCount = 0;
        radarLastFailedUrl = "";
        if (radarTemporarilyUnavailable && productChanged) {
          radarTemporarilyUnavailable = false;
        }
        if (radarSuppressedForErrors) {
          radarSuppressedForErrors = false;
          if (radarSuppressionTimeoutId !== null) {
            clearTimeout(radarSuppressionTimeoutId);
            radarSuppressionTimeoutId = null;
          }
        }
        if (radarEnabled && map) {
          radarCacheBustKey = buildRadarCacheBustKey();
          if (radarLayer) {
            radarLayerProduct = radarProduct;
            const template = getRadarTileUrlTemplate(radarProduct, radarCacheBustKey);
            if (template) {
              radarLayer.setUrl(template);
            }
            radarLayer.setOpacity(radarOpacity);
          } else {
            applyRadarState();
          }
          restartRadarRefreshTimer();
        }
        if (isRadarInteractiveMode()) {
          saveRadarSessionState();
        }
        refreshRadarControlsUI();
      }

      function setRadarOpacity(nextOpacity) {
        if (!adminFeaturesAllowed()) {
          refreshRadarControlsUI();
          return;
        }
        const clamped = clampRadarOpacity(nextOpacity);
        if (Math.abs(clamped - radarOpacity) < 0.0001) {
          refreshRadarControlsUI();
          return;
        }
        radarOpacity = clamped;
        if (radarLayer) {
          radarLayer.setOpacity(radarOpacity);
        }
        if (isRadarInteractiveMode()) {
          saveRadarSessionState();
        }
        refreshRadarControlsUI();
      }

      function initializeRadarControls() {
        const toggleButton = document.getElementById("radarToggleButton");
        if (toggleButton) {
          toggleButton.addEventListener("click", event => {
            event.preventDefault();
            if (toggleButton.disabled) {
              return;
            }
            setRadarEnabled(!radarEnabled);
          });
        }
        const productSelect = document.getElementById("radarProductSelect");
        if (productSelect) {
          productSelect.addEventListener("change", event => {
            setRadarProduct(event.target.value);
          });
        }
        const opacityRange = document.getElementById("radarOpacityRange");
        if (opacityRange) {
          const handleOpacityChange = event => {
            const value = Number.parseFloat(event.target.value);
            if (Number.isFinite(value)) {
              setRadarOpacity(value);
            }
          };
          opacityRange.addEventListener("input", handleOpacityChange);
          opacityRange.addEventListener("change", handleOpacityChange);
        }
        refreshRadarControlsUI();
      }

      function refreshRadarControlsUI() {
        const allowRadar = adminFeaturesAllowed();
        const toggleButton = document.getElementById("radarToggleButton");
        const isActive = allowRadar && radarEnabled && !radarTemporarilyUnavailable;
        if (toggleButton) {
          toggleButton.classList.toggle("is-active", isActive);
          toggleButton.setAttribute("aria-pressed", isActive ? "true" : "false");
          toggleButton.disabled = !allowRadar || radarTemporarilyUnavailable;
          const indicator = toggleButton.querySelector(".toggle-indicator");
          if (indicator) {
            indicator.textContent = isActive ? "On" : "Off";
          }
        }
        const productSelect = document.getElementById("radarProductSelect");
        if (productSelect) {
          productSelect.value = radarProduct;
          productSelect.disabled = !allowRadar;
        }
        const opacityRange = document.getElementById("radarOpacityRange");
        if (opacityRange) {
          opacityRange.value = radarOpacity.toFixed(2);
          opacityRange.disabled = !allowRadar;
        }
        const opacityValue = document.getElementById("radarOpacityValue");
        if (opacityValue) {
          opacityValue.textContent = formatRadarOpacity(radarOpacity);
        }
        const statusMessage = document.getElementById("radarStatusMessage");
        if (statusMessage) {
          if (radarTemporarilyUnavailable) {
            statusMessage.textContent = RADAR_UNAVAILABLE_MESSAGE;
            statusMessage.style.display = "";
          } else {
            statusMessage.textContent = "";
            statusMessage.style.display = "none";
          }
        }
      }

      const ROUTE_LAYER_BASE_OPTIONS = Object.freeze({
        updateWhenZooming: true,
        updateWhenIdle: true,
        interactive: false
      });
      let sharedRouteRenderer = null;
      let routePaneName = 'overlayPane';
      let lastRenderedLegendRoutes = [];

      function createSpatialIndex(options = {}) {
        if (typeof rbush === 'function') {
          try {
            return rbush(options.maxEntries);
          } catch (error) {
            console.error('Failed to create rbush index via rbush()', error);
          }
        }
        if (typeof RBush === 'function') {
          try {
            return new RBush(options.maxEntries);
          } catch (error) {
            console.error('Failed to create rbush index via new RBush()', error);
          }
        }
        console.error('RBush spatial index library is not available. Route overlap rendering will be disabled.');
        return null;
      }

      function mergeRouteLayerOptions(overrides = {}, rendererOverride = null, paneOverride = null) {
        const base = Object.assign({}, ROUTE_LAYER_BASE_OPTIONS);
        const renderer = rendererOverride || sharedRouteRenderer;
        if (renderer) {
          base.renderer = renderer;
        }
        const pane = paneOverride || routePaneName;
        if (typeof pane === 'string' && pane) {
          base.pane = pane;
        }
        return Object.assign(base, overrides || {});
      }

      const params = new URLSearchParams(window.location.search);
      const kioskParam = params.get('kioskMode');
      if (kioskParam !== null) {
        kioskMode = kioskParam.toLowerCase() === 'true';
      }
      const adminKioskParam = params.get('adminKioskMode');
      if (adminKioskParam !== null) {
        adminKioskMode = adminKioskParam.toLowerCase() === 'true';
      }
      const adminParam = params.get('adminMode');
      if (adminParam !== null) {
        adminMode = adminParam.toLowerCase() === 'true';
      }

      const showRadarParam = params.get('showRadar');
      if (showRadarParam !== null) {
        showRadar = showRadarParam.toLowerCase() === 'true';
      }
      const radarProductParam = params.get('radarProduct');
      if (radarProductParam) {
        radarConfiguredProduct = normalizeRadarProduct(radarProductParam);
      }
      const radarOpacityParam = params.get('radarOpacity');
      if (radarOpacityParam !== null) {
        const parsedOpacity = Number.parseFloat(radarOpacityParam);
        if (Number.isFinite(parsedOpacity)) {
          radarConfiguredOpacity = clampRadarOpacity(parsedOpacity);
        }
      }

      initializeRadarPreferences();

      const outOfServiceRouteColor = '#000000';

      const PULSEPOINT_ENDPOINT = "https://api.pulsepoint.org/v1/webapp?resource=incidents&agencyid=54000,00300";
      const PULSEPOINT_PASSPHRASE = "tombrady5rings";
      const INCIDENT_REFRESH_INTERVAL_MS = 45000;
      const FALLBACK_INCIDENT_ICON_SIZE = 36;
      const INCIDENT_ICON_SCALE = 0.25;
      const DEFAULT_ICON_SCALE = Number.isFinite(INCIDENT_ICON_SCALE) && INCIDENT_ICON_SCALE > 0
        ? INCIDENT_ICON_SCALE
        : 1;
      const DEFAULT_SCALED_INCIDENT_ICON_HEIGHT = Math.max(1, Math.round(FALLBACK_INCIDENT_ICON_SIZE * DEFAULT_ICON_SCALE));
      const HALO_MIN_RADIUS_PX = 16;
      const HALO_MAX_RADIUS_PX = 64;
      const HALO_BASE_OPACITY = 0.5;
      const HALO_DURATION_MS = 1600;
      const HALO_COLOR_DEFAULT = '#FF5A3C';
      const HALO_COLOR_RGB = (() => {
        if (typeof HALO_COLOR_DEFAULT !== 'string') return '255, 90, 60';
        const hex = HALO_COLOR_DEFAULT.replace(/[^0-9a-f]/gi, '').trim();
        if (hex.length === 3) {
          const r = parseInt(hex[0] + hex[0], 16);
          const g = parseInt(hex[1] + hex[1], 16);
          const b = parseInt(hex[2] + hex[2], 16);
          if ([r, g, b].every(value => Number.isFinite(value))) {
            return `${r}, ${g}, ${b}`;
          }
        } else if (hex.length === 6) {
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          if ([r, g, b].every(value => Number.isFinite(value))) {
            return `${r}, ${g}, ${b}`;
          }
        }
        return '255, 90, 60';
      })();
      const INCIDENT_HALO_ANIMATED_LIMIT = 60;
      // To tweak the centroid offset without editing this file, set
      // window.HeadwayGuardIncidentMarkerOffset = { xFactor: <number>, yFactor: <number> }
      // before this script runs. Factors are multiplied by the scaled marker height.
      const markerCentroidOverride = (typeof window !== 'undefined' && window.HeadwayGuardIncidentMarkerOffset)
        ? window.HeadwayGuardIncidentMarkerOffset
        : null;
      const MARKER_CENTROID_OFFSET_Y_FACTOR = typeof markerCentroidOverride?.yFactor === 'number'
        ? markerCentroidOverride.yFactor
        : -0.18;
      const MARKER_CENTROID_OFFSET_X_FACTOR = typeof markerCentroidOverride?.xFactor === 'number'
        ? markerCentroidOverride.xFactor
        : 0;
      const INCIDENTS_ALLOWED_AGENCY_NAMES = ['University of Virginia', 'University of Virginia Health'];
      const TRAIN_API_URL = 'https://api-v3.amtraker.com/v3/trains';
      const TRAIN_POLL_INTERVAL_MS = 30000;
      const TRAIN_TARGET_STATION_CODE = 'CVS';
      const TRAIN_CARDINAL_HEADING_DEGREES = Object.freeze({
        N: 0,
        NORTH: 0,
        NORTHBOUND: 0,
        NE: 45,
        NORTHEAST: 45,
        NORTHEASTBOUND: 45,
        E: 90,
        EAST: 90,
        EASTBOUND: 90,
        SE: 135,
        SOUTHEAST: 135,
        SOUTHEASTBOUND: 135,
        S: 180,
        SOUTH: 180,
        SOUTHBOUND: 180,
        SW: 225,
        SOUTHWEST: 225,
        SOUTHWESTBOUND: 225,
        W: 270,
        WEST: 270,
        WESTBOUND: 270,
        NW: 315,
        NORTHWEST: 315,
        NORTHWESTBOUND: 315
      });
      const CAT_API_BASE_URL = 'https://catpublic.etaspot.net/service.php';
      const CAT_API_TOKEN = 'TESTING';
      const CAT_VEHICLE_FETCH_INTERVAL_MS = 5000;
      const CAT_METADATA_REFRESH_INTERVAL_MS = 5 * 60 * 1000;
      const CAT_SERVICE_ALERT_REFRESH_INTERVAL_MS = 60000;
      const CAT_SERVICE_ALERT_UNAVAILABLE_MESSAGE = 'CAT service alerts are unavailable.';
      const CAT_VEHICLE_MARKER_DEFAULT_COLOR = '#0f172a';
      const CAT_VEHICLE_MARKER_MIN_LABEL = 'CAT';
      const CAT_MAX_TOOLTIP_ETAS = 3;

      let map;
      let markers = {};
      let busMarkerStates = {};
      let trainMarkers = {};
      let trainMarkerStates = {};
      let trainsVisible = false;
      let planesVisible = false;
      let trainFetchPromise = null;
      const vehicleHeadingCache = new Map();
      let vehicleHeadingCachePromise = null;
      const VEHICLE_HEADING_CACHE_ENDPOINT = '/v1/vehicle_headings';
      let pendingBusVisualUpdates = new Map();
      let busMarkerVisualUpdateFrame = null;
      let selectedVehicleId = null;
      let markerScaleUpdateFrame = null;
      let pendingMarkerScaleMetrics = null;
      let textMeasurementCanvas = null;

      let agencies = [];
      let baseURL = '';
      let catOverlayEnabled = false;
      let catLayerGroup = null;
      const catVehicleMarkers = new Map();
      const catRoutesById = new Map();
      const catStopsById = new Map();
      const CAT_OUT_OF_SERVICE_ROUTE_KEY = '__CAT_OUT_OF_SERVICE__';
      const CAT_OUT_OF_SERVICE_NUMERIC_ROUTE_ID = 777;
      const catRouteSelections = new Map();
      let catActiveRouteKeys = new Set();
      const catVehiclesById = new Map();
      let catRefreshIntervals = [];
      let catRoutesLastFetchTime = 0;
      let catStopsLastFetchTime = 0;
      const catRoutePatternGeometries = new Map();
      const catRoutePatternLayers = new Map();
      const catOverlapPatternIdMap = new Map();
      const catOverlapInfoByNumericId = new Map();
      let nextCatOverlapNumericId = 1000000;
      let catRoutePatternsLastFetchTime = 0;
      let catRoutePatternsCache = [];
      let catVehiclesPaneName = 'catVehiclesPane';
      let catServiceAlerts = [];
      let catServiceAlertsLoading = false;
      let catServiceAlertsError = null;
      let catServiceAlertsFetchPromise = null;
      let catServiceAlertsLastFetchTime = 0;
      let catBusMarkerSvgPromise = null;

      let incidentsVisible = false;
      let incidentsVisibilityPreference = false;
      let incidentLayerGroup = null;
      const incidentMarkers = new Map();
      const incidentIconCache = new Map();
      const incidentHaloIconCache = new Map();
      let incidentHaloLayerGroup = null;
      let incidentsNearRoutesLookup = new Map();
      const reduceMotionMediaQuery = (typeof window !== 'undefined' && typeof window.matchMedia === 'function')
        ? window.matchMedia('(prefers-reduced-motion: reduce)')
        : null;
      let isFetchingIncidents = false;

      const SERVICE_ALERT_REFRESH_INTERVAL_MS = 60000;
      const SERVICE_ALERT_START_FIELDS = Object.freeze([
        'StartDateText',
        'StartDateDisplay',
        'StartDateLocalText',
        'StartDateLocal',
        'StartDate',
        'StartDateUtc',
        'StartDateTime',
        'StartDateISO',
        'StartTimestamp',
        'StartTime',
        'Start',
        'BeginDateText',
        'BeginDate',
        'BeginDateUtc',
        'BeginTime',
        'EffectiveStart',
        'EffectiveStartDate',
        'EffectiveStartUtc'
      ]);
      const SERVICE_ALERT_END_FIELDS = Object.freeze([
        'EndDateText',
        'EndDateDisplay',
        'EndDateLocalText',
        'EndDateLocal',
        'EndDate',
        'EndDateUtc',
        'EndDateTime',
        'EndDateISO',
        'EndTimestamp',
        'EndTime',
        'End',
        'StopDateText',
        'StopDate',
        'StopDateUtc',
        'StopTime',
        'ExpirationDate',
        'ExpirationDateUtc',
        'ExpireDate',
        'ExpireDateUtc',
        'EffectiveEnd',
        'EffectiveEndDate',
        'EffectiveEndUtc'
      ]);
      const SERVICE_ALERT_UNAVAILABLE_MESSAGE = 'Service alerts unavailable.';
      const SERVICE_ALERT_STATUS_NO_ALERTS = 'No Active Alerts';
      const SERVICE_ALERT_STATUS_LOADING = 'Loading';
      const SERVICE_ALERT_STATUS_ERROR = 'Unavailable';
      const SERVICE_ALERT_DATE_FORMATTER = (() => {
        if (typeof Intl === 'undefined' || typeof Intl.DateTimeFormat !== 'function') {
          return null;
        }
        try {
          return new Intl.DateTimeFormat('en-US', {
            dateStyle: 'medium',
            timeStyle: 'short',
            timeZoneName: 'short'
          });
        } catch (error) {
          try {
            return new Intl.DateTimeFormat('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
              hour: 'numeric',
              minute: '2-digit',
              timeZoneName: 'short'
            });
          } catch (fallbackError) {
            return null;
          }
        }
      })();
      let serviceAlerts = [];
      let serviceAlertsLoading = false;
      let serviceAlertsError = null;
      let serviceAlertsExpanded = false;
      let serviceAlertsLastFetchAgency = '';
      let serviceAlertsLastFetchTime = 0;
      let serviceAlertsFetchPromise = null;
      let serviceAlertsHasLoaded = false;

      function hasIncidentsRequiringVisibility() {
        return incidentsNearRoutesLookup instanceof Map && incidentsNearRoutesLookup.size > 0;
      }

      function shouldShowIncidentLayer() {
        if (!incidentsAreAvailable()) {
          return false;
        }
        return incidentsVisible || hasIncidentsRequiringVisibility();
      }

      function maintainIncidentLayers() {
        if (!map) return;
        const shouldShow = shouldShowIncidentLayer();
        if (!incidentLayerGroup) {
          incidentLayerGroup = L.layerGroup();
        }
        if (shouldShow) {
          if (!map.hasLayer(incidentLayerGroup)) {
            incidentLayerGroup.addTo(map);
          }
        } else if (map.hasLayer(incidentLayerGroup)) {
          map.removeLayer(incidentLayerGroup);
        }
        const shouldShowHalos = shouldShow && hasIncidentsRequiringVisibility();
        if (!incidentHaloLayerGroup) {
          incidentHaloLayerGroup = L.layerGroup();
        }
        if (shouldShowHalos) {
          if (!map.hasLayer(incidentHaloLayerGroup)) {
            incidentHaloLayerGroup.addTo(map);
          }
        } else if (map.hasLayer(incidentHaloLayerGroup)) {
          map.removeLayer(incidentHaloLayerGroup);
        }
      }

      const INCIDENT_ROUTE_PROXIMITY_THRESHOLD_METERS = 150;
      const INCIDENT_TIME_ZONE = 'America/New_York';
      const INCIDENT_LIST_ICON_BASE_URL = 'https://web.pulsepoint.org/images/respond_icons/';
      const INCIDENT_TYPE_LABELS = Object.freeze({
        AED: 'AED Alarm',
        AC: 'Aircraft Crash',
        AE: 'Aircraft Emergency',
        AES: 'Aircraft Emergency Standby',
        OA: 'Alarm',
        AR: 'Animal Rescue',
        AF: 'Appliance Fire',
        AI: 'Arson Investigation',
        AA: 'Auto Aid',
        BT: 'Bomb Threat',
        BP: 'Burn Permit',
        CMA: 'Carbon Monoxide',
        CHIM: 'Chimney Fire',
        CR: 'Cliff Rescue',
        TCP: 'Collision Involving Pedestrian',
        TCS: 'Collision Involving Structure',
        TCT: 'Collision Involving Train',
        CF: 'Commercial Fire',
        CL: 'Commercial Lockout',
        CA: 'Community Activity',
        CP: 'Community Paramedicine',
        CSR: 'Confined Space Rescue',
        WF: 'Confirmed Fire',
        WSF: 'Confirmed Structure Fire',
        WVEG: 'Confirmed Vegetation Fire',
        CB: 'Controlled Burn/Prescribed Fire',
        EQ: 'Earthquake',
        EE: 'Electrical Emergency',
        ELF: 'Electrical Fire',
        ELR: 'Elevator Rescue',
        EER: 'Elevator/Escalator Rescue',
        EM: 'Emergency',
        ER: 'Emergency Response',
        TCE: 'Expanded Traffic Collision',
        EX: 'Explosion',
        EF: 'Extinguished Fire',
        FIRE: 'Fire',
        FA: 'Fire Alarm',
        FW: 'Fire Watch',
        FWI: 'Fireworks Investigation',
        FLW: 'Flood Warning',
        FL: 'Flooding',
        FULL: 'Full Assignment',
        GAS: 'Gas Leak',
        HC: 'Hazardous Condition',
        HMR: 'Hazardous Response',
        HMI: 'Hazmat Investigation',
        IR: 'Ice Rescue',
        IF: 'Illegal Fire',
        IA: 'Industrial Accident',
        IFT: 'Interfacility Transfer',
        INV: 'Investigation',
        LR: 'Ladder Request',
        LZ: 'Landing Zone',
        LA: 'Lift Assist',
        LO: 'Lockout',
        MA: 'Manual Alarm',
        MF: 'Marine Fire',
        ME: 'Medical Emergency',
        MC: 'Move-up/Cover',
        MCI: 'Multi Casualty',
        MU: 'Mutual Aid',
        NO: 'Notification',
        OI: 'Odor Investigation',
        OF: 'Outside Fire',
        PE: 'Pipeline Emergency',
        PF: 'Pole Fire',
        PA: 'Police Assist',
        PLE: 'Powerline Emergency',
        PS: 'Public Service',
        RTE: 'Railroad/Train Emergency',
        GF: 'Refuse/Garbage Fire',
        RES: 'Rescue',
        RF: 'Residential Fire',
        RL: 'Residential Lockout',
        RR: 'Rope Rescue',
        SH: 'Sheared Hydrant',
        SD: 'Smoke Detector',
        SI: 'Smoke Investigation',
        STBY: 'Standby',
        ST: 'Strike Team/Task Force',
        SC: 'Structural Collapse',
        SF: 'Structure Fire',
        TF: 'Tank Fire',
        TR: 'Technical Rescue',
        TEST: 'Test',
        TOW: 'Tornado Warning',
        TC: 'Traffic Collision',
        TRNG: 'Training',
        TE: 'Transformer Explosion',
        TD: 'Tree Down',
        TNR: 'Trench Rescue',
        TRBL: 'Trouble Alarm',
        TSW: 'Tsunami Warning',
        USAR: 'Urban Search and Rescue',
        VEG: 'Vegetation Fire',
        VF: 'Vehicle Fire',
        VL: 'Vehicle Lockout',
        VS: 'Vessel Sinking',
        WE: 'Water Emergency',
        WR: 'Water Rescue',
        WFA: 'Waterflow Alarm',
        WX: 'Weather Incident',
        WA: 'Wires Arching',
        WD: 'Wires Down',
        WDA: 'Wires Down/Arcing',
        WCF: 'Working Commercial Fire',
        WRF: 'Working Residential Fire'
      });
      const INCIDENT_RECEIVED_FIELDS = Object.freeze([
        'CallReceivedDateTime',
        'ReceivedDateTime',
        'Received',
        'CallReceived',
        'FirstReceived',
        'CreateDate',
        'CreatedDateTime',
        'DispatchDateTime'
      ]);
      const INCIDENT_UNIT_STATUS_INFO = Object.freeze({
        DP: { label: 'Dispatched', color: '#f57c00', background: 'rgba(245, 124, 0, 0.16)', border: 'rgba(245, 124, 0, 0.38)' },
        AK: { label: 'Acknowledged', color: '#f57c00', background: 'rgba(245, 124, 0, 0.16)', border: 'rgba(245, 124, 0, 0.38)' },
        ER: { label: 'En Route', color: '#00cc00', background: 'rgba(0, 204, 0, 0.16)', border: 'rgba(0, 204, 0, 0.38)' },
        SG: { label: 'Staged', color: '#cc0000', background: 'rgba(204, 0, 0, 0.16)', border: 'rgba(204, 0, 0, 0.38)' },
        OS: { label: 'On Scene', color: '#cc0000', background: 'rgba(204, 0, 0, 0.16)', border: 'rgba(204, 0, 0, 0.38)' },
        AE: { label: 'Available On Scene', color: '#cc0000', background: 'rgba(204, 0, 0, 0.16)', border: 'rgba(204, 0, 0, 0.38)' },
        TR: { label: 'Transport', color: '#ffc107', background: 'rgba(255, 193, 7, 0.16)', border: 'rgba(255, 193, 7, 0.38)' },
        TA: { label: 'Transport Arrived', color: '#1976d2', background: 'rgba(25, 118, 210, 0.16)', border: 'rgba(25, 118, 210, 0.38)' },
        AR: { label: 'Cleared From Incident', color: '#494949', background: 'rgba(73, 73, 73, 0.16)', border: 'rgba(73, 73, 73, 0.38)' }
      });
      const INCIDENT_UNIT_STATUS_ALIASES = Object.freeze({
        DP: 'DP',
        DISPATCHED: 'DP',
        DISPATCH: 'DP',
        AK: 'AK',
        ACK: 'AK',
        ACKNOWLEDGED: 'AK',
        ER: 'ER',
        'EN ROUTE': 'ER',
        ENROUTE: 'ER',
        SG: 'SG',
        STAGED: 'SG',
        OS: 'OS',
        'ON SCENE': 'OS',
        'ON-SCENE': 'OS',
        ONSCENE: 'OS',
        AE: 'AE',
        'AVAILABLE ON SCENE': 'AE',
        'AVAILABLE ONSCENE': 'AE',
        'AVAILABLE ON-SCENE': 'AE',
        'AVAIL ON SCENE': 'AE',
        TR: 'TR',
        TRANSPORT: 'TR',
        TRANSPORTING: 'TR',
        TA: 'TA',
        'TRANSPORT ARRIVED': 'TA',
        'TRANSPORT-ARRIVED': 'TA',
        'TRANSPORT ARRVD': 'TA',
        AR: 'AR',
        CLEARED: 'AR',
        'CLEARED FROM INCIDENT': 'AR'
      });
      const INCIDENT_UNIT_STATUS_SECTION_ORDER = Object.freeze([
        'OS',
        'AE',
        'SG',
        'ER',
        'TR',
        'TA',
        'DP',
        'AK',
        'AR'
      ]);
      const INCIDENT_UNIT_STATUS_FALLBACK_LABEL = 'Status Unknown';

      let latestActiveIncidents = [];
      let incidentsNearRoutes = [];
      let incidentRouteAlertSignature = '';
      // Demo incident preview state (delete when demo button is removed).
      let demoIncidentActive = false;
      let demoIncidentEntry = null;
      let demoIncidentPreviousVisibility = null;
      const DEMO_INCIDENT_STATIC_ROW = Object.freeze({
        Marker: 'https://web.pulsepoint.org/images/respond_icons/me_map_active.png',
        Category: 'active',
        ID: '2296541797',
        Type: 'ME',
        Address: 'HILLSDALE DR, CHARLOTTESVILLE, VA',
        Received: '2025-09-22T02:25:48Z',
        Agency: '00300',
        Latitude: '38.0739216008',
        Longitude: '-78.4735028808',
        Units: 'E83 (OS), RS18 (OS)'
      });

      let demoIncidentCsvRow = null;

      function incidentsAreAvailable() {
        if (!adminFeaturesAllowed()) {
          return false;
        }
        if (!Array.isArray(agencies) || agencies.length === 0) {
          return true;
        }
        const sanitizedBaseURL = typeof baseURL === 'string' ? baseURL.trim().replace(/\/+$/, '') : '';
        const selectedAgency = agencies.find(agency => {
          if (!agency || typeof agency.url !== 'string') return false;
          const candidateUrl = agency.url.trim().replace(/\/+$/, '');
          return candidateUrl === sanitizedBaseURL;
        });
        if (!selectedAgency || typeof selectedAgency.name !== 'string') {
          return false;
        }
        const normalizedName = selectedAgency.name.trim().toLowerCase();
        return INCIDENTS_ALLOWED_AGENCY_NAMES.some(name => {
          return typeof name === 'string' && name.trim().toLowerCase() === normalizedName;
        });
      }

      if (!incidentsAreAvailable()) {
        incidentsVisible = false;
      }
      incidentsVisibilityPreference = incidentsVisible;

      function fetchPulsePointEncrypted() {
        return fetch(PULSEPOINT_ENDPOINT, {
          method: 'GET',
          mode: 'cors',
          cache: 'no-store'
        }).then(response => {
          if (!response || !response.ok) {
            throw new Error(response ? `PulsePoint HTTP ${response.status}` : 'PulsePoint request failed');
          }
          return response.json();
        });
      }

      function decryptPulsePointPayload(encryptedObj) {
        if (!encryptedObj) {
          throw new Error('Missing PulsePoint payload.');
        }
        const obj = typeof encryptedObj === 'string' ? JSON.parse(encryptedObj) : encryptedObj;
        if (!obj || typeof obj !== 'object' || !obj.ct) {
          throw new Error('PulsePoint payload is malformed.');
        }
        const cipherParams = CryptoJS.lib.CipherParams.create({
          ciphertext: CryptoJS.enc.Base64.parse(obj.ct)
        });
        if (obj.iv) cipherParams.iv = CryptoJS.enc.Hex.parse(obj.iv);
        if (obj.s) cipherParams.salt = CryptoJS.enc.Hex.parse(obj.s);
        const rawText = CryptoJS.AES.decrypt(cipherParams, PULSEPOINT_PASSPHRASE, {
          mode: CryptoJS.mode.CBC,
          padding: CryptoJS.pad.Pkcs7
        }).toString(CryptoJS.enc.Utf8);
        if (!rawText) {
          throw new Error('PulsePoint decryption returned empty payload.');
        }
        let parsed = rawText;
        for (let i = 0; i < 3; i += 1) {
          if (typeof parsed === 'string') {
            try {
              parsed = JSON.parse(parsed);
              continue;
            } catch (error) {
              break;
            }
          }
          break;
        }
        if (typeof parsed === 'string') {
          throw new Error('PulsePoint decrypted payload is not valid JSON.');
        }
        return { parsed, rawText };
      }

      function looksLikePulsePointIncident(obj) {
        if (!obj || typeof obj !== 'object') return false;
        const keys = ['ID', 'FullDisplayAddress', 'PulsePointIncidentCallType', 'CallReceivedDateTime', 'Latitude', 'Longitude'];
        return keys.filter(key => key in obj).length >= 2;
      }

      function inferPulsePointMarkerType(rec) {
        const candidates = [
          rec.PulsePointIncidentCallTypePrimaryCode,
          rec.PulsePointIncidentCallTypeCode,
          rec.PulsePointIncidentCallTypeID,
          rec.PulsePointIncidentTypeCode,
          rec.PulsePointIncidentType,
          rec.CallTypeCode,
          rec.TypeCode,
          rec.CallType,
          rec.Type,
          rec.IncidentType,
          rec.PulsePointIncidentCallType
        ];
        for (const value of candidates) {
          if (value == null) continue;
          const raw = typeof value === 'number' ? value.toString() : String(value);
          const trimmed = raw.trim();
          if (!trimmed) continue;
          if (/^[A-Za-z0-9]{1,6}$/.test(trimmed)) return trimmed.toUpperCase();
          const firstToken = trimmed.split(/[\s/-]+/)[0];
          if (firstToken && /^[A-Za-z0-9]{1,4}$/.test(firstToken)) return firstToken.toUpperCase();
          const words = trimmed.match(/[A-Za-z0-9]+/g);
          if (words && words.length >= 2) {
            const acronym = words.map(word => word[0]).join('');
            if (acronym && /^[A-Za-z0-9]{1,4}$/.test(acronym)) return acronym.toUpperCase();
          }
        }
        return '';
      }

      function buildPulsePointMarkerUrl(type, category) {
        const categoryLower = (category || '').toLowerCase();
        if (!type || (categoryLower !== 'active' && categoryLower !== 'recent')) return '';
        return `https://web.pulsepoint.org/images/respond_icons/${type.toLowerCase()}_map_${categoryLower}.png`;
      }

      function pulsePointMarkerAltText(type, category, fallback) {
        const parts = [];
        if (type) parts.push(type);
        if (category) parts.push(category);
        if (!parts.length && fallback) parts.push(fallback);
        if (!parts.length) return 'Marker icon';
        parts.push('marker icon');
        return parts.join(' ');
      }

      function decoratePulsePointIncident(rec, category) {
        const copy = { ...(rec || {}), _category: category };
        if (Array.isArray(copy.Unit)) {
          copy._units = copy.Unit.map(u => {
            const id = u.UnitID || u.Unit || '';
            const status = u.PulsePointDispatchStatus || u.Status || '';
            return status ? `${id} (${status})` : id;
          }).join(', ');
        } else {
          copy._units = '';
        }
        const markerType = inferPulsePointMarkerType(copy);
        const markerCategory = (category || '').toLowerCase();
        const markerUrl = buildPulsePointMarkerUrl(markerType, markerCategory);
        copy._markerType = markerType;
        copy._markerCategory = markerUrl ? markerCategory : '';
        copy._markerUrl = markerUrl;
        copy._markerAlt = markerUrl ? pulsePointMarkerAltText(markerType, markerCategory, copy.PulsePointIncidentCallType) : '';
        return copy;
      }

      function normalizePulsePointIncidents(root) {
        const out = [];
        const incidentsRoot = root && root.incidents;
        const categories = [['active', 'active'], ['recent', 'recent'], ['alerts', 'alerts']];
        let pulled = 0;
        if (incidentsRoot && typeof incidentsRoot === 'object') {
          for (const [key, label] of categories) {
            const arr = Array.isArray(incidentsRoot[key]) ? incidentsRoot[key] : [];
            arr.forEach(rec => out.push(decoratePulsePointIncident(rec, label)));
            pulled += arr.length;
          }
          if (pulled) return out;
        }
        const rootKeys = root && typeof root === 'object' ? Object.keys(root) : [];
        for (const key of rootKeys) {
          const value = root[key];
          if (Array.isArray(value) && value.every(looksLikePulsePointIncident)) {
            value.forEach(rec => out.push(decoratePulsePointIncident(rec, key)));
          } else if (value && typeof value === 'object') {
            Object.keys(value).forEach(innerKey => {
              const innerValue = value[innerKey];
              if (Array.isArray(innerValue) && innerValue.every(looksLikePulsePointIncident)) {
                innerValue.forEach(rec => out.push(decoratePulsePointIncident(rec, innerKey)));
              }
            });
          }
        }
        if (out.length) return out;
        (function dig(x, label = 'misc') {
          if (!x) return;
          if (Array.isArray(x) && x.length && looksLikePulsePointIncident(x[0])) {
            x.forEach(rec => out.push(decoratePulsePointIncident(rec, label)));
            return;
          }
          if (typeof x === 'object') {
            Object.keys(x).forEach(childKey => dig(x[childKey], childKey));
          }
        })(root);
        return out;
      }

      function resetIncidentAlertState() {
        latestActiveIncidents = [];
        updateIncidentsNearRoutes([], '');
      }

      function parseIncidentDate(value) {
        if (value === undefined || value === null || value === '') return null;
        if (value instanceof Date && !Number.isNaN(value.getTime())) return value;
        if (typeof value === 'number' && Number.isFinite(value)) {
          const fromNumber = new Date(value);
          return Number.isNaN(fromNumber.getTime()) ? null : fromNumber;
        }
        const str = String(value).trim();
        if (!str) return null;
        let parsed = new Date(str);
        if (!Number.isNaN(parsed.getTime())) return parsed;
        if (!/[zZ]|[+-]\d{2}:?\d{2}$/.test(str)) {
          parsed = new Date(`${str}Z`);
          if (!Number.isNaN(parsed.getTime())) return parsed;
        }
        return null;
      }

      function getIncidentReceivedTimeInfo(incident) {
        if (!incident) return null;
        for (const field of INCIDENT_RECEIVED_FIELDS) {
          if (!Object.prototype.hasOwnProperty.call(incident, field)) continue;
          const date = parseIncidentDate(incident[field]);
          if (!date) continue;
          try {
            const display = new Intl.DateTimeFormat('en-US', {
              hour: 'numeric',
              minute: '2-digit',
              hour12: true,
              timeZone: INCIDENT_TIME_ZONE
            }).format(date);
            const full = new Intl.DateTimeFormat('en-US', {
              dateStyle: 'medium',
              timeStyle: 'short',
              timeZone: INCIDENT_TIME_ZONE
            }).format(date);
            return { display, full };
          } catch (error) {
            const fallback = date.toLocaleString();
            return { display: fallback, full: fallback };
          }
        }
        return null;
      }

      function getIncidentTimestamp(incident) {
        if (!incident) return null;
        for (const field of INCIDENT_RECEIVED_FIELDS) {
          if (!Object.prototype.hasOwnProperty.call(incident, field)) continue;
          const date = parseIncidentDate(incident[field]);
          if (date) {
            return date.getTime();
          }
        }
        return null;
      }

      // === Demo incident CSV helpers (remove alongside the demo button) ===
      function parseCsvRows(text) {
        if (typeof text !== 'string') return [];
        const rows = [];
        let current = [];
        let field = '';
        let inQuotes = false;
        for (let i = 0; i < text.length; i += 1) {
          const char = text[i];
          if (inQuotes) {
            if (char === '"') {
              if (text[i + 1] === '"') {
                field += '"';
                i += 1;
              } else {
                inQuotes = false;
              }
            } else {
              field += char;
            }
            continue;
          }
          if (char === '"') {
            inQuotes = true;
            continue;
          }
          if (char === ',') {
            current.push(field);
            field = '';
            continue;
          }
          if (char === '\r') {
            continue;
          }
          if (char === '\n') {
            current.push(field);
            rows.push(current);
            current = [];
            field = '';
            continue;
          }
          field += char;
        }
        if (field !== '' || current.length > 0) {
          current.push(field);
        }
        if (current.length > 0) {
          rows.push(current);
        }
        return rows.filter(row => Array.isArray(row) && row.some(value => String(value ?? '').trim() !== ''));
      }

      function extractFirstIncidentFromCsv(text) {
        const rows = parseCsvRows(text);
        if (!rows.length) return null;
        const header = rows[0].map(cell => String(cell ?? '').trim());
        for (let i = 1; i < rows.length; i += 1) {
          const row = rows[i];
          if (!row || !row.some(value => String(value ?? '').trim() !== '')) continue;
          const obj = {};
          header.forEach((key, index) => {
            if (!key) return;
            obj[key] = row[index] !== undefined ? row[index] : '';
          });
          const hasValue = Object.keys(obj).some(key => String(obj[key] ?? '').trim() !== '');
          if (hasValue) {
            return obj;
          }
        }
        return null;
      }

      function buildDemoIncidentEntryFromRow(row) {
        if (!row || typeof row !== 'object') return null;
        const sanitize = value => (typeof value === 'string' ? value.trim() : value);
        const typeValue = sanitize(row.Type) || 'INC';
        const typeCode = String(typeValue || '').trim().toUpperCase();
        const idRaw = sanitize(row.ID) || 'DEMO_INCIDENT';
        const id = String(idRaw).trim() || 'DEMO_INCIDENT';
        const normalizedId = getNormalizedIncidentId(id) || 'DEMO_INCIDENT';
        const markerUrl = sanitize(row.Marker) || '';
        const category = sanitize(row.Category) || 'active';
        const address = sanitize(row.Address) || 'Demo Address';
        const received = sanitize(row.Received) || new Date().toISOString();
        const agency = sanitize(row.Agency) || '';
        const units = sanitize(row.Units) || '';
        const lat = parseIncidentCoordinate(sanitize(row.Latitude));
        const lon = parseIncidentCoordinate(sanitize(row.Longitude));
        const label = (typeCode && Object.prototype.hasOwnProperty.call(INCIDENT_TYPE_LABELS, typeCode))
          ? INCIDENT_TYPE_LABELS[typeCode]
          : (typeValue ? String(typeValue) : 'Incident');
        const incident = {
          _markerUrl: markerUrl,
          _markerType: typeCode || 'INC',
          _category: category,
          _demo: true,
          ID: normalizedId,
          IncidentID: normalizedId,
          Type: typeCode || typeValue,
          TypeCode: typeCode || typeValue,
          PulsePointIncidentCallType: label,
          PulsePointIncidentCallTypeCode: typeCode || typeValue,
          CallType: label,
          CallTypeCode: typeCode || typeValue,
          Received: received,
          DisplayAddress: address,
          FullDisplayAddress: address,
          Address: address,
          Latitude: lat,
          Longitude: lon,
          Units: units,
          Agency: agency
        };
        const timestamp = getIncidentTimestamp(incident) ?? Date.now();
        const demoRouteColor = sanitizeCssColor(routeColors?.[404] || '#F97316');
        return {
          id: normalizedId,
          incident,
          routes: [
            { routeId: 404, name: 'Demo Route 404', distance: 42, color: demoRouteColor }
          ],
          closestDistance: 42,
          timestamp,
          _demo: true,
          _demoSignature: `demo-${normalizedId}`
        };
      }

      async function ensureDemoIncidentRow() {
        if (demoIncidentCsvRow) return demoIncidentCsvRow;
        if (!DEMO_INCIDENT_STATIC_ROW) return null;
        demoIncidentCsvRow = { ...DEMO_INCIDENT_STATIC_ROW };
        return demoIncidentCsvRow;
      }

      function createDemoIncidentEntry() {
        if (!demoIncidentCsvRow) return null;
        const entry = buildDemoIncidentEntryFromRow(demoIncidentCsvRow);
        if (!entry) return null;
        entry.incident = entry.incident ? { ...entry.incident } : null;
        entry.routes = Array.isArray(entry.routes)
          ? entry.routes.map(route => ({ ...route }))
          : [];
        return entry;
      }

      function normalizeUnitStatus(value) {
        if (value === undefined || value === null || value === '') {
          return { key: '', raw: '' };
        }
        const raw = String(value).trim();
        if (!raw) {
          return { key: '', raw: '' };
        }
        const upper = raw.toUpperCase();
        const canonical = INCIDENT_UNIT_STATUS_ALIASES[upper] || '';
        const info = canonical ? INCIDENT_UNIT_STATUS_INFO[canonical] || null : null;
        const label = info?.label || raw;
        return { key: canonical, raw, info, label };
      }

      function parseUnitString(text) {
        if (typeof text !== 'string') {
          return { name: '', status: '', raw: '' };
        }
        const trimmed = text.trim();
        if (!trimmed) {
          return { name: '', status: '', raw: '' };
        }
        const match = trimmed.match(/^(.*?)\s*\(([^)]*)\)\s*$/);
        if (match) {
          return {
            name: match[1].trim(),
            status: match[2].trim(),
            raw: trimmed
          };
        }
        return { name: trimmed, status: '', raw: trimmed };
      }

      function extractIncidentUnits(incident) {
        const units = [];
        if (incident && Array.isArray(incident.Unit)) {
          incident.Unit.forEach(entry => {
            if (!entry) return;
            const nameCandidates = [
              entry.UnitID,
              entry.Unit,
              entry.Name,
              entry.ApparatusID,
              entry.VehicleID
            ];
            let name = nameCandidates.find(value => typeof value === 'string' && value.trim());
            const statusCandidates = [
              entry.PulsePointDispatchStatus,
              entry.DispatchStatus,
              entry.Status,
              entry.UnitStatus
            ];
            let status = statusCandidates.find(value => typeof value === 'string' && value.trim());
            let parsed = null;
            if (typeof entry === 'string') {
              parsed = parseUnitString(entry);
              if (!status && parsed.status) {
                status = parsed.status;
              }
              if (!name && parsed.name) {
                name = parsed.name;
              }
            }
            const normalized = normalizeUnitStatus(status);
            const statusKey = normalized.key || '';
            const normalizedLabel = typeof normalized.label === 'string' ? normalized.label.trim() : '';
            const statusLabel = normalizedLabel || (typeof normalized.raw === 'string' ? normalized.raw.trim() : '');
            const unitName = typeof name === 'string' ? name.trim() : '';
            const rawText = parsed?.raw && parsed.raw.trim()
              ? parsed.raw.trim()
              : (typeof entry === 'string' ? entry.trim() : '');
            const displayText = unitName || statusLabel || rawText;
            if (!displayText) return;
            let tooltip = '';
            if (statusLabel) {
              tooltip = statusLabel;
            }
            if (normalized.raw && normalized.raw !== statusLabel && (!tooltip || tooltip.toLowerCase() !== normalized.raw.toLowerCase())) {
              tooltip = tooltip ? `${tooltip}  ${normalized.raw}` : normalized.raw;
            }
            units.push({
              displayText,
              statusKey,
              statusLabel,
              colorInfo: normalized.info || null,
              tooltip,
              rawStatus: normalized.raw,
              name: unitName
            });
          });
        }
        if (units.length === 0) {
          const stringCandidates = [
            incident?._units,
            incident?.Units,
            incident?.Apparatus,
            incident?.UnitString
          ];
          const source = stringCandidates.find(value => typeof value === 'string' && value.trim());
          if (source) {
            source.split(',').map(part => part.trim()).filter(Boolean).forEach(part => {
              const parsed = parseUnitString(part);
              const normalized = normalizeUnitStatus(parsed.status);
              const statusKey = normalized.key || '';
              const normalizedLabel = typeof normalized.label === 'string' ? normalized.label.trim() : '';
              const statusLabel = normalizedLabel || (typeof normalized.raw === 'string' ? normalized.raw.trim() : '');
              const baseName = parsed.name ? parsed.name.trim() : '';
              const displayText = baseName
                ? baseName
                : (statusLabel || (parsed.raw ? parsed.raw.trim() : ''));
              if (!displayText) return;
              let tooltip = '';
              if (statusLabel) {
                tooltip = statusLabel;
              }
              if (normalized.raw && normalized.raw !== statusLabel && (!tooltip || tooltip.toLowerCase() !== normalized.raw.toLowerCase())) {
                tooltip = tooltip ? `${tooltip}  ${normalized.raw}` : normalized.raw;
              }
              units.push({
                displayText,
                statusKey,
                statusLabel,
                colorInfo: normalized.info || null,
                tooltip,
                rawStatus: normalized.raw,
                name: baseName
              });
            });
          }
        }
        return units;
      }

      function getIncidentTypeCode(incident) {
        if (!incident) return '';
        const candidates = [
          incident._markerType,
          incident.PulsePointIncidentCallTypePrimaryCode,
          incident.PulsePointIncidentCallTypeCode,
          incident.PulsePointIncidentTypeCode,
          incident.CallTypeCode,
          incident.TypeCode,
          incident.CallType,
          incident.Type,
          incident.IncidentType
        ];
        for (const value of candidates) {
          if (value === undefined || value === null) continue;
          const raw = String(value).trim();
          if (!raw) continue;
          const normalized = raw.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
          if (normalized) return normalized;
        }
        return '';
      }

      function buildPulsePointListIconUrl(typeCode) {
        if (!typeCode) return '';
        const normalized = String(typeCode).trim().toLowerCase();
        if (!normalized) return '';
        return `${INCIDENT_LIST_ICON_BASE_URL}${normalized}_list.png`;
      }

      function getIncidentTypeLabel(incident) {
        const code = getIncidentTypeCode(incident);
        if (code && Object.prototype.hasOwnProperty.call(INCIDENT_TYPE_LABELS, code)) {
          return INCIDENT_TYPE_LABELS[code];
        }
        const fallbackCandidates = [
          incident?.PulsePointIncidentCallType,
          incident?.CallType,
          incident?.Type,
          incident?.IncidentType
        ];
        const fallback = fallbackCandidates.find(value => typeof value === 'string' && value.trim());
        if (fallback) return fallback.trim();
        if (code) return code;
        return 'Incident';
      }

      async function fetchPulsePointIncidents() {
        const encrypted = await fetchPulsePointEncrypted();
        const { parsed } = decryptPulsePointPayload(encrypted);
        return normalizePulsePointIncidents(parsed);
      }

      function parseIncidentCoordinate(value) {
        if (value === undefined || value === null || value === '') return null;
        const numeric = typeof value === 'number' ? value : Number.parseFloat(value);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function getNormalizedIncidentId(value) {
        if (value === undefined || value === null) return '';
        const str = typeof value === 'string' ? value : String(value);
        const trimmed = str.trim();
        return trimmed;
      }

      function getIncidentIdentifier(rec) {
        if (!rec || typeof rec !== 'object') return null;
        const candidateKeys = [
          'ID',
          'IncidentID',
          'IncidentNumber',
          'PulsePointIncidentID',
          'PulsePointIncidentCallNumber',
          'CadIncidentNumber',
          'CADIncidentNumber'
        ];
        for (const key of candidateKeys) {
          const value = rec[key];
          if (value === undefined || value === null) continue;
          const str = String(value).trim();
          if (str) return str;
        }
        const lat = parseIncidentCoordinate(rec.Latitude ?? rec.latitude ?? rec.lat);
        const lon = parseIncidentCoordinate(rec.Longitude ?? rec.longitude ?? rec.lon);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
        const received = typeof rec.CallReceivedDateTime === 'string'
          ? rec.CallReceivedDateTime
          : (typeof rec.ReceivedDateTime === 'string' ? rec.ReceivedDateTime : '');
        return `${lat.toFixed(6)}_${lon.toFixed(6)}_${received}`;
      }

      function createIncidentLeafletIcon(iconUrl, width, height) {
        const scale = Number.isFinite(INCIDENT_ICON_SCALE) && INCIDENT_ICON_SCALE > 0
          ? INCIDENT_ICON_SCALE
          : 1;
        const baseWidth = Number.isFinite(width) && width > 0 ? width : FALLBACK_INCIDENT_ICON_SIZE;
        const baseHeight = Number.isFinite(height) && height > 0 ? height : FALLBACK_INCIDENT_ICON_SIZE;
        const scaledWidth = Math.max(1, Math.round(baseWidth * scale));
        const scaledHeight = Math.max(1, Math.round(baseHeight * scale));
        const anchorX = Math.round(scaledWidth / 2);
        const anchorY = scaledHeight;
        return L.icon({
          iconUrl,
          iconSize: [scaledWidth, scaledHeight],
          iconAnchor: [anchorX, anchorY],
          className: 'incident-marker-icon'
        });
      }

      function getIncidentIconEntry(iconUrl) {
        if (!iconUrl) return null;
        let entry = incidentIconCache.get(iconUrl);
        if (!entry) {
          const fallback = FALLBACK_INCIDENT_ICON_SIZE;
          entry = {
            icon: createIncidentLeafletIcon(iconUrl, fallback, fallback),
            markers: new Set(),
            loaded: false
          };
          incidentIconCache.set(iconUrl, entry);
          const img = new Image();
          img.decoding = 'async';
          img.addEventListener('load', () => {
            const width = img.naturalWidth || fallback;
            const height = img.naturalHeight || fallback;
            entry.icon = createIncidentLeafletIcon(iconUrl, width, height);
            entry.loaded = true;
            entry.markers.forEach(marker => {
              if (marker && typeof marker.setIcon === 'function') {
                marker.setIcon(entry.icon);
              }
            });
            applyIncidentHaloStates();
          });
          img.addEventListener('error', () => {
            entry.loaded = true;
          });
          img.src = iconUrl;
        }
        return entry;
      }

      function assignIncidentIcon(marker, iconUrl) {
        if (!marker || !iconUrl) return;
        const entry = getIncidentIconEntry(iconUrl);
        if (!entry) return;
        entry.markers.add(marker);
        marker.setIcon(entry.icon);
      }

      function releaseIncidentIcon(marker, iconUrl) {
        if (!marker || !iconUrl) return;
        const entry = incidentIconCache.get(iconUrl);
        if (entry && entry.markers) {
          entry.markers.delete(marker);
        }
      }

      function getIncidentMarkerIconSize(marker) {
        if (!marker) return null;
        const icon = marker.options && marker.options.icon ? marker.options.icon : null;
        if (!icon || !icon.options) return null;
        const size = icon.options.iconSize;
        if (Array.isArray(size) && size.length >= 2) {
          const width = Number(size[0]);
          const height = Number(size[1]);
          if (Number.isFinite(width) && Number.isFinite(height)) {
            return { width, height };
          }
        }
        return null;
      }

      function getIncidentHaloIcon(markerHeight) {
        const diameter = HALO_MAX_RADIUS_PX * 2;
        const safeHeight = Number.isFinite(markerHeight) && markerHeight > 0
          ? markerHeight
          : DEFAULT_SCALED_INCIDENT_ICON_HEIGHT;
        const key = safeHeight.toFixed(2);
        let icon = incidentHaloIconCache.get(key);
        if (!icon) {
          const offsetX = Number.isFinite(MARKER_CENTROID_OFFSET_X_FACTOR)
            ? MARKER_CENTROID_OFFSET_X_FACTOR * safeHeight
            : 0;
          const offsetY = Number.isFinite(MARKER_CENTROID_OFFSET_Y_FACTOR)
            ? MARKER_CENTROID_OFFSET_Y_FACTOR * safeHeight
            : 0;
          const anchorX = diameter / 2 - offsetX;
          const anchorY = diameter / 2 - offsetY;
          const minScale = HALO_MAX_RADIUS_PX > 0
            ? Math.max(0, Math.min(1, HALO_MIN_RADIUS_PX / HALO_MAX_RADIUS_PX))
            : 0.25;
          const html = `<div class="incident-halo" style="--incident-halo-diameter:${diameter}px;--incident-halo-base-opacity:${HALO_BASE_OPACITY};--incident-halo-duration:${HALO_DURATION_MS}ms;--incident-halo-start-scale:${minScale};--incident-halo-color-rgb:${HALO_COLOR_RGB};"></div>`;
          icon = L.divIcon({
            className: 'incident-halo-icon',
            iconSize: [diameter, diameter],
            iconAnchor: [anchorX, anchorY],
            html
          });
          incidentHaloIconCache.set(key, icon);
        }
        return icon;
      }

      function createIncidentHaloMarker(latLng, markerHeight) {
        const haloIcon = getIncidentHaloIcon(markerHeight);
        return L.marker(latLng, {
          icon: haloIcon,
          pane: 'incidentHalosPane',
          interactive: false,
          keyboard: false,
          bubblingMouseEvents: false
        });
      }

      function ensureIncidentHaloLayerGroup() {
        if (!map) return null;
        if (!incidentHaloLayerGroup) {
          incidentHaloLayerGroup = L.layerGroup();
        }
        const shouldShowHalos = shouldShowIncidentLayer() && hasIncidentsRequiringVisibility();
        if (shouldShowHalos) {
          if (!map.hasLayer(incidentHaloLayerGroup)) {
            incidentHaloLayerGroup.addTo(map);
          }
        } else if (map.hasLayer(incidentHaloLayerGroup)) {
          map.removeLayer(incidentHaloLayerGroup);
        }
        return incidentHaloLayerGroup;
      }

      function isReducedMotionPreferred() {
        return !!(reduceMotionMediaQuery && typeof reduceMotionMediaQuery.matches === 'boolean' && reduceMotionMediaQuery.matches);
      }

      function applyHaloAnimationState(entry, animated) {
        if (!entry || !entry.haloMarker) return;
        const haloMarker = entry.haloMarker;
        const update = () => {
          const element = haloMarker.getElement();
          if (!element) return;
          const haloElement = element.querySelector('.incident-halo');
          if (!haloElement) return;
          if (animated) {
            haloElement.classList.add('incident-halo--animated');
            haloElement.classList.remove('incident-halo--static');
          } else {
            haloElement.classList.add('incident-halo--static');
            haloElement.classList.remove('incident-halo--animated');
          }
        };
        update();
        setTimeout(update, 0);
      }

      function removeIncidentHalo(entry) {
        if (!entry || !entry.haloMarker) return;
        const haloMarker = entry.haloMarker;
        if (incidentHaloLayerGroup && incidentHaloLayerGroup.hasLayer(haloMarker)) {
          incidentHaloLayerGroup.removeLayer(haloMarker);
        } else if (haloMarker && typeof haloMarker.remove === 'function' && haloMarker._map) {
          haloMarker.remove();
        }
        entry.haloMarker = null;
        entry.haloAnimated = false;
      }

      function syncIncidentHaloForEntry(id, entry) {
        if (!entry || !entry.marker) return;
        if (!incidentsNearRoutesLookup.has(id)) {
          removeIncidentHalo(entry);
          return;
        }
        const haloGroup = ensureIncidentHaloLayerGroup();
        if (!haloGroup) return;
        const latLng = entry.marker.getLatLng();
        if (!latLng) return;
        const size = getIncidentMarkerIconSize(entry.marker);
        const markerHeight = size && Number.isFinite(size.height) ? size.height : DEFAULT_SCALED_INCIDENT_ICON_HEIGHT;
        const desiredIcon = getIncidentHaloIcon(markerHeight);
        if (entry.haloMarker) {
          entry.haloMarker.setLatLng(latLng);
          if (entry.haloMarker.options && entry.haloMarker.options.icon !== desiredIcon) {
            entry.haloMarker.setIcon(desiredIcon);
          }
          if (!haloGroup.hasLayer(entry.haloMarker)) {
            haloGroup.addLayer(entry.haloMarker);
          }
        } else {
          const haloMarker = createIncidentHaloMarker(latLng, markerHeight);
          entry.haloMarker = haloMarker;
          haloGroup.addLayer(haloMarker);
        }
      }

      function applyIncidentHaloStates() {
        if (!map) return;
        const haloGroup = ensureIncidentHaloLayerGroup();
        if (!haloGroup) return;
        const nearRouteList = Array.isArray(incidentsNearRoutes) ? incidentsNearRoutes : [];
        const orderedIds = [];
        nearRouteList.forEach(entry => {
          if (!entry) return;
          const candidateId = typeof entry.id === 'string' ? entry.id : getNormalizedIncidentId(entry.id);
          if (candidateId && !orderedIds.includes(candidateId)) {
            orderedIds.push(candidateId);
          }
        });
        const reduceMotion = isReducedMotionPreferred();
        const animatedIds = reduceMotion
          ? new Set()
          : new Set(orderedIds.slice(0, Math.max(0, INCIDENT_HALO_ANIMATED_LIMIT)));
        incidentMarkers.forEach((entry, id) => {
          if (!incidentsNearRoutesLookup.has(id)) {
            removeIncidentHalo(entry);
            return;
          }
          syncIncidentHaloForEntry(id, entry);
          const animate = animatedIds.has(id) && !reduceMotion;
          entry.haloAnimated = animate;
          applyHaloAnimationState(entry, animate);
        });
      }

      if (reduceMotionMediaQuery) {
        const handleReduceMotionChange = () => {
          applyIncidentHaloStates();
        };
        if (typeof reduceMotionMediaQuery.addEventListener === 'function') {
          reduceMotionMediaQuery.addEventListener('change', handleReduceMotionChange);
        } else if (typeof reduceMotionMediaQuery.addListener === 'function') {
          reduceMotionMediaQuery.addListener(handleReduceMotionChange);
        }
      }

      function updateIncidentMarkerTooltip(marker, incident) {
        if (!marker || !incident) return;
        const lines = [];
        const callType = incident.PulsePointIncidentCallType || incident.CallType || incident.Type || '';
        const address = incident.FullDisplayAddress || incident.DisplayAddress || incident.Address || '';
        if (callType) lines.push(callType);
        if (address) {
          if (!lines.length || address.trim().toLowerCase() !== lines[0].trim().toLowerCase()) {
            lines.push(address);
          }
        }
        if (!lines.length) {
          if (typeof marker.unbindTooltip === 'function') {
            marker.unbindTooltip();
          }
          return;
        }
        const tooltipText = lines.join('\n');
        if (typeof marker.getTooltip === 'function') {
          const tooltip = marker.getTooltip();
          if (tooltip && typeof tooltip.setContent === 'function') {
            tooltip.setContent(tooltipText);
            return;
          }
        }
        if (typeof marker.bindTooltip === 'function') {
          marker.bindTooltip(tooltipText, { direction: 'top', offset: [0, -4], sticky: true });
        }
      }

      function updateIncidentsNearRoutes(matches, signature = '') {
        const list = Array.isArray(matches) ? matches.slice() : [];
        incidentsNearRoutes = list;
        const lookup = new Map();
        list.forEach(entry => {
          if (!entry) return;
          const candidateId = typeof entry.id === 'string' ? entry.id : getNormalizedIncidentId(entry.id);
          if (candidateId) {
            lookup.set(candidateId, entry);
          }
        });
        incidentsNearRoutesLookup = lookup;
        incidentRouteAlertSignature = typeof signature === 'string' ? signature : '';
        applyIncidentHaloStates();
        refreshOpenIncidentPopups();
        maintainIncidentLayers();
      }

      function applyIncidentMarkers(incidents) {
        if (!map) return;
        if (!incidentLayerGroup) {
          incidentLayerGroup = L.layerGroup();
        }
        const layerGroup = incidentLayerGroup;
        const shouldShowLayer = shouldShowIncidentLayer();
        if (shouldShowLayer) {
          if (!map.hasLayer(layerGroup)) {
            layerGroup.addTo(map);
          }
        } else if (map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
        const activeIds = new Set();
        (Array.isArray(incidents) ? incidents : []).forEach(incident => {
          if (!incident) return;
          const lat = parseIncidentCoordinate(incident.Latitude ?? incident.latitude ?? incident.lat);
          const lon = parseIncidentCoordinate(incident.Longitude ?? incident.longitude ?? incident.lon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
          const fallbackId = getNormalizedIncidentId(`${lat.toFixed(6)}_${lon.toFixed(6)}`);
          let id = getNormalizedIncidentId(getIncidentIdentifier(incident));
          if (!id) {
            id = fallbackId;
          }
          if (!id) return;
          const markerUrl = incident._markerUrl;
          if (!markerUrl) return;
          const isPinned = incidentsNearRoutesLookup.has(id);
          if (!incidentsVisible) {
            if (!shouldShowLayer || !isPinned) {
              return;
            }
          }
          activeIds.add(id);
          const existing = incidentMarkers.get(id);
          if (existing && existing.marker) {
            existing.marker.setLatLng([lat, lon]);
            if (existing.iconUrl !== markerUrl) {
              releaseIncidentIcon(existing.marker, existing.iconUrl);
              assignIncidentIcon(existing.marker, markerUrl);
              existing.iconUrl = markerUrl;
            }
            updateIncidentMarkerTooltip(existing.marker, incident);
            existing.data = incident;
            refreshIncidentPopup(id);
          } else {
            const marker = L.marker([lat, lon], {
              pane: 'incidentsPane',
              keyboard: false,
              zIndexOffset: 200
            });
            assignIncidentIcon(marker, markerUrl);
            updateIncidentMarkerTooltip(marker, incident);
            marker.addTo(layerGroup);
            incidentMarkers.set(id, {
              marker,
              data: incident,
              iconUrl: markerUrl,
              haloMarker: null,
              haloAnimated: false
            });
            marker.on('click', () => {
              const config = buildIncidentPopupConfig(id);
              if (config) {
                createCustomPopup(config);
              }
            });
            refreshIncidentPopup(id);
          }
        });
        const idsToRemove = [];
        incidentMarkers.forEach((entry, id) => {
          if (!activeIds.has(id)) {
            idsToRemove.push(id);
          }
        });
        idsToRemove.forEach(id => {
          const entry = incidentMarkers.get(id);
          if (!entry) return;
          releaseIncidentIcon(entry.marker, entry.iconUrl);
          if (incidentLayerGroup && entry.marker) {
            incidentLayerGroup.removeLayer(entry.marker);
          } else if (map && entry.marker && map.hasLayer(entry.marker)) {
            map.removeLayer(entry.marker);
          }
          removeIncidentHalo(entry);
          removeIncidentPopupById(id);
          incidentMarkers.delete(id);
        });
        applyIncidentHaloStates();
        maintainIncidentLayers();
      }

      function ensureRouteProjectedPath(entry) {
        if (!entry) return null;
        const latLngPath = Array.isArray(entry.latLngPath) ? entry.latLngPath : null;
        if (!latLngPath || latLngPath.length < 2) return null;
        const existing = Array.isArray(entry.projectedPath) ? entry.projectedPath : null;
        if (existing && existing.length === latLngPath.length && existing.length >= 2) {
          return existing;
        }
        if (typeof L === 'undefined' || !L.Projection || !L.Projection.SphericalMercator) return null;
        entry.projectedPath = latLngPath.map(point => L.Projection.SphericalMercator.project(point));
        return entry.projectedPath;
      }

      function computeDistanceFromProjectedPointToSegmentMeters(point, a, b) {
        if (!point || !a || !b) return Infinity;
        const ax = a.x;
        const ay = a.y;
        const bx = b.x;
        const by = b.y;
        if (!Number.isFinite(ax) || !Number.isFinite(ay) || !Number.isFinite(bx) || !Number.isFinite(by)) {
          return Infinity;
        }
        const dx = bx - ax;
        const dy = by - ay;
        if (dx === 0 && dy === 0) {
          const diffX = point.x - ax;
          const diffY = point.y - ay;
          return Math.sqrt(diffX * diffX + diffY * diffY);
        }
        const t = ((point.x - ax) * dx + (point.y - ay) * dy) / (dx * dx + dy * dy);
        const clamped = Math.max(0, Math.min(1, t));
        const projX = ax + clamped * dx;
        const projY = ay + clamped * dy;
        const diffX = point.x - projX;
        const diffY = point.y - projY;
        return Math.sqrt(diffX * diffX + diffY * diffY);
      }

      function computeDistanceFromProjectedPointToPathMeters(point, projectedPath) {
        if (!point || !Array.isArray(projectedPath) || projectedPath.length < 2) {
          return Infinity;
        }
        let minDistance = Infinity;
        for (let i = 0; i < projectedPath.length - 1; i += 1) {
          const segmentStart = projectedPath[i];
          const segmentEnd = projectedPath[i + 1];
          const distance = computeDistanceFromProjectedPointToSegmentMeters(point, segmentStart, segmentEnd);
          if (!Number.isFinite(distance)) continue;
          if (distance < minDistance) {
            minDistance = distance;
          }
        }
        return minDistance;
      }

      function getRouteDisplayName(routeId) {
        const numericRouteId = Number(routeId);
        const candidates = [];
        if (Number.isFinite(numericRouteId) && allRoutes && allRoutes[numericRouteId]) {
          candidates.push(allRoutes[numericRouteId]);
        }
        if (allRoutes && Object.prototype.hasOwnProperty.call(allRoutes, routeId)) {
          candidates.push(allRoutes[routeId]);
        }
        const record = candidates.find(Boolean) || null;
        if (record) {
          const nameCandidates = [
            record.Description,
            record.RouteName,
            record.Name,
            record.LongName,
            record.ShortName
          ];
          const name = nameCandidates.find(value => typeof value === 'string' && value.trim());
          if (name) return name.trim();
        }
        if (Number.isFinite(numericRouteId)) {
          return `Route ${numericRouteId}`;
        }
        if (typeof routeId === 'string' && routeId.trim()) {
          return routeId.trim();
        }
        return 'Route';
      }

      function evaluateIncidentRouteAlerts() {
        if (demoIncidentActive && demoIncidentEntry) {
          return;
        }
        const hadAlerts = incidentRouteAlertSignature !== '' || (Array.isArray(incidentsNearRoutes) && incidentsNearRoutes.length > 0);
        if (!incidentsAreAvailable()) {
          if (hadAlerts) {
            resetIncidentAlertState();
            updateControlPanel();
          } else {
            resetIncidentAlertState();
          }
          return;
        }
        if (typeof L === 'undefined' || !L.Projection || !L.Projection.SphericalMercator) {
          return;
        }
        const activeRecords = Array.isArray(latestActiveIncidents) ? latestActiveIncidents : [];
        if (activeRecords.length === 0) {
          if (hadAlerts) {
            resetIncidentAlertState();
            updateControlPanel();
          } else {
            resetIncidentAlertState();
          }
          return;
        }
        const routeEntries = [];
        routePolylineCache.forEach((entry, key) => {
          const numericRouteId = Number(key);
          if (!Number.isFinite(numericRouteId) || numericRouteId === 0) return;
          const projectedPath = ensureRouteProjectedPath(entry);
          if (!projectedPath || projectedPath.length < 2) return;
          routeEntries.push({ routeId: numericRouteId, projectedPath });
        });
        if (routeEntries.length === 0) {
          if (hadAlerts) {
            resetIncidentAlertState();
            updateControlPanel();
          }
          return;
        }
        const projection = L.Projection.SphericalMercator;
        const threshold = Number.isFinite(INCIDENT_ROUTE_PROXIMITY_THRESHOLD_METERS) && INCIDENT_ROUTE_PROXIMITY_THRESHOLD_METERS >= 0
          ? INCIDENT_ROUTE_PROXIMITY_THRESHOLD_METERS
          : 0;
        const matches = [];
        activeRecords.forEach(incident => {
          const lat = parseIncidentCoordinate(incident?.Latitude ?? incident?.latitude ?? incident?.lat);
          const lon = parseIncidentCoordinate(incident?.Longitude ?? incident?.longitude ?? incident?.lon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
          const incidentLatLng = L.latLng(lat, lon);
          const projectedPoint = projection.project(incidentLatLng);
          if (!projectedPoint) return;
          const matchedRoutes = [];
          const seenRoutes = new Set();
          let closestDistance = Infinity;
          routeEntries.forEach(({ routeId, projectedPath }) => {
            const distance = computeDistanceFromProjectedPointToPathMeters(projectedPoint, projectedPath);
            if (!Number.isFinite(distance)) return;
            if (distance < closestDistance) {
              closestDistance = distance;
            }
            if (distance <= threshold && !seenRoutes.has(routeId)) {
              seenRoutes.add(routeId);
              const colorCandidates = [];
              if (routeColors && typeof routeColors[routeId] === 'string') {
                colorCandidates.push(routeColors[routeId]);
              }
              const storedRoute = allRoutes ? (allRoutes[routeId] || allRoutes[`${routeId}`] || null) : null;
              if (storedRoute) {
                const storedColorCandidates = [storedRoute.MapLineColor, storedRoute.RouteColor, storedRoute.Color, storedRoute.color];
                storedColorCandidates.forEach(value => {
                  if (typeof value === 'string') {
                    colorCandidates.push(value);
                  }
                });
              }
              let matchedColor = '';
              for (const candidate of colorCandidates) {
                const sanitized = sanitizeCssColor(candidate);
                if (sanitized) {
                  matchedColor = sanitized;
                  break;
                }
              }
              matchedRoutes.push({ routeId, name: getRouteDisplayName(routeId), distance, color: matchedColor });
            }
          });
          if (!matchedRoutes.length) return;
          matchedRoutes.sort((a, b) => (a.distance || 0) - (b.distance || 0));
          let id = getIncidentIdentifier(incident);
          if (!id) {
            id = `${lat.toFixed(6)}_${lon.toFixed(6)}`;
          }
          id = getNormalizedIncidentId(id);
          if (!id) return;
          const timestamp = getIncidentTimestamp(incident) ?? 0;
          matches.push({
            id,
            incident,
            routes: matchedRoutes,
            closestDistance,
            timestamp
          });
        });
        if (!matches.length) {
          if (hadAlerts) {
            resetIncidentAlertState();
            updateControlPanel();
          }
          return;
        }
        matches.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        const signature = matches.map(match => {
          const routePart = match.routes.map(route => route.routeId).join(',');
          const distancePart = Number.isFinite(match.closestDistance) ? Math.round(match.closestDistance) : 'x';
          return `${match.id || ''}:${routePart}:${distancePart}`;
        }).join('|');
        if (signature !== incidentRouteAlertSignature) {
          updateIncidentsNearRoutes(matches, signature);
          updateControlPanel();
        }
      }

      async function refreshIncidents() {
        if (!incidentsAreAvailable()) {
          setIncidentsVisibility(false);
          return;
        }
        if (demoIncidentActive && demoIncidentEntry) {
          return;
        }
        if (!map || isFetchingIncidents) return;
        isFetchingIncidents = true;
        try {
          const records = await fetchPulsePointIncidents();
          const activeRecords = Array.isArray(records)
            ? records.filter(record => (record._category || '').toLowerCase() === 'active')
            : [];
          latestActiveIncidents = activeRecords;
          evaluateIncidentRouteAlerts();
          applyIncidentMarkers(activeRecords);
        } catch (error) {
          console.error('Failed to refresh PulsePoint incidents', error);
        } finally {
          isFetchingIncidents = false;
        }
      }

      function setIncidentsVisibility(visible) {
        const allowIncidents = incidentsAreAvailable();
        const hadAlerts = incidentRouteAlertSignature !== '' || (Array.isArray(incidentsNearRoutes) && incidentsNearRoutes.length > 0);
        incidentsVisible = allowIncidents && !!visible;

        if (!incidentsVisible && demoIncidentActive) {
          deactivateDemoIncidentPreview({ preserveVisibility: true });
        }

        if (!allowIncidents) {
          if (hadAlerts || (Array.isArray(latestActiveIncidents) && latestActiveIncidents.length > 0)) {
            resetIncidentAlertState();
            updateControlPanel();
          } else {
            resetIncidentAlertState();
          }
          removeAllIncidentPopups();
          maintainIncidentLayers();
          updateIncidentToggleButton();
          return;
        }

        incidentsVisibilityPreference = incidentsVisible;

        applyIncidentMarkers(latestActiveIncidents);
        if (incidentsVisible && incidentMarkers.size === 0 && !isFetchingIncidents) {
          refreshIncidents();
        } else {
          maintainIncidentLayers();
        }
        updateIncidentToggleButton();
        applyIncidentHaloStates();
        if (!incidentsVisible) {
          removeAllIncidentPopups();
        }
      }

      async function activateDemoIncidentPreview() {
        if (demoIncidentActive) return;
        const row = await ensureDemoIncidentRow();
        if (!row) {
          if (typeof window !== 'undefined' && typeof window.alert === 'function') {
            window.alert('Demo incident data is unavailable.');
          }
          return;
        }
        const entry = createDemoIncidentEntry();
        if (!entry || !entry.incident) {
          console.warn('Demo incident data is missing required fields.', entry);
          if (typeof window !== 'undefined' && typeof window.alert === 'function') {
            window.alert('Demo incident data is missing required fields.');
          }
          return;
        }
        demoIncidentEntry = entry;
        demoIncidentPreviousVisibility = incidentsVisible;
        demoIncidentActive = true;
        updateIncidentsNearRoutes([entry], entry._demoSignature || entry.id || 'demo');
        incidentsVisible = true;
        incidentsVisibilityPreference = true;
        if (!incidentLayerGroup && typeof L !== 'undefined' && typeof L.layerGroup === 'function') {
          incidentLayerGroup = L.layerGroup();
        }
        if (map && incidentLayerGroup && typeof incidentLayerGroup.addTo === 'function') {
          incidentLayerGroup.addTo(map);
        }
        if (entry.incident) {
          applyIncidentMarkers([entry.incident]);
        }
        if (entry.incident && Number.isFinite(entry.incident.Latitude) && Number.isFinite(entry.incident.Longitude) && map && typeof map.setView === 'function') {
          try {
            const currentZoom = typeof map.getZoom === 'function' ? map.getZoom() : 0;
            const targetZoom = Number.isFinite(currentZoom) ? Math.max(currentZoom, 15) : 15;
            map.setView([entry.incident.Latitude, entry.incident.Longitude], targetZoom, { animate: true });
          } catch (error) {
            console.warn('Unable to move map to the demo incident location.', error);
          }
        }
        updateControlPanel();
        updateIncidentToggleButton();
      }

      function deactivateDemoIncidentPreview(options = {}) {
        if (!demoIncidentActive) {
          demoIncidentPreviousVisibility = null;
          return;
        }
        const preserveVisibility = options && options.preserveVisibility;
        demoIncidentActive = false;
        demoIncidentEntry = null;
        resetIncidentAlertState();
        applyIncidentMarkers([]);
        if (!preserveVisibility) {
          if (demoIncidentPreviousVisibility !== null) {
            incidentsVisible = !!demoIncidentPreviousVisibility;
            incidentsVisibilityPreference = incidentsVisible;
            if (map && incidentLayerGroup) {
              if (incidentsVisible) {
                incidentLayerGroup.addTo(map);
              } else {
                map.removeLayer(incidentLayerGroup);
              }
            }
          }
        }
        demoIncidentPreviousVisibility = null;
        updateControlPanel();
        updateIncidentToggleButton();
      }

      async function toggleDemoIncident() {
        if (demoIncidentActive) {
          deactivateDemoIncidentPreview();
        } else {
          await activateDemoIncidentPreview();
        }
      }

      function enforceIncidentVisibilityForCurrentAgency() {
        if (incidentsAreAvailable()) {
          setIncidentsVisibility(incidentsVisibilityPreference);
        } else {
          setIncidentsVisibility(false);
        }
      }

      function toggleIncidentsVisibility() {
        if (!incidentsAreAvailable()) return;
        setIncidentsVisibility(!incidentsVisible);
      }

      const BUS_MARKER_SVG_URL = 'busmarker.svg';

      const BUS_MARKER_VIEWBOX_WIDTH = 52.99;
      const BUS_MARKER_VIEWBOX_HEIGHT = 86.99;
      const BUS_MARKER_PIVOT_X = BUS_MARKER_VIEWBOX_WIDTH / 2;
      const BUS_MARKER_PIVOT_Y = BUS_MARKER_VIEWBOX_HEIGHT / 2;
      const BUS_MARKER_ASPECT_RATIO = BUS_MARKER_VIEWBOX_HEIGHT / BUS_MARKER_VIEWBOX_WIDTH;
      const BUS_MARKER_BASE_WIDTH_PX = 26;
      const BUS_MARKER_MIN_WIDTH_PX = 18;
      const BUS_MARKER_MAX_WIDTH_PX = 48;
      const BUS_MARKER_BASE_ZOOM = 15;
      const BUS_MARKER_MIN_SCALE = BUS_MARKER_MIN_WIDTH_PX / BUS_MARKER_BASE_WIDTH_PX;
      const BUS_MARKER_MAX_SCALE = BUS_MARKER_MAX_WIDTH_PX / BUS_MARKER_BASE_WIDTH_PX;
      const BUS_MARKER_SCALE_ZOOM_FACTOR = 5;
      const BUS_MARKER_ICON_ANCHOR_X_RATIO = BUS_MARKER_PIVOT_X / BUS_MARKER_VIEWBOX_WIDTH;
      const BUS_MARKER_ICON_ANCHOR_Y_RATIO = BUS_MARKER_PIVOT_Y / BUS_MARKER_VIEWBOX_HEIGHT;
      const BUS_MARKER_TRANSFORM_ORIGIN = '50% 50%';
      const BUS_MARKER_DEFAULT_HEADING = 0;
      const BUS_MARKER_DEFAULT_ROUTE_COLOR = '#0B7A26';
      const BUS_MARKER_DEFAULT_CONTRAST_COLOR = '#FFFFFF';
      const BUS_MARKER_CENTER_RING_CENTER_X = 26.5;
      const BUS_MARKER_CENTER_RING_CENTER_Y = 43.49;
      const BUS_MARKER_STOPPED_SQUARE_SIZE_PX = 20;
      const BUS_MARKER_STOPPED_SQUARE_ID = 'center_square';
      const BUS_MARKER_CENTER_RING_ID = 'center_ring';
      let BUS_MARKER_SVG_TEXT = null;
      let BUS_MARKER_SVG_LOAD_PROMISE = null;
      let busMarkerVisibleExtents = null;
      const BUS_MARKER_LABEL_FONT_FAMILY = 'FGDC, sans-serif';
      const BUS_MARKER_LABEL_MIN_FONT_PX = 10;
      const SPEED_BUBBLE_BASE_FONT_PX = 12;
      const SPEED_BUBBLE_HORIZONTAL_PADDING = 12;
      const SPEED_BUBBLE_VERTICAL_PADDING = 4;
      const SPEED_BUBBLE_MIN_WIDTH = 60;
      const SPEED_BUBBLE_MIN_HEIGHT = 20;
      const SPEED_BUBBLE_CORNER_RADIUS = 10;
      const LABEL_VERTICAL_CLEARANCE_PX = -7; // pull labels ~7px closer to the vehicle while relying on the half-diagonal for rotation safety
      const LABEL_VERTICAL_ALIGNMENT_BONUS_PX = 6; // push labels a little farther away when the vehicle is nearly north/south
      const LABEL_VERTICAL_ALIGNMENT_EXPONENT = 4; // emphasize the bonus for headings close to due north/south
      const LABEL_HORIZONTAL_ALIGNMENT_BONUS_PX = 1; // give east/west headings extra breathing room
      const LABEL_TEXT_VERTICAL_ADJUSTMENT_RATIO = 0.06;
      const NAME_BUBBLE_BASE_FONT_PX = 14;
      const NAME_BUBBLE_HORIZONTAL_PADDING = 14;
      const NAME_BUBBLE_VERTICAL_PADDING = 3;
      const NAME_BUBBLE_MIN_WIDTH = 40;
      const NAME_BUBBLE_MIN_HEIGHT = 20;
      const NAME_BUBBLE_CORNER_RADIUS = 10;
      const NAME_BUBBLE_FRAME_INSET = 5;
      const BLOCK_BUBBLE_BASE_FONT_PX = 14;
      const BLOCK_BUBBLE_HORIZONTAL_PADDING = 14;
      const BLOCK_BUBBLE_VERTICAL_PADDING = 3;
      const BLOCK_BUBBLE_MIN_WIDTH = 40;
      const BLOCK_BUBBLE_MIN_HEIGHT = 20;
      const BLOCK_BUBBLE_CORNER_RADIUS = 10;
      const BLOCK_BUBBLE_FRAME_INSET = 5;
      const LABEL_BASE_STROKE_WIDTH = 3;
      const MIN_HEADING_DISTANCE_METERS = 2;
      const MIN_POSITION_UPDATE_METERS = 0.5;
      const MIN_HEADING_SPEED_METERS_PER_SECOND = 1;
      const METERS_PER_SECOND_PER_MPH = 0.44704;
      const GPS_STALE_THRESHOLD_SECONDS = 60;
      let busMarkerContrastOverrideColor = null;

      let routeColors = {};
      let routeLayers = [];
      let stopMarkers = [];
      let stopDataCache = [];
      let routeStopAddressMap = {};
      let routeStopRouteMap = {};
      let nameBubbles = {};
      let busBlocks = {};
      let previousBusData = {};
      let cachedEtas = {};
      let customPopups = [];
      let allRouteBounds = null;
      let mapHasFitAllRoutes = false;
      let refreshIntervals = [];

      let overlapRenderer = null;

      let currentTranslocRendererGeometries = new Map();
      let currentTranslocSelectedRouteIds = [];

      let activeAgencyLoadCount = 0;

      function showLoadingOverlay() {
        const overlay = document.getElementById('loadingOverlay');
        if (!overlay) return;
        overlay.classList.add('is-visible');
        overlay.setAttribute('aria-busy', 'true');
      }

      function hideLoadingOverlay() {
        const overlay = document.getElementById('loadingOverlay');
        if (!overlay) return;
        overlay.classList.remove('is-visible');
        overlay.setAttribute('aria-busy', 'false');
      }

      function beginAgencyLoad() {
        activeAgencyLoadCount += 1;
        showLoadingOverlay();
      }

      function completeAgencyLoad() {
        activeAgencyLoadCount = Math.max(0, activeAgencyLoadCount - 1);
        if (activeAgencyLoadCount === 0) {
          hideLoadingOverlay();
        }
      }

      const STOP_GROUPING_PIXEL_DISTANCE = 20;
      const STOP_MARKER_ICON_SIZE = 24;
      const STOP_MARKER_BORDER_COLOR = 'rgba(15,23,42,0.55)';
      const STOP_MARKER_OUTLINE_COLOR = '#FFFFFF';
      const STOP_MARKER_OUTLINE_WIDTH = 2;

      let routePolylineCache = new Map();
      let lastRouteRenderState = {
        selectionKey: '',
        colorSignature: '',
        geometrySignature: '',
        useOverlapRenderer: false
      };
      let lastRouteSelectorSignature = null;

      const DEFAULT_ROUTE_STROKE_WEIGHT = 6;
      const MIN_ROUTE_STROKE_WEIGHT = 3;
      const MAX_ROUTE_STROKE_WEIGHT = 12;
      const ROUTE_WEIGHT_ZOOM_DELTA_LIMIT = 3;
      const ROUTE_WEIGHT_BASE_ZOOM = 15;
      const ROUTE_WEIGHT_STEP_PER_ZOOM = 1;

      function computeRouteStrokeWeight(zoom) {
        const baseWeight = DEFAULT_ROUTE_STROKE_WEIGHT;
        const minWeight = MIN_ROUTE_STROKE_WEIGHT;
        const maxWeight = MAX_ROUTE_STROKE_WEIGHT;
        const targetZoom = Number.isFinite(zoom)
          ? zoom
          : (map && typeof map?.getZoom === 'function' ? map.getZoom() : null);
        if (!Number.isFinite(targetZoom)) {
          return Math.max(minWeight, Math.min(maxWeight, baseWeight));
        }
        const zoomDeltaRaw = targetZoom - ROUTE_WEIGHT_BASE_ZOOM;
        const limitedDelta = Math.max(-ROUTE_WEIGHT_ZOOM_DELTA_LIMIT, Math.min(ROUTE_WEIGHT_ZOOM_DELTA_LIMIT, zoomDeltaRaw));
        const computed = baseWeight + ROUTE_WEIGHT_STEP_PER_ZOOM * limitedDelta;
        if (!Number.isFinite(computed)) {
          return Math.max(minWeight, Math.min(maxWeight, baseWeight));
        }
        return Math.max(minWeight, Math.min(maxWeight, computed));
      }

      async function loadAgencies() {
        try {
          const response = await fetch('https://admin.ridesystems.net/api/Clients/GetClients');
          const contentType = response.headers.get('content-type') || '';
          let clients = [];
          if (contentType.includes('application/json')) {
            clients = await response.json();
          } else {
            const text = await response.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'application/xml');
            clients = Array.from(xml.getElementsByTagName('Client')).map(c => ({
              Name: c.getElementsByTagName('Name')[0]?.textContent.trim(),
              WebAddress: c.getElementsByTagName('WebAddress')[0]?.textContent.trim()
            }));
          }
          agencies = clients.map(c => {
            const name = c.Name?.trim();
            const webAddress = c.WebAddress?.trim();
            if (!name || !webAddress) return null;
            const url = webAddress.startsWith('http')
              ? webAddress.replace(/^http:\/\//i, 'https://')
              : `https://${webAddress}`;
            return { name, url };
          }).filter(Boolean);
          agencies.sort((a, b) => a.name.localeCompare(b.name));
          const uvaIndex = agencies.findIndex(a => a.name === 'University of Virginia');
          if (uvaIndex > -1) {
            const uva = agencies.splice(uvaIndex, 1)[0];
            agencies.unshift(uva);
          }
          const consent = localStorage.getItem('agencyConsent') === 'true';
          const storedAgency = consent ? localStorage.getItem('selectedAgency') : null;
          if (storedAgency && agencies.some(a => a.url === storedAgency)) {
            baseURL = storedAgency;
          } else {
            baseURL = agencies[0]?.url || '';
          }
          resetServiceAlertsState();
          updateControlPanel();
          enforceIncidentVisibilityForCurrentAgency();
          updateRouteSelector(activeRoutes, true);
        } catch (e) {
          console.error('Failed to load agencies', e);
        }
      }

      function positionPanelTab(panelId, tabId, side = 'right') {
        const panel = document.getElementById(panelId);
        const tab = document.getElementById(tabId);
        if (!panel || !tab) return;

        const panelRect = panel.getBoundingClientRect();
        const tabRect = tab.getBoundingClientRect();
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
        const tabHeight = tabRect.height || tab.offsetHeight || parseFloat(window.getComputedStyle(tab).height) || 0;
        if (Number.isFinite(panelRect?.top) && Number.isFinite(panelRect?.height)) {
          const panelCenter = panelRect.top + panelRect.height / 2;
          if (Number.isFinite(panelCenter)) {
            const halfTab = Number.isFinite(tabHeight) ? tabHeight / 2 : 0;
            let targetTop = panelCenter;
            if (Number.isFinite(viewportHeight) && halfTab > 0) {
              const minTop = halfTab + 8;
              const maxTop = viewportHeight - halfTab - 8;
              if (Number.isFinite(minTop) && Number.isFinite(maxTop)) {
                targetTop = Math.min(Math.max(panelCenter, minTop), Math.max(minTop, maxTop));
              }
            }
            if (Number.isFinite(targetTop)) {
              tab.style.top = `${targetTop}px`;
            }
          }
        }

        const panelStyle = window.getComputedStyle(panel);
        const gap = side === 'right'
          ? (parseFloat(panelStyle.right) || 0)
          : (parseFloat(panelStyle.left) || 0);
        const offset = panel.offsetWidth + gap;
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
        const tabWidth = tabRect.width || tab.offsetWidth || parseFloat(window.getComputedStyle(tab).width) || 0;

        if (side === 'right') {
          if (panel.classList.contains('hidden')) {
            tab.style.right = '0';
          } else {
            const maxRight = Math.max(0, viewportWidth - tabWidth);
            const clampedOffset = Math.min(offset, maxRight);
            tab.style.right = `${clampedOffset}px`;
          }
          tab.style.left = '';
        } else {
          if (panel.classList.contains('hidden')) {
            tab.style.left = '0';
          } else {
            const maxLeft = Math.max(0, viewportWidth - tabWidth);
            const clampedOffset = Math.min(offset, maxLeft);
            tab.style.left = `${clampedOffset}px`;
          }
          tab.style.right = '';
        }
      }

      function isCompactViewport() {
        const width = window.innerWidth || document.documentElement?.clientWidth || document.body?.clientWidth || 0;
        const height = window.innerHeight || document.documentElement?.clientHeight || document.body?.clientHeight || 0;
        const dimensionCandidates = [width, height].filter(value => Number.isFinite(value) && value > 0);
        const smallestDimension = dimensionCandidates.length > 0 ? Math.min(...dimensionCandidates) : width;
        return Number.isFinite(smallestDimension) && smallestDimension <= PANEL_COLLAPSE_BREAKPOINT;
      }

      function isPanelVisibleForMobileBehavior(panel) {
        if (!panel) return false;
        if (panel.classList && panel.classList.contains('hidden')) return false;
        if (panel.style && panel.style.display === 'none') return false;
        if (typeof window.getComputedStyle === 'function') {
          const computed = window.getComputedStyle(panel);
          if (computed && computed.display === 'none') {
            return false;
          }
        }
        return true;
      }

      function updatePanelTabVisibility() {
        const controlTab = document.getElementById('controlPanelTab');
        const routeTab = document.getElementById('routeSelectorTab');

        if (!controlTab || !routeTab) return;

        if (!isCompactViewport()) {
          controlTab.classList.remove('is-hidden-mobile');
          routeTab.classList.remove('is-hidden-mobile');
          return;
        }

        const controlPanel = document.getElementById('controlPanel');
        const routePanel = document.getElementById('routeSelector');

        const controlVisible = isPanelVisibleForMobileBehavior(controlPanel);
        const routeVisible = isPanelVisibleForMobileBehavior(routePanel);

        if (controlVisible && !routeVisible) {
          routeTab.classList.add('is-hidden-mobile');
          controlTab.classList.remove('is-hidden-mobile');
        } else if (routeVisible && !controlVisible) {
          controlTab.classList.add('is-hidden-mobile');
          routeTab.classList.remove('is-hidden-mobile');
        } else {
          controlTab.classList.remove('is-hidden-mobile');
          routeTab.classList.remove('is-hidden-mobile');
        }
      }

      function positionAllPanelTabs() {
        positionPanelTab('routeSelector', 'routeSelectorTab', 'right');
        positionPanelTab('controlPanel', 'controlPanelTab', 'left');
        updatePanelTabVisibility();
      }

      window.addEventListener("load", positionAllPanelTabs);
      window.addEventListener("resize", positionAllPanelTabs);

      // Global storage for routes from GetRoutes.
      let allRoutes = {};
      // Global object to store user selections (for admin mode).
      let routeSelections = {};
      // Tracks routes that currently have at least one vehicle assigned.
      let activeRoutes = new Set();
      // Tracks which routes the API designates as public-facing.
      let routeVisibility = {};

      // Routes default to visible if they currently have vehicles unless the user
      // overrides the selection via the route selector.
      function isRouteSelected(routeID) {
        if (!canDisplayRoute(routeID)) return false;
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (routeSelections.hasOwnProperty(id)) return routeSelections[id];
        return activeRoutes.has(id);
      }

      function normalizeRouteIdForComparison(routeId) {
        if (routeId === undefined || routeId === null) return null;
        const numericId = Number(routeId);
        if (Number.isFinite(numericId)) {
          return `${numericId}`;
        }
        if (typeof routeId === 'string') {
          const trimmed = routeId.trim().toLowerCase();
          return trimmed !== '' ? trimmed : null;
        }
        const stringValue = String(routeId).trim().toLowerCase();
        return stringValue !== '' ? stringValue : null;
      }

      function routeHasActiveVehicles(routeId) {
        const normalizedRouteId = normalizeRouteIdForComparison(routeId);
        if (!normalizedRouteId) return false;
        let activeValues = [];
        if (activeRoutes instanceof Set) {
          activeValues = Array.from(activeRoutes);
        } else if (Array.isArray(activeRoutes)) {
          activeValues = activeRoutes.slice();
        } else {
          return false;
        }
        return activeValues.some(activeRouteId => {
          const normalizedActive = normalizeRouteIdForComparison(activeRouteId);
          return normalizedActive !== null && normalizedActive === normalizedRouteId;
        });
      }

      function setRouteVisibility(route) {
        if (!route || typeof route.RouteID === 'undefined') return;
        const id = Number(route.RouteID);
        if (Number.isNaN(id)) return;
        routeVisibility[id] = route.IsVisibleOnMap !== false;
      }

      function isRoutePublicById(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id) || id === 0) return false;
        if (Object.prototype.hasOwnProperty.call(routeVisibility, id)) {
          return routeVisibility[id];
        }
        return true;
      }

      function canDisplayRoute(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (id === 0) {
          return adminKioskMode || (!kioskMode && adminMode);
        }
        if (adminKioskMode) return true;
        if (kioskMode) return isRoutePublicById(id);
        if (adminMode) return true;
        return isRoutePublicById(id);
      }

      function setDisplayMode(mode) {
        const normalizedMode = typeof mode === 'string' ? mode.toLowerCase() : '';
        const validModes = Object.values(DISPLAY_MODES);
        if (!validModes.includes(normalizedMode)) return;
        const modeChanged = displayMode !== normalizedMode;
        displayMode = normalizedMode;
        updateDisplayModeButtons();
        if (modeChanged) {
          updateDisplayModeOverlays();
          refreshMap();
        }
      }

      function updateDisplayModeButtons() {
        const buttonContainer = document.getElementById('displayModeButtons');
        if (!buttonContainer) return;
        const buttons = buttonContainer.querySelectorAll('button[data-mode]');
        buttons.forEach(button => {
          const buttonMode = (button.dataset.mode || '').toLowerCase();
          const isActive = buttonMode === displayMode;
          button.classList.toggle('is-active', isActive);
        });
      }

      function updateTrainToggleButton() {
        const button = document.getElementById('trainToggleButton');
        if (!button) return;
        const allowTrains = adminFeaturesAllowed();
        const isActive = allowTrains && !!trainsVisible;
        button.classList.toggle('is-active', isActive);
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        button.disabled = !allowTrains;
        const indicator = button.querySelector('.toggle-indicator');
        if (indicator) {
          indicator.textContent = isActive ? 'On' : 'Off';
        }
      }

      function updateAircraftToggleButton() {
        const button = document.getElementById('aircraftToggleButton');
        if (!button) return;
        const allowPlanes = adminFeaturesAllowed();
        const planeLayer = window.PlaneLayer;
        const planeLayerStarted = !!(planeLayer && planeLayer.isStarted);
        const isActive = allowPlanes && !!planesVisible && planeLayerStarted;
        button.classList.toggle('is-active', isActive);
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        button.disabled = !allowPlanes;
        const indicator = button.querySelector('.toggle-indicator');
        if (indicator) {
          indicator.textContent = isActive ? 'On' : 'Off';
        }
      }

      function updateIncidentToggleButton() {
        const button = document.getElementById('incidentToggleButton');
        if (!button) return;
        const isActive = !!incidentsVisible;
        button.classList.toggle('is-active', isActive);
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        const indicator = button.querySelector('.toggle-indicator');
        if (indicator) {
          indicator.textContent = isActive ? 'On' : 'Off';
        }
      }

      function updateDisplayModeOverlays() {
        if (!map || typeof map.removeLayer !== 'function') return;
        Object.keys(nameBubbles).forEach(vehicleID => {
          const bubble = nameBubbles[vehicleID];
          if (!bubble) return;
          if (bubble.speedMarker && displayMode !== DISPLAY_MODES.SPEED) {
            map.removeLayer(bubble.speedMarker);
            delete bubble.speedMarker;
          }
          if (bubble.blockMarker && displayMode !== DISPLAY_MODES.BLOCK) {
            map.removeLayer(bubble.blockMarker);
            delete bubble.blockMarker;
          }
        });
      }

      function applyRouteOptionState(inputElement) {
        if (!inputElement || typeof inputElement.closest !== 'function') return;
        const parentLabel = inputElement.closest('label.route-option');
        if (!parentLabel) return;
        if (inputElement.checked) {
          parentLabel.classList.add('is-active');
        } else {
          parentLabel.classList.remove('is-active');
        }
      }

      function renderIncidentUnit(unit) {
        if (!unit) return '';
        const text = typeof unit.displayText === 'string' ? unit.displayText.trim() : '';
        if (!text) return '';
        const classes = ['incident-unit'];
        if (unit.statusKey) {
          classes.push(`incident-unit--${unit.statusKey.toLowerCase()}`);
        }
        const classAttr = classes.join(' ');
        const styleParts = [];
        if (unit.colorInfo) {
          if (unit.colorInfo.color) styleParts.push(`color:${unit.colorInfo.color}`);
          if (unit.colorInfo.background) styleParts.push(`background:${unit.colorInfo.background}`);
          if (unit.colorInfo.border) styleParts.push(`border-color:${unit.colorInfo.border}`);
        }
        const styleAttr = styleParts.length ? ` style="${styleParts.join(';')}"` : '';
        const tooltipValue = typeof unit.tooltip === 'string' ? unit.tooltip.trim() : '';
        const titleAttr = tooltipValue ? ` title="${escapeAttribute(tooltipValue)}"` : '';
        return `<span class="${classAttr}"${styleAttr}${titleAttr}>${escapeHtml(text)}</span>`;
      }

      function getIncidentUnitStatusLabel(unit) {
        if (!unit) return INCIDENT_UNIT_STATUS_FALLBACK_LABEL;
        const candidates = [
          typeof unit.statusLabel === 'string' ? unit.statusLabel.trim() : '',
          typeof unit.rawStatus === 'string' ? unit.rawStatus.trim() : '',
          typeof unit.statusKey === 'string' ? unit.statusKey.trim() : ''
        ];
        const label = candidates.find(value => value);
        return label || INCIDENT_UNIT_STATUS_FALLBACK_LABEL;
      }

      function getIncidentUnitStatusSortIndex(statusKey) {
        if (typeof statusKey === 'string' && statusKey) {
          const index = INCIDENT_UNIT_STATUS_SECTION_ORDER.indexOf(statusKey);
          if (index !== -1) return index;
        }
        return INCIDENT_UNIT_STATUS_SECTION_ORDER.length;
      }

      function buildIncidentUnitStatusGroups(units) {
        if (!Array.isArray(units) || units.length === 0) return [];
        const groupsMap = new Map();
        units.forEach((unit, index) => {
          if (!unit) return;
          const text = typeof unit.displayText === 'string' ? unit.displayText.trim() : '';
          if (!text) return;
          const rawLabel = getIncidentUnitStatusLabel(unit);
          const trimmedLabel = rawLabel ? rawLabel.trim() : '';
          const label = trimmedLabel || INCIDENT_UNIT_STATUS_FALLBACK_LABEL;
          const mapKey = unit.statusKey
            ? `key:${unit.statusKey}`
            : `label:${label.toLowerCase()}`;
          let group = groupsMap.get(mapKey);
          if (!group) {
            group = {
              key: unit.statusKey || '',
              label,
              units: [],
              sortIndex: getIncidentUnitStatusSortIndex(unit.statusKey || ''),
              firstUnitIndex: index
            };
            groupsMap.set(mapKey, group);
          }
          group.units.push(unit);
          if (index < group.firstUnitIndex) {
            group.firstUnitIndex = index;
          }
        });
        return Array.from(groupsMap.values()).sort((a, b) => {
          if (a.sortIndex !== b.sortIndex) return a.sortIndex - b.sortIndex;
          if (a.firstUnitIndex !== b.firstUnitIndex) return a.firstUnitIndex - b.firstUnitIndex;
          return a.label.localeCompare(b.label);
        });
      }

      function renderIncidentPopupUnitsSection(units) {
        const validUnits = Array.isArray(units)
          ? units.filter(unit => unit && typeof unit.displayText === 'string' && unit.displayText.trim())
          : [];
        if (!validUnits.length) return '';
        const groups = buildIncidentUnitStatusGroups(validUnits);
        if (!groups.length) return '';
        const groupsHtml = groups.map(group => {
          const unitsHtml = group.units.map(renderIncidentUnit).filter(Boolean).join('');
          if (!unitsHtml) return '';
          const safeLabel = escapeHtml(group.label);
          return `<div class="incident-popup__unit-status-group"><div class="incident-popup__unit-status-title">${safeLabel}</div><div class="incident-popup__unit-list">${unitsHtml}</div></div>`;
        }).filter(Boolean).join('');
        if (!groupsHtml) return '';
        return `<div class="incident-popup__section incident-popup__units"><div class="incident-popup__section-title">Units</div>${groupsHtml}</div>`;
      }

      function renderIncidentAlertUnitsSection(units) {
        const validUnits = Array.isArray(units)
          ? units.filter(unit => unit && typeof unit.displayText === 'string' && unit.displayText.trim())
          : [];
        if (!validUnits.length) return '';
        const groups = buildIncidentUnitStatusGroups(validUnits);
        if (!groups.length) return '';
        const groupsHtml = groups.map(group => {
          const unitsHtml = group.units.map(renderIncidentUnit).filter(Boolean).join('');
          if (!unitsHtml) return '';
          const safeLabel = escapeHtml(group.label);
          return `<div class="incident-alert__unit-status-group"><div class="incident-alert__unit-status-title">${safeLabel}</div><div class="incident-alert__unit-list">${unitsHtml}</div></div>`;
        }).filter(Boolean).join('');
        if (!groupsHtml) return '';
        return `<div class="incident-alert__units"><div class="incident-alert__units-label">Units</div>${groupsHtml}</div>`;
      }

      function renderIncidentAlertItem(entry) {
        if (!entry || !entry.incident) return '';
        const incident = entry.incident;
        const typeLabel = getIncidentTypeLabel(incident) || 'Incident';
        const safeTypeLabel = escapeHtml(typeLabel);
        const typeCode = getIncidentTypeCode(incident);
        const iconUrl = buildPulsePointListIconUrl(typeCode);
        const altText = typeLabel ? `${typeLabel} icon` : 'Incident icon';
        const safeAltText = escapeAttribute(altText);
        const iconHtml = iconUrl
          ? `<div class="incident-alert__media"><img src="${escapeAttribute(iconUrl)}" alt="${safeAltText}" loading="lazy" onerror="this.style.display='none';"></div>`
          : '';
        let incidentIdValue = typeof entry.id === 'string' ? entry.id : '';
        if (!incidentIdValue) {
          incidentIdValue = getIncidentIdentifier(incident) || '';
        }
        const normalizedIncidentId = getNormalizedIncidentId(incidentIdValue);
        if (!normalizedIncidentId) return '';
        const safeIncidentId = escapeAttribute(normalizedIncidentId);
        const locationText = getIncidentLocationText(incident);
        const locationHtml = locationText
          ? `<div class="incident-alert__location"><span class="incident-alert__location-label">Location:</span><span class="incident-alert__location-text">${escapeHtml(locationText)}</span></div>`
          : '';
        const timeInfo = getIncidentReceivedTimeInfo(incident);
        const metaParts = [];
        if (timeInfo) {
          metaParts.push(`<span class="incident-alert__received" title="${escapeAttribute(timeInfo.full)}">Received ${escapeHtml(timeInfo.display)}</span>`);
        }
        const metaHtml = metaParts.length ? `<div class="incident-alert__meta">${metaParts.join('')}</div>` : '';
        const routeNames = Array.isArray(entry.routes)
          ? entry.routes.map(route => (typeof route?.name === 'string' ? route.name.trim() : '')).filter(Boolean)
          : [];
        const routesHtml = routeNames.length
          ? `<div class="incident-alert__routes-line"><span class="incident-alert__routes-label">Routes:</span><span class="incident-alert__routes-list">${routeNames.map(name => escapeHtml(name)).join(', ')}</span></div>`
          : '';
        const units = extractIncidentUnits(incident);
        const unitsHtml = renderIncidentAlertUnitsSection(units);
        const buttonTitleParts = [];
        if (typeLabel) {
          buttonTitleParts.push(`View ${typeLabel}`);
        } else {
          buttonTitleParts.push('View incident');
        }
        if (locationText) {
          buttonTitleParts.push(`at ${locationText}`);
        }
        buttonTitleParts.push('on the map');
        const safeButtonTitle = escapeAttribute(buttonTitleParts.join(' '));
        return `
          <button type="button" class="incident-alert__item incident-alert__item-button" data-incident-id="${safeIncidentId}" onclick="handleIncidentAlertClick(this)" title="${safeButtonTitle}">
            ${iconHtml}
            <div class="incident-alert__content">
              <div class="incident-alert__type">${safeTypeLabel}</div>
              ${metaHtml}
              ${locationHtml}
              ${routesHtml}
              ${unitsHtml}
            </div>
          </button>
        `;
      }

      function renderIncidentAlertsHtml() {
        const hasDemo = demoIncidentActive && demoIncidentEntry && demoIncidentEntry.incident;
        if (!hasDemo && !incidentsAreAvailable()) return '';
        const sourceEntries = hasDemo
          ? [demoIncidentEntry]
          : (Array.isArray(incidentsNearRoutes) ? incidentsNearRoutes : []);
        if (!Array.isArray(sourceEntries) || sourceEntries.length === 0) return '';
        const itemsHtml = sourceEntries.map(renderIncidentAlertItem).filter(Boolean).join('');
        if (!itemsHtml) return '';
        const multiple = sourceEntries.length > 1;
        const heading = hasDemo
          ? 'Demo Incident Near a Route'
          : (multiple ? 'Active Incidents Near Routes' : 'Active Incident Near a Route');
        const subheading = hasDemo
          ? 'Preview of an active incident alert using built-in sample data.'
          : (multiple
            ? 'Emergency responses are active on or near multiple transit corridors.'
            : 'An emergency response is active on or near a transit corridor.');
        return `
          <div class="selector-section incident-alert-block">
            <div class="incident-alert__header">
              <div class="incident-alert__title">${escapeHtml(heading)}</div>
              <div class="incident-alert__subtitle">${escapeHtml(subheading)}</div>
            </div>
            <div class="incident-alert__list">
              ${itemsHtml}
            </div>
          </div>
        `;
      }

      function handleIncidentAlertClick(element) {
        if (!element) return;
        const incidentId = element.getAttribute('data-incident-id');
        if (!incidentId) return;
        focusIncidentOnMap(incidentId);
      }

      function focusIncidentOnMap(incidentId) {
        if (!map) return;
        const normalizedId = getNormalizedIncidentId(incidentId);
        if (!normalizedId) return;
        maintainIncidentLayers();
        const entry = incidentMarkers.get(normalizedId);
        let latLng = null;
        if (entry && entry.marker && typeof entry.marker.getLatLng === 'function') {
          latLng = entry.marker.getLatLng();
        }
        if (!latLng) {
          const match = incidentsNearRoutesLookup.get(normalizedId);
          const incident = match?.incident || entry?.data || null;
          if (incident) {
            const lat = parseIncidentCoordinate(incident.Latitude ?? incident.latitude ?? incident.lat);
            const lon = parseIncidentCoordinate(incident.Longitude ?? incident.longitude ?? incident.lon);
            if (Number.isFinite(lat) && Number.isFinite(lon)) {
              if (typeof L !== 'undefined' && typeof L.latLng === 'function') {
                latLng = L.latLng(lat, lon);
              } else {
                latLng = { lat, lng: lon };
              }
            }
          }
        }
        if (!latLng || !Number.isFinite(latLng.lat) || !Number.isFinite(latLng.lng)) {
          return;
        }
        const targetLat = Number(latLng.lat);
        const targetLng = Number(latLng.lng);
        if (!Number.isFinite(targetLat) || !Number.isFinite(targetLng)) {
          return;
        }
        const currentZoom = typeof map.getZoom === 'function' ? map.getZoom() : null;
        const targetZoom = Number.isFinite(currentZoom) ? Math.max(currentZoom, 16) : 16;
        if (typeof map.flyTo === 'function') {
          map.flyTo([targetLat, targetLng], targetZoom, { animate: true, duration: 0.75, easeLinearity: 0.25 });
        } else if (typeof map.setView === 'function') {
          map.setView([targetLat, targetLng], targetZoom, { animate: true });
        }
        if (entry && entry.marker) {
          if (typeof entry.marker.bringToFront === 'function') {
            entry.marker.bringToFront();
          } else if (typeof entry.marker.setZIndexOffset === 'function') {
            entry.marker.setZIndexOffset(500);
          }
          if (typeof entry.marker.fire === 'function') {
            entry.marker.fire('click');
          }
        } else {
          const match = incidentsNearRoutesLookup.get(normalizedId);
          const incident = match?.incident || null;
          if (incident) {
            const routes = Array.isArray(match?.routes) ? match.routes : [];
            createCustomPopup({
              popupType: 'incident',
              position: [targetLat, targetLng],
              incident,
              id: normalizedId,
              routes
            });
          }
        }
      }

      function formatServiceAlertDate(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
          return '';
        }
        if (SERVICE_ALERT_DATE_FORMATTER) {
          try {
            return SERVICE_ALERT_DATE_FORMATTER.format(date);
          } catch (error) {
            // fall through to native formatting
          }
        }
        try {
          return date.toLocaleString();
        } catch (error) {
          return date.toString();
        }
      }

      function formatServiceAlertTimeValue(value) {
        if (value === null || value === undefined) {
          return { display: '', raw: '' };
        }
        if (value instanceof Date && !Number.isNaN(value.getTime())) {
          return {
            display: formatServiceAlertDate(value),
            raw: value.toISOString()
          };
        }
        if (typeof value === 'number' && Number.isFinite(value)) {
          const date = new Date(value);
          if (!Number.isNaN(date.getTime())) {
            return {
              display: formatServiceAlertDate(date),
              raw: String(value)
            };
          }
          return { display: String(value), raw: String(value) };
        }
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) {
            return { display: '', raw: '' };
          }
          const unixMatch = trimmed.match(/\/Date\((\d+)\)\/?/i);
          if (unixMatch && unixMatch[1]) {
            const millis = Number(unixMatch[1]);
            if (Number.isFinite(millis)) {
              const date = new Date(millis);
              if (!Number.isNaN(date.getTime())) {
                return {
                  display: formatServiceAlertDate(date),
                  raw: trimmed
                };
              }
            }
          }
          const parsed = new Date(trimmed);
          if (!Number.isNaN(parsed.getTime())) {
            return {
              display: formatServiceAlertDate(parsed),
              raw: trimmed
            };
          }
          return { display: trimmed, raw: trimmed };
        }
        if (typeof value === 'object') {
          const stringValue = String(value);
          if (stringValue && stringValue !== '[object Object]') {
            return formatServiceAlertTimeValue(stringValue);
          }
        }
        return { display: '', raw: '' };
      }

      function extractServiceAlertTime(record, type) {
        if (!record || typeof record !== 'object') {
          return { display: '', raw: '' };
        }
        const fields = type === 'end' ? SERVICE_ALERT_END_FIELDS : SERVICE_ALERT_START_FIELDS;
        for (const field of fields) {
          if (Object.prototype.hasOwnProperty.call(record, field)) {
            const info = formatServiceAlertTimeValue(record[field]);
            if (info.display) {
              return info;
            }
          }
        }
        const lowerKeyMap = Object.keys(record).reduce((acc, key) => {
          acc[key.toLowerCase()] = key;
          return acc;
        }, {});
        for (const field of fields) {
          const originalKey = lowerKeyMap[field.toLowerCase()];
          if (originalKey && Object.prototype.hasOwnProperty.call(record, originalKey)) {
            const info = formatServiceAlertTimeValue(record[originalKey]);
            if (info.display) {
              return info;
            }
          }
        }
        return { display: '', raw: '' };
      }

      function normalizeServiceAlertRoutes(record) {
        const collected = [];
        const candidateKeys = ['Routes', 'routes', 'RoutesAffected', 'routesAffected', 'AffectedRoutes', 'affectedRoutes', 'RouteNames', 'routeNames'];
        for (const key of candidateKeys) {
          if (!Object.prototype.hasOwnProperty.call(record, key)) continue;
          const value = record[key];
          if (Array.isArray(value)) {
            value.forEach(entry => {
              if (!entry) return;
              if (typeof entry === 'string') {
                const trimmed = entry.trim();
                if (trimmed) collected.push(trimmed);
                return;
              }
              if (typeof entry === 'object') {
                const nameCandidates = [
                  typeof entry.Name === 'string' ? entry.Name.trim() : '',
                  typeof entry.RouteName === 'string' ? entry.RouteName.trim() : '',
                  typeof entry.Description === 'string' ? entry.Description.trim() : '',
                  typeof entry.Title === 'string' ? entry.Title.trim() : '',
                  typeof entry.label === 'string' ? entry.label.trim() : ''
                ];
                const label = nameCandidates.find(candidate => candidate);
                if (label) collected.push(label);
              }
            });
          } else if (typeof value === 'string') {
            const trimmed = value.trim();
            if (trimmed) {
              trimmed.split(/[,;]+/).map(part => part.trim()).filter(Boolean).forEach(part => collected.push(part));
            }
          }
          if (collected.length) break;
        }
        if (!collected.length) {
          return [];
        }
        const seen = new Set();
        return collected.filter(route => {
          const key = route.toLowerCase();
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      }

      function normalizeServiceAlertRow(row) {
        if (!row || typeof row !== 'object') return null;
        const titleCandidates = [
          typeof row.MessageTitle === 'string' ? row.MessageTitle.trim() : '',
          typeof row.Title === 'string' ? row.Title.trim() : '',
          typeof row.Subject === 'string' ? row.Subject.trim() : ''
        ];
        const messageCandidates = [
          typeof row.MessageText === 'string' ? row.MessageText.trim() : '',
          typeof row.MessageBody === 'string' ? row.MessageBody.trim() : '',
          typeof row.Text === 'string' ? row.Text.trim() : '',
          typeof row.Description === 'string' ? row.Description.trim() : '',
          typeof row.Details === 'string' ? row.Details.trim() : '',
          typeof row.Body === 'string' ? row.Body.trim() : ''
        ];
        const title = titleCandidates.find(candidate => candidate) || '';
        const message = messageCandidates.find(candidate => candidate) || '';
        const startInfo = extractServiceAlertTime(row, 'start');
        const endInfo = extractServiceAlertTime(row, 'end');
        const idCandidates = [
          row.MessageID,
          row.MessageId,
          row.MessageGuid,
          row.Guid,
          row.ID,
          row.Id,
          row.AlertId,
          row.AlertID,
          row.RecordId,
          row.RecordID
        ];
        const rawId = idCandidates.find(value => value !== null && value !== undefined);
        const statusValue = typeof row.Status === 'string' ? row.Status.trim().toLowerCase() : '';
        let isActive = true;
        if (Object.prototype.hasOwnProperty.call(row, 'IsActive')) {
          isActive = !!row.IsActive;
        } else if (Object.prototype.hasOwnProperty.call(row, 'Active')) {
          isActive = !!row.Active;
        } else if (Object.prototype.hasOwnProperty.call(row, 'Visible')) {
          isActive = !!row.Visible;
        } else if (statusValue) {
          isActive = !(statusValue === 'inactive' || statusValue === 'expired' || statusValue === 'inactive alert');
        }
        const routes = normalizeServiceAlertRoutes(row);
        return {
          id: rawId !== undefined && rawId !== null ? String(rawId) : (title || message || null),
          title,
          message,
          startDisplay: startInfo.display,
          startRaw: startInfo.raw,
          endDisplay: endInfo.display,
          endRaw: endInfo.raw,
          isActive,
          routes
        };
      }

      function extractServiceAlertRows(data) {
        if (!data) return [];
        if (Array.isArray(data)) return data;
        if (Array.isArray(data.Rows)) return data.Rows;
        if (Array.isArray(data.rows)) return data.rows;
        if (Array.isArray(data.Result?.Rows)) return data.Result.Rows;
        if (Array.isArray(data.Result)) return data.Result;
        if (Array.isArray(data.Data)) return data.Data;
        if (Array.isArray(data.data)) return data.data;
        if (Array.isArray(data.Messages)) return data.Messages;
        if (Array.isArray(data.messages)) return data.messages;
        if (data.d) return extractServiceAlertRows(data.d);
        return [];
      }

      function getVisibleServiceAlerts() {
        const baseAlerts = Array.isArray(serviceAlerts) ? serviceAlerts : [];
        if (!catOverlayEnabled) {
          return baseAlerts;
        }
        const catAlerts = Array.isArray(catServiceAlerts) ? catServiceAlerts : [];
        return baseAlerts.concat(catAlerts);
      }

      function getActiveServiceAlertCount() {
        const alerts = getVisibleServiceAlerts();
        if (!Array.isArray(alerts) || alerts.length === 0) {
          return 0;
        }
        return alerts.reduce((total, alert) => {
          if (!alert) return total;
          return total + (alert.isActive === false ? 0 : 1);
        }, 0);
      }

      function isAnyServiceAlertsLoading() {
        return !!serviceAlertsLoading || (catOverlayEnabled && !!catServiceAlertsLoading);
      }

      function getCombinedServiceAlertsError() {
        const alerts = getVisibleServiceAlerts();
        const hasVisibleAlerts = Array.isArray(alerts) && alerts.length > 0;
        if (serviceAlertsError && !hasVisibleAlerts) {
          return serviceAlertsError;
        }
        if (catOverlayEnabled && catServiceAlertsError && !hasVisibleAlerts && !isAnyServiceAlertsLoading()) {
          return catServiceAlertsError;
        }
        return null;
      }

      function buildServiceAlertsStatusText() {
        if (isAnyServiceAlertsLoading()) {
          return SERVICE_ALERT_STATUS_LOADING;
        }
        const errorMessage = getCombinedServiceAlertsError();
        if (errorMessage) {
          return SERVICE_ALERT_STATUS_ERROR;
        }
        if (!serviceAlertsHasLoaded && !(catOverlayEnabled && Array.isArray(catServiceAlerts) && catServiceAlerts.length > 0)) {
          return SERVICE_ALERT_STATUS_LOADING;
        }
        const count = getActiveServiceAlertCount();
        if (count > 0) {
          return count === 1 ? '1 Active Alert' : `${count} Active Alerts`;
        }
        return SERVICE_ALERT_STATUS_NO_ALERTS;
      }

      function renderServiceAlertItem(alert) {
        if (!alert) return '';
        const itemClasses = ['service-alerts-item'];
        if (alert.isActive === false) {
          itemClasses.push('is-inactive');
        }
        const idAttr = alert.id ? ` data-alert-id="${escapeAttribute(alert.id)}"` : '';
        const titleTextRaw = typeof alert.title === 'string' ? alert.title.trim() : '';
        const messageTextRaw = typeof alert.message === 'string' ? alert.message.trim() : '';
        const titleText = titleTextRaw || 'Service Alert';
        const statusText = alert.isActive === false ? 'Inactive' : 'Active';
        const headerHtml = `<div class="service-alerts-item__header"><div class="service-alerts-item__title">${escapeHtml(titleText)}</div><span class="service-alerts-item__status">${escapeHtml(statusText)}</span></div>`;
        const messageHtml = messageTextRaw ? `<div class="service-alerts-item__message">${escapeHtml(messageTextRaw)}</div>` : '';
        const metaRows = [];
        if (alert.startDisplay) {
          const titleAttr = alert.startRaw ? ` title="${escapeAttribute(alert.startRaw)}"` : '';
          metaRows.push(`<div class="service-alerts-item__meta-row"><span class="service-alerts-item__meta-label">Start</span><span class="service-alerts-item__meta-value"${titleAttr}>${escapeHtml(alert.startDisplay)}</span></div>`);
        }
        if (alert.endDisplay) {
          const titleAttr = alert.endRaw ? ` title="${escapeAttribute(alert.endRaw)}"` : '';
          metaRows.push(`<div class="service-alerts-item__meta-row"><span class="service-alerts-item__meta-label">End</span><span class="service-alerts-item__meta-value"${titleAttr}>${escapeHtml(alert.endDisplay)}</span></div>`);
        }
        if (Array.isArray(alert.routes) && alert.routes.length > 0) {
          const routesHtml = alert.routes.map(route => escapeHtml(route)).join(', ');
          metaRows.push(`<div class="service-alerts-item__meta-row"><span class="service-alerts-item__meta-label">Routes</span><span class="service-alerts-item__meta-value">${routesHtml}</span></div>`);
        }
        const metaHtml = metaRows.length ? `<div class="service-alerts-item__meta">${metaRows.join('')}</div>` : '';
        return `<li class="${itemClasses.join(' ')}"${idAttr}>${headerHtml}${messageHtml}${metaHtml}</li>`;
      }

      function renderServiceAlertsPanelContentHtml() {
        const alerts = getVisibleServiceAlerts();
        const loading = isAnyServiceAlertsLoading();
        const errorMessage = getCombinedServiceAlertsError();
        if (loading && (!Array.isArray(alerts) || alerts.length === 0)) {
          return `<div class="service-alerts-state service-alerts-state--loading">Loading service alerts</div>`;
        }
        if (errorMessage && (!Array.isArray(alerts) || alerts.length === 0)) {
          return `<div class="service-alerts-state service-alerts-state--error">${escapeHtml(errorMessage)}</div>`;
        }
        if (!Array.isArray(alerts) || alerts.length === 0) {
          return '';
        }
        const itemsHtml = alerts.map(renderServiceAlertItem).filter(Boolean).join('');
        if (!itemsHtml) {
          return '';
        }
        return `<ul class="service-alerts-list">${itemsHtml}</ul>`;
      }

      function renderServiceAlertsSectionHtml() {
        const buttonClasses = ['pill-button', 'service-alerts-toggle'];
        if (serviceAlertsExpanded) buttonClasses.push('is-expanded');
        if (isAnyServiceAlertsLoading()) buttonClasses.push('is-loading');
        if (getCombinedServiceAlertsError()) buttonClasses.push('has-error');
        if (getActiveServiceAlertCount() > 0) buttonClasses.push('has-active-alerts');
        const panelClasses = ['service-alerts-panel'];
        if (serviceAlertsExpanded) panelClasses.push('is-expanded');
        if (isAnyServiceAlertsLoading()) panelClasses.push('is-loading');
        if (getCombinedServiceAlertsError()) panelClasses.push('has-error');
        const panelContentHtml = renderServiceAlertsPanelContentHtml();
        const panelHasContent = typeof panelContentHtml === 'string' && panelContentHtml.trim().length > 0;
        if (!panelHasContent) panelClasses.push('is-empty');
        const statusText = escapeHtml(buildServiceAlertsStatusText());
        const hiddenAttr = serviceAlertsExpanded ? '' : ' hidden';
        const ariaHiddenAttr = ` aria-hidden="${serviceAlertsExpanded ? 'false' : 'true'}"`;
        return `
          <div class="selector-group service-alerts-group">
            <button type="button" id="serviceAlertsToggle" class="${buttonClasses.join(' ')}" aria-expanded="${serviceAlertsExpanded ? 'true' : 'false'}" aria-controls="serviceAlertsPanel" onclick="toggleServiceAlertsPanel(event)">
              <span class="service-alerts-toggle__text">
                <span class="service-alerts-toggle__label">Service Alerts</span>
                <span class="service-alerts-toggle__status">${statusText}</span>
              </span>
              <span class="service-alerts-toggle__chevron" aria-hidden="true"></span>
            </button>
            <div id="serviceAlertsPanel" class="${panelClasses.join(' ')}"${hiddenAttr}${ariaHiddenAttr}>${panelContentHtml}</div>
          </div>
        `;
      }

      function updateServiceAlertsButtonState() {
        const button = document.getElementById('serviceAlertsToggle');
        if (!button) return;
        button.setAttribute('aria-expanded', serviceAlertsExpanded ? 'true' : 'false');
        button.classList.toggle('is-expanded', !!serviceAlertsExpanded);
        button.classList.toggle('is-loading', isAnyServiceAlertsLoading());
        button.classList.toggle('has-error', !!getCombinedServiceAlertsError());
        button.classList.toggle('has-active-alerts', getActiveServiceAlertCount() > 0);
        const statusEl = button.querySelector('.service-alerts-toggle__status');
        if (statusEl) {
          statusEl.textContent = buildServiceAlertsStatusText();
        }
      }

      function updateServiceAlertsPanelVisibility() {
        const panel = document.getElementById('serviceAlertsPanel');
        if (!panel) return;
        panel.hidden = !serviceAlertsExpanded;
        panel.setAttribute('aria-hidden', serviceAlertsExpanded ? 'false' : 'true');
        if (panel.style) {
          if (serviceAlertsExpanded) {
            if (typeof panel.style.removeProperty === 'function') {
              panel.style.removeProperty('display');
            } else {
              panel.style.display = '';
            }
          } else {
            panel.style.display = 'none';
          }
        }
        panel.classList.toggle('is-expanded', !!serviceAlertsExpanded);
        panel.classList.toggle('is-loading', isAnyServiceAlertsLoading());
        panel.classList.toggle('has-error', !!getCombinedServiceAlertsError());
        const panelHasContent = typeof panel.innerHTML === 'string' && panel.innerHTML.trim().length > 0;
        panel.classList.toggle('is-empty', !panelHasContent && !isAnyServiceAlertsLoading() && !getCombinedServiceAlertsError());
      }

      function updateServiceAlertsPanelContent() {
        const panel = document.getElementById('serviceAlertsPanel');
        if (!panel) return;
        const contentHtml = renderServiceAlertsPanelContentHtml();
        panel.innerHTML = contentHtml;
        const hasContent = typeof contentHtml === 'string' && contentHtml.trim().length > 0;
        panel.classList.toggle('is-empty', !hasContent);
      }

      function refreshServiceAlertsUI() {
        const hasVisibleAlerts = getVisibleServiceAlerts().length > 0;
        if (serviceAlertsExpanded && !hasVisibleAlerts && !isAnyServiceAlertsLoading() && !getCombinedServiceAlertsError() && (serviceAlertsHasLoaded || (catOverlayEnabled && !catServiceAlertsLoading))) {
          serviceAlertsExpanded = false;
        }
        updateServiceAlertsButtonState();
        updateServiceAlertsPanelContent();
        updateServiceAlertsPanelVisibility();
      }

      function shouldFetchServiceAlerts() {
        if (serviceAlertsLoading || serviceAlertsFetchPromise) {
          return false;
        }
        if (!baseURL) {
          return true;
        }
        if (serviceAlertsLastFetchAgency !== baseURL) {
          return true;
        }
        if (!serviceAlertsLastFetchTime) {
          return true;
        }
        return (Date.now() - serviceAlertsLastFetchTime) > SERVICE_ALERT_REFRESH_INTERVAL_MS;
      }

        async function fetchServiceAlertsForCurrentAgency() {
          if (serviceAlertsFetchPromise) {
            return serviceAlertsFetchPromise;
          }
          const fetchBaseURL = baseURL;
          const sanitizedBase = sanitizeBaseUrl(fetchBaseURL);
          if (!sanitizedBase) {
            serviceAlerts = [];
            serviceAlertsError = SERVICE_ALERT_UNAVAILABLE_MESSAGE;
            serviceAlertsLoading = false;
            serviceAlertsLastFetchAgency = fetchBaseURL;
            serviceAlertsLastFetchTime = Date.now();
            serviceAlertsHasLoaded = true;
            refreshServiceAlertsUI();
            return [];
          }
        serviceAlertsLoading = true;
        serviceAlertsError = null;
        refreshServiceAlertsUI();
        const query = new URLSearchParams({
          showInactive: 'false',
          includeDeleted: 'false',
          messageTypeId: '1',
          search: 'false',
          rows: '10',
          page: '1',
          sortIndex: 'StartDateUtc',
          sortOrder: 'asc'
        });
        const endpoint = `${sanitizedBase}/Secure/Services/RoutesService.svc/GetMessagesPaged?${query.toString()}`;
        const requestPromise = (async () => {
          const response = await fetch(endpoint, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Service alerts request failed: ${response.status}`);
          }
          const text = await response.text();
          let payload = {};
          if (text) {
            try {
              payload = JSON.parse(text);
            } catch (parseError) {
              console.error('Failed to parse service alerts response:', parseError);
              throw parseError;
            }
          }
          let rows = extractServiceAlertRows(payload);
          if (!rows.length && payload && typeof payload === 'object' && payload.d) {
            rows = extractServiceAlertRows(payload.d);
          }
          return rows.map(normalizeServiceAlertRow).filter(Boolean);
        })();
          serviceAlertsFetchPromise = requestPromise;
          try {
            const alerts = await requestPromise;
            if (baseURL !== fetchBaseURL) {
              return alerts;
            }
            serviceAlerts = alerts;
            serviceAlertsError = null;
            serviceAlertsLoading = false;
            serviceAlertsLastFetchAgency = fetchBaseURL;
            serviceAlertsLastFetchTime = Date.now();
            serviceAlertsHasLoaded = true;
            return alerts;
          } catch (error) {
            console.error('Failed to fetch service alerts:', error);
            if (baseURL !== fetchBaseURL) {
              return [];
            }
            serviceAlerts = [];
            serviceAlertsError = SERVICE_ALERT_UNAVAILABLE_MESSAGE;
            serviceAlertsLoading = false;
            serviceAlertsLastFetchAgency = fetchBaseURL;
            serviceAlertsLastFetchTime = Date.now();
            serviceAlertsHasLoaded = true;
            return [];
          } finally {
            if (serviceAlertsFetchPromise === requestPromise) {
              serviceAlertsFetchPromise = null;
            }
            if (baseURL === fetchBaseURL) {
              refreshServiceAlertsUI();
            }
          }
        }

      function toggleServiceAlertsPanel(event) {
        if (event && typeof event.preventDefault === 'function') {
          event.preventDefault();
        }
        const hasVisibleAlerts = getVisibleServiceAlerts().length > 0;
        const loading = isAnyServiceAlertsLoading();
        const errorMessage = getCombinedServiceAlertsError();
        if (!serviceAlertsExpanded && !hasVisibleAlerts && !loading && !errorMessage && (serviceAlertsHasLoaded || (catOverlayEnabled && !catServiceAlertsLoading))) {
          return;
        }
        serviceAlertsExpanded = !serviceAlertsExpanded;
        refreshServiceAlertsUI();
        if (serviceAlertsExpanded && shouldFetchServiceAlerts()) {
          fetchServiceAlertsForCurrentAgency();
        }
      }

      function resetServiceAlertsState() {
        serviceAlerts = [];
        serviceAlertsLoading = false;
        serviceAlertsError = null;
        serviceAlertsExpanded = false;
        serviceAlertsLastFetchAgency = '';
        serviceAlertsLastFetchTime = 0;
        serviceAlertsFetchPromise = null;
        serviceAlertsHasLoaded = false;
        refreshServiceAlertsUI();
      }

      function escapeAttribute(value) {
        return String(value || '')
          .replace(/&/g, '&amp;')
          .replace(/"/g, '&quot;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }


      function sanitizeBaseUrl(url) {
        if (typeof url !== 'string') return '';
        return url.trim().replace(/\/+$/, '');
      }

      function updateControlPanel() {
        const panel = document.getElementById('controlPanel');
        if (!panel) return;

        const selectedAgency = agencies.find(a => a.url === baseURL);
        const sanitizedBaseURL = sanitizeBaseUrl(baseURL);
        let logoHtml = '';
        if (sanitizedBaseURL) {
          const agencyLogoUrl = `${sanitizedBaseURL}/Images/clientLogo.jpg`;
          const safeLogoSrc = escapeAttribute(agencyLogoUrl);
          const logoAltText = selectedAgency?.name ? `${selectedAgency.name} logo` : 'Agency logo';
          const safeLogoAltText = escapeAttribute(logoAltText);
          logoHtml = `
            <div class="selector-logo">
              <img src="${safeLogoSrc}" alt="${safeLogoAltText}" loading="lazy" onerror="this.closest('.selector-logo').style.display='none';">
            </div>
          `;
        }

        const incidentAlertsHtml = renderIncidentAlertsHtml();
        const serviceAlertsSectionHtml = renderServiceAlertsSectionHtml();
        const allowAdminFeatures = adminFeaturesAllowed();
        if (!allowAdminFeatures && planesVisible) {
          setPlanesVisibility(false);
        }
        let trainToggleHtml = '';
        if (allowAdminFeatures) {
          trainToggleHtml = `
            <div class="selector-group">
              <div class="selector-label">Trains and Planes</div>
              <button type="button" id="trainToggleButton" class="pill-button train-toggle-button${trainsVisible ? ' is-active' : ''}" aria-pressed="${trainsVisible ? 'true' : 'false'}" onclick="toggleTrainsVisibility()">
                Show Amtrak<span class="toggle-indicator">${trainsVisible ? 'On' : 'Off'}</span>
              </button>
              <button type="button" id="aircraftToggleButton" class="pill-button aircraft-toggle-button${planesVisible ? ' is-active' : ''}" aria-pressed="${planesVisible ? 'true' : 'false'}" onclick="toggleAircraftVisibility()">
                Show Aircraft<span class="toggle-indicator">${planesVisible ? 'On' : 'Off'}</span>
              </button>
            </div>
          `;
        }
        let radarControlsHtml = '';
        if (allowAdminFeatures) {
          const toggleActive = radarEnabled && !radarTemporarilyUnavailable;
          const toggleDisabledAttr = radarTemporarilyUnavailable ? ' disabled' : '';
          const productOptions = RADAR_PRODUCT_ORDER.map(productKey => {
            const info = RADAR_PRODUCT_INFO[productKey] || {};
            const label = typeof info.label === 'string' ? info.label : productKey;
            const safeLabel = escapeHtml(label);
            const selected = radarProduct === productKey ? ' selected' : '';
            return `<option value="${productKey}"${selected}>${safeLabel}</option>`;
          }).join('');
          const statusText = radarTemporarilyUnavailable ? escapeHtml(RADAR_UNAVAILABLE_MESSAGE) : '';
          radarControlsHtml = `
            <div class="selector-group radar-control-group">
              <div class="selector-label">Radar</div>
              <button type="button" id="radarToggleButton" class="pill-button radar-toggle${toggleActive ? ' is-active' : ''}" aria-pressed="${toggleActive ? 'true' : 'false'}"${toggleDisabledAttr}>
                Show Radar<span class="toggle-indicator">${toggleActive ? 'On' : 'Off'}</span>
              </button>
              <div class="radar-control">
                <label class="radar-control-label" for="radarProductSelect">Product</label>
                <div class="selector-control">
                  <select id="radarProductSelect">
                    ${productOptions}
                  </select>
                </div>
              </div>
              <div class="radar-control">
                <label class="radar-control-label" for="radarOpacityRange">Opacity</label>
                <div class="radar-opacity-row">
                  <input type="range" id="radarOpacityRange" min="${RADAR_MIN_OPACITY}" max="${RADAR_MAX_OPACITY}" step="0.01" value="${radarOpacity.toFixed(2)}">
                  <span id="radarOpacityValue" class="radar-opacity-value">${formatRadarOpacity(radarOpacity)}</span>
                </div>
              </div>
              <div id="radarStatusMessage" class="radar-status-message" role="status" aria-live="polite"${radarTemporarilyUnavailable ? '' : ' style="display:none;"'}>${statusText}</div>
            </div>
          `;
        }
        let demoButtonHtml = '';
        if (adminMode) {
          const demoButtonLabel = demoIncidentActive ? 'Hide Demo Incident' : 'Show Demo Incident';
          const demoButtonPressed = demoIncidentActive ? 'true' : 'false';
          const demoNoteText = demoIncidentActive
            ? 'Showing sample alert using built-in data.'
            : 'Load a sample alert using built-in data.';
          demoButtonHtml = `
            <!-- Demo incident preview controls (remove when the demo is finished) -->
            <div class="selector-section demo-incident-section">
              <button type="button" id="demoIncidentButton" class="demo-incident-button${demoIncidentActive ? ' is-active' : ''}" aria-pressed="${demoButtonPressed}" onclick="toggleDemoIncident()">
                ${escapeHtml(demoButtonLabel)}
              </button>
              <div class="demo-incident-note">${escapeHtml(demoNoteText)}</div>
            </div>
          `;
        }
        const incidentToggleHtml = incidentsAreAvailable() ? `
          <div class="selector-group">
            <div class="selector-label">Incidents</div>
            <button type="button" id="incidentToggleButton" class="pill-button incident-toggle-button${incidentsVisible ? ' is-active' : ''}" aria-pressed="${incidentsVisible ? 'true' : 'false'}" onclick="toggleIncidentsVisibility()">
              Show Incidents<span class="toggle-indicator">${incidentsVisible ? 'On' : 'Off'}</span>
            </button>
          </div>
        ` : '';
        let html = `
          <div class="selector-header">
            <div class="selector-header-text">
              <div class="selector-title">System Controls</div>
              <div class="selector-subtitle">Choose a transit system and label style.</div>
            </div>
            ${logoHtml}
          </div>
          <div class="selector-content">
            <div class="selector-group">
              <label class="selector-label" for="agencySelect">Select System</label>
              <div class="selector-control">
                <select id="agencySelect" onchange="changeAgency(this.value)">
        `;
        agencies.forEach(a => {
          html += `<option value="${a.url}" ${a.url === baseURL ? 'selected' : ''}>${a.name}</option>`;
        });
        html += `
                </select>
              </div>
            </div>
            <div class="selector-group">
              <button type="button" id="catToggleButton" class="pill-button cat-toggle-button${catOverlayEnabled ? ' is-active' : ''}" aria-pressed="${catOverlayEnabled ? 'true' : 'false'}" onclick="toggleCatOverlay()">
                Show CAT<span class="toggle-indicator">${catOverlayEnabled ? 'On' : 'Off'}</span>
              </button>
            </div>
        `;
        html += serviceAlertsSectionHtml;
        html += incidentAlertsHtml;

        if (adminMode) {
          html += `
            <div class="selector-group">
              <div class="selector-label">Vehicle Labels</div>
              <div class="display-mode-group" id="displayModeButtons">
                <button type="button" class="pill-button display-mode-button ${displayMode === DISPLAY_MODES.SPEED ? 'is-active' : ''}" data-mode="${DISPLAY_MODES.SPEED}" onclick="setDisplayMode('${DISPLAY_MODES.SPEED}')">
                  Show Speed
                </button>
                <button type="button" class="pill-button display-mode-button ${displayMode === DISPLAY_MODES.BLOCK ? 'is-active' : ''}" data-mode="${DISPLAY_MODES.BLOCK}" onclick="setDisplayMode('${DISPLAY_MODES.BLOCK}')">
                  Show Blocks
                </button>
                <button type="button" class="pill-button display-mode-button ${displayMode === DISPLAY_MODES.NONE ? 'is-active' : ''}" data-mode="${DISPLAY_MODES.NONE}" onclick="setDisplayMode('${DISPLAY_MODES.NONE}')">
                  Show None
                </button>
              </div>
            </div>
          `;
        }

        html += incidentToggleHtml;
        html += radarControlsHtml;
        html += trainToggleHtml;
        html += demoButtonHtml;

        html += `
          </div>
        `;

        panel.innerHTML = html;
        updateCatToggleButtonState();
        initializeRadarControls();
        updateDisplayModeButtons();
        updateTrainToggleButton();
        updateAircraftToggleButton();
        updateIncidentToggleButton();
        refreshServiceAlertsUI();
        positionAllPanelTabs();
      }

      // updateRouteSelector rebuilds the route selector panel.
      // The list (excluding Out of Service) is alphabetized and defaults to
      // checking only routes that currently have vehicles.
      function updateRouteSelector(activeRoutesParam, forceUpdate = false) {
        const container = document.getElementById("routeSelector");
        if (!container) return;

        const activeRoutesSet = activeRoutesParam instanceof Set
          ? activeRoutesParam
          : new Set(Array.isArray(activeRoutesParam) ? activeRoutesParam : []);

        if (forceUpdate) {
          lastRouteSelectorSignature = null;
        }

        const agencyDropdown = document.getElementById('agencySelect');
        if (!forceUpdate && agencyDropdown && document.activeElement === agencyDropdown) {
          return;
        }

        let routeIDs = Object.keys(allRoutes)
          .map(id => Number(id))
          .filter(id => !Number.isNaN(id) && id !== 0 && canDisplayRoute(id));

        routeIDs.sort((a, b) => {
          const aHasVehicle = activeRoutesSet.has(a);
          const bHasVehicle = activeRoutesSet.has(b);
          if (aHasVehicle !== bHasVehicle) {
            return aHasVehicle ? -1 : 1;
          }
          const routeA = allRoutes[a] || {};
          const routeB = allRoutes[b] || {};
          const nameA = (routeA.Description || routeA.RouteName || `Route ${routeA.RouteID || a}` || '').trim().toUpperCase();
          const nameB = (routeB.Description || routeB.RouteName || `Route ${routeB.RouteID || b}` || '').trim().toUpperCase();
          if (nameA < nameB) return -1;
          if (nameA > nameB) return 1;
          return 0;
        });

        const agenciesSignature = agencies
          .map(a => `${a.url || ''}::${a.name || ''}`)
          .join('|');

        const routeSignatureParts = routeIDs.map(routeID => {
          const route = allRoutes[routeID] || {};
          const checked = Object.prototype.hasOwnProperty.call(routeSelections, routeID)
            ? routeSelections[routeID]
            : activeRoutesSet.has(routeID);
          const infoText = typeof route.InfoText === 'string' ? route.InfoText.trim() : '';
          const desc = typeof route.Description === 'string' ? route.Description.trim() : '';
          const color = route.MapLineColor || '';
          const hasActiveVehicle = activeRoutesSet.has(routeID);
          return `${routeID}:${checked ? 1 : 0}:${color}:${desc}:${infoText}:${hasActiveVehicle ? 1 : 0}`;
        });

        const catRoutesList = catOverlayEnabled ? getSortedCatRoutes() : [];
        const activeCatRouteKeysSet = catOverlayEnabled
          ? (catActiveRouteKeys instanceof Set ? new Set(catActiveRouteKeys) : new Set())
          : new Set();
        const catRouteRenderData = catRoutesList.map(route => {
          const key = catRouteKey(route.idKey);
          if (!key || key === CAT_OUT_OF_SERVICE_ROUTE_KEY) {
            return null;
          }
          const checked = getCatRouteSelectionState(key, activeCatRouteKeysSet);
          const hasActiveVehicle = activeCatRouteKeysSet.has(key);
          const displayNameRaw = (route.displayName || route.shortName || route.longName || key || '').trim();
          const displayName = displayNameRaw || `Route ${key}`;
          const longName = typeof route.longName === 'string' ? route.longName.trim() : '';
          const detailLines = [];
          if (longName && longName.toUpperCase() !== displayName.toUpperCase()) {
            detailLines.push(longName);
          }
          if (!hasActiveVehicle) {
            detailLines.push('No buses currently assigned');
          }
          const color = route.color || CAT_VEHICLE_MARKER_DEFAULT_COLOR;
          return {
            route,
            key,
            checked,
            hasActiveVehicle,
            displayName,
            detailLines,
            color
          };
        }).filter(Boolean);
        const catRouteSignatureParts = catRouteRenderData.map(entry => {
          const detailSignature = entry.detailLines.join('||');
          return `${entry.key}:${entry.checked ? 1 : 0}:${entry.color || ''}:${entry.displayName || ''}:${detailSignature}:${entry.hasActiveVehicle ? 1 : 0}`;
        });
        const catActiveSignature = Array.from(activeCatRouteKeysSet).sort().join('|');

        const outOfServiceChecked = adminMode && canDisplayRoute(0)
          ? (Object.prototype.hasOwnProperty.call(routeSelections, 0)
            ? routeSelections[0]
            : activeRoutesSet.has(0))
          : null;

        const signatureParts = [
          baseURL,
          adminMode ? '1' : '0',
          kioskMode ? '1' : '0',
          adminKioskMode ? '1' : '0',
          displayMode || '',
          agenciesSignature,
          outOfServiceChecked === null ? 'na' : (outOfServiceChecked ? '1' : '0'),
          routeSignatureParts.join('|'),
          catOverlayEnabled ? '1' : '0',
          `${catRouteRenderData.length}:${catRouteSignatureParts.join('|')}::${catActiveSignature}`
        ];

        const signature = signatureParts.join('||');
        if (!forceUpdate && signature === lastRouteSelectorSignature) {
          positionAllPanelTabs();
          return;
        }
        lastRouteSelectorSignature = signature;

        const previousContent = container.querySelector('.selector-content');
        const previousScrollTop = previousContent ? previousContent.scrollTop : 0;
        const activeElement = document.activeElement;
        const focusedElementId = activeElement && container.contains(activeElement) && activeElement.id
          ? activeElement.id
          : null;

        let html = `
          <div class="selector-header">
            <div class="selector-header-text">
              <div class="selector-title">Route Controls</div>
              <div class="selector-subtitle">Tailor the live map to the routes you care about.</div>
            </div>
          </div>
          <div class="selector-content">
            <div class="selector-section">
              <div class="selector-group selector-group--route-actions">
                <div class="selector-label">Select Routes</div>
                <div class="display-mode-group route-action-buttons">
                  <button type="button" class="pill-button" onclick="selectAllRoutes()">Select All</button>
                  <button type="button" class="pill-button" onclick="selectActiveRoutes()">Select Active</button>
                  <button type="button" class="pill-button" onclick="deselectAllRoutes()">Deselect All</button>
                </div>
              </div>
              <div class="route-list">
        `;

        if (adminMode && canDisplayRoute(0)) {
          let outChecked = Object.prototype.hasOwnProperty.call(routeSelections, 0) ? routeSelections[0] : activeRoutesSet.has(0);
          html += `
                <label class="route-option route-option--out">
                  <input type="checkbox" id="route_0" value="0" ${outChecked ? "checked" : ""}>
                  <span class="color-box route-option-swatch" style="background:${outOfServiceRouteColor};"></span>
                  <span class="route-option-text">
                    <span class="route-option-name">Out of Service</span>
                    <span class="route-option-detail">Vehicles without an assigned route</span>
                  </span>
                </label>
          `;
        }

        routeIDs.forEach(routeID => {
          const route = allRoutes[routeID] || {};
          const checked = Object.prototype.hasOwnProperty.call(routeSelections, routeID)
            ? routeSelections[routeID]
            : activeRoutesSet.has(routeID);
          const routeNameRaw = (route.Description || route.RouteName || '').trim();
          const routeName = routeNameRaw !== '' ? routeNameRaw : `Route ${route.RouteID || routeID}`;
          const infoText = typeof route.InfoText === 'string' ? route.InfoText.trim() : '';
          const hasActiveVehicle = activeRoutesSet.has(routeID);
          const detailLines = [];
          if (infoText) {
            detailLines.push(infoText);
          }
          if (!hasActiveVehicle) {
            detailLines.push('No buses currently assigned');
          }
          const detailHtml = detailLines.map(text => `<span class="route-option-detail">${text}</span>`).join('');
          const color = route.MapLineColor || '#A0AEC0';
          html += `
                <label class="route-option">
                  <input type="checkbox" id="route_${routeID}" value="${routeID}" ${checked ? "checked" : ""}>
                  <span class="color-box route-option-swatch" style="background:${color};"></span>
                  <span class="route-option-text">
                    <span class="route-option-name">${routeName}</span>
                    ${detailHtml}
                  </span>
                </label>
          `;
        });

        if (catRouteRenderData.length > 0) {
          html += `
                <div class="selector-label">CAT Routes</div>
          `;
          catRouteRenderData.forEach(entry => {
            const detailHtml = entry.detailLines.map(text => `<span class="route-option-detail">${escapeHtml(text)}</span>`).join('');
            const checkboxId = getCatRouteCheckboxId(entry.key);
            const safeValue = escapeAttribute(entry.key);
            const safeColor = escapeAttribute(entry.color || CAT_VEHICLE_MARKER_DEFAULT_COLOR);
            const safeName = escapeHtml(entry.displayName);
            html += `
                <label class="route-option route-option--cat">
                  <input type="checkbox" id="${checkboxId}" value="${safeValue}" ${entry.checked ? "checked" : ""}>
                  <span class="color-box route-option-swatch" style="background:${safeColor};"></span>
                  <span class="route-option-text">
                    <span class="route-option-name">${safeName}</span>
                    ${detailHtml}
                  </span>
                </label>
            `;
          });
        }

        html += `
              </div>
            </div>
          </div>
        `;

        container.innerHTML = html;

        const newContent = container.querySelector('.selector-content');
        if (newContent) {
          newContent.scrollTop = previousScrollTop;
        }
        if (focusedElementId) {
          const replacementElement = document.getElementById(focusedElementId);
          if (replacementElement && typeof replacementElement.focus === 'function') {
            try {
              replacementElement.focus({ preventScroll: true });
            } catch (error) {
              replacementElement.focus();
            }
          }
        }
        let outChk = document.getElementById("route_0");
        if (outChk) {
          outChk.addEventListener("change", function() {
            routeSelections[0] = outChk.checked;
            applyRouteOptionState(outChk);
            refreshMap();
          });
          applyRouteOptionState(outChk);
        }
        routeIDs.forEach(routeID => {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) return;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.addEventListener("change", function() {
              routeSelections[routeID] = chk.checked;
              applyRouteOptionState(chk);
              refreshMap();
            });
            applyRouteOptionState(chk);
          }
        });

        if (catRouteRenderData.length > 0) {
            catRouteRenderData.forEach(entry => {
              const checkboxId = getCatRouteCheckboxId(entry.key);
              const catCheckbox = document.getElementById(checkboxId);
              if (!catCheckbox) {
                return;
              }
              catCheckbox.checked = entry.checked;
              applyRouteOptionState(catCheckbox);
              catCheckbox.addEventListener('change', function() {
                catRouteSelections.set(entry.key, catCheckbox.checked);
                applyRouteOptionState(catCheckbox);
                renderCatVehiclesUsingCache();
                renderCatRoutes();
              });
            });
          }

        positionAllPanelTabs();
      }

      function selectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) {
            outChk.checked = true;
            applyRouteOptionState(outChk);
          }
          routeSelections[0] = true;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.checked = true;
            applyRouteOptionState(chk);
          }
          routeSelections[routeID] = true;
        }
        if (catOverlayEnabled) {
          const catRoutes = getUniqueCatRoutes();
          catRoutes.forEach(route => {
            const key = catRouteKey(route.idKey);
            if (!key) {
              return;
            }
            const checkboxId = getCatRouteCheckboxId(key);
            const catCheckbox = document.getElementById(checkboxId);
            if (catCheckbox) {
              catCheckbox.checked = true;
              applyRouteOptionState(catCheckbox);
            }
            catRouteSelections.set(key, true);
          });
          renderCatVehiclesUsingCache();
          renderCatRoutes();
        }
        refreshMap();
      }

      function selectActiveRoutes() {
        const activeSet = activeRoutes instanceof Set
          ? activeRoutes
          : new Set(Array.isArray(activeRoutes) ? activeRoutes : []);

        if (adminMode && canDisplayRoute(0)) {
          const outChk = document.getElementById("route_0");
          const shouldSelectOut = activeSet.has(0);
          if (outChk) {
            outChk.checked = shouldSelectOut;
            applyRouteOptionState(outChk);
          }
          routeSelections[0] = shouldSelectOut;
        }

        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          const numericRouteId = Number(routeID);
          const chk = document.getElementById("route_" + routeID);
          const shouldSelect = activeSet.has(numericRouteId);
          if (chk) {
            chk.checked = shouldSelect;
            applyRouteOptionState(chk);
          }
          routeSelections[numericRouteId] = shouldSelect;
        }

        if (catOverlayEnabled) {
          const activeCatKeys = catActiveRouteKeys instanceof Set ? new Set(catActiveRouteKeys) : new Set();
          const catRoutes = getUniqueCatRoutes();
          catRoutes.forEach(route => {
            const key = catRouteKey(route.idKey);
            if (!key) {
              return;
            }
            const shouldSelectCat = activeCatKeys.has(key);
            const checkboxId = getCatRouteCheckboxId(key);
            const catCheckbox = document.getElementById(checkboxId);
            if (catCheckbox) {
              catCheckbox.checked = shouldSelectCat;
              applyRouteOptionState(catCheckbox);
            }
            catRouteSelections.set(key, shouldSelectCat);
          });
          renderCatVehiclesUsingCache();
          renderCatRoutes();
        }

        refreshMap();
      }

      function deselectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) {
            outChk.checked = false;
            applyRouteOptionState(outChk);
          }
          routeSelections[0] = false;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.checked = false;
            applyRouteOptionState(chk);
          }
          routeSelections[routeID] = false;
        }
        if (catOverlayEnabled) {
          const catRoutes = getUniqueCatRoutes();
          catRoutes.forEach(route => {
            const key = catRouteKey(route.idKey);
            if (!key) {
              return;
            }
            const checkboxId = getCatRouteCheckboxId(key);
            const catCheckbox = document.getElementById(checkboxId);
            if (catCheckbox) {
              catCheckbox.checked = false;
              applyRouteOptionState(catCheckbox);
            }
            catRouteSelections.set(key, false);
          });
          renderCatVehiclesUsingCache();
          renderCatRoutes();
        }
        refreshMap();
      }

      function setPanelToggleArrow(tab, arrowHtml) {
        if (!tab) return;
        const arrowElement = tab.querySelector('.panel-toggle__arrow');
        if (arrowElement) {
          arrowElement.innerHTML = arrowHtml;
        } else {
          tab.innerHTML = arrowHtml;
        }
      }

      // togglePanelVisibility toggles the provided panel's visibility and updates its tab arrow.
      function togglePanelVisibility(panelId, tabId, expandedArrow, collapsedArrow) {
        const panel = document.getElementById(panelId);
        const tab = document.getElementById(tabId);
        if (!panel || !tab) return;
        const isHidden = panel.classList.toggle('hidden');
        setPanelToggleArrow(tab, isHidden ? collapsedArrow : expandedArrow);
        positionAllPanelTabs();
      }

      function toggleRoutePanel() {
        togglePanelVisibility('routeSelector', 'routeSelectorTab', '&#9664;', '&#9654;');
      }

      function toggleControlPanel() {
        togglePanelVisibility('controlPanel', 'controlPanelTab', '&#9654;', '&#9664;');
      }

      function shouldCollapsePanelsOnLoad() {
        return isCompactViewport();
      }

      function initializePanelStateForViewport() {
        if (!shouldCollapsePanelsOnLoad()) return;

        const controlPanel = document.getElementById('controlPanel');
        const controlTab = document.getElementById('controlPanelTab');
        const routePanel = document.getElementById('routeSelector');
        const routeTab = document.getElementById('routeSelectorTab');

        if (controlPanel && !controlPanel.classList.contains('hidden')) {
          controlPanel.classList.add('hidden');
        }
        if (controlTab) {
          setPanelToggleArrow(controlTab, '&#9664;');
        }

        if (routePanel && !routePanel.classList.contains('hidden')) {
          routePanel.classList.add('hidden');
        }
        if (routeTab) {
          setPanelToggleArrow(routeTab, '&#9654;');
        }

        positionAllPanelTabs();
      }

      function renderRouteLegendContent(legendElement, routes) {
        if (!legendElement) return;
        legendElement.style.display = "block";
        legendElement.innerHTML = "";

        const title = document.createElement("div");
        title.className = "legend-title";
        title.textContent = "Routes";
        legendElement.appendChild(title);

        routes.forEach(route => {
          const item = document.createElement("div");
          item.className = "legend-item";

          const color = document.createElement("span");
          color.className = "legend-color";
          color.style.backgroundColor = route.color;
          item.appendChild(color);

          const textContainer = document.createElement("div");
          textContainer.className = "legend-text";

          const name = document.createElement("div");
          name.className = "legend-name";
          name.textContent = route.name;
          textContainer.appendChild(name);

          if (route.description) {
            const description = document.createElement("div");
            description.className = "legend-description";
            description.textContent = route.description;
            textContainer.appendChild(description);
          }

          item.appendChild(textContainer);
          legendElement.appendChild(item);
        });
      }

      function createOutOfServiceLegendEntry() {
        return {
          routeId: 0,
          name: 'Out of Service',
          description: 'Vehicles without an assigned route',
          color: outOfServiceRouteColor
        };
      }

      function extractLegendRouteIdentifiers(route) {
        const rawRouteId = route && typeof route === 'object'
          ? (route.routeId ?? route.routeID ?? route.id ?? null)
          : null;
        const numericId = Number(rawRouteId);
        if (Number.isFinite(numericId)) {
          return {
            rawRouteId,
            numericId,
            stringId: null
          };
        }
        const stringId = rawRouteId !== null && rawRouteId !== undefined
          ? String(rawRouteId).trim()
          : '';
        return {
          rawRouteId,
          numericId: null,
          stringId
        };
      }

      function buildLegendRouteKey(route) {
        const identifiers = extractLegendRouteIdentifiers(route);
        if (Number.isFinite(identifiers.numericId)) {
          return `num:${identifiers.numericId}`;
        }
        if (identifiers.stringId) {
          return `str:${identifiers.stringId.toLowerCase()}`;
        }
        if (route && typeof route.name === 'string' && route.name.trim() !== '') {
          return `name:${route.name.trim().toLowerCase()}`;
        }
        return null;
      }

      function compareLegendRoutes(a, b) {
        const aIdentifiers = extractLegendRouteIdentifiers(a);
        const bIdentifiers = extractLegendRouteIdentifiers(b);
        const aHasNumeric = Number.isFinite(aIdentifiers.numericId);
        const bHasNumeric = Number.isFinite(bIdentifiers.numericId);
        if (aHasNumeric && bHasNumeric) {
          return aIdentifiers.numericId - bIdentifiers.numericId;
        }
        if (aHasNumeric) return -1;
        if (bHasNumeric) return 1;
        const aLabel = aIdentifiers.stringId || (typeof a?.name === 'string' ? a.name.trim() : '');
        const bLabel = bIdentifiers.stringId || (typeof b?.name === 'string' ? b.name.trim() : '');
        return aLabel.localeCompare(bLabel, undefined, { numeric: true, sensitivity: 'base' });
      }

      function mergeLegendRoutes(primaryRoutes, additionalRoutes) {
        const mergedMap = new Map();
        let autoKeyCounter = 0;

        const appendRoute = (route, shouldOverride = false) => {
          if (!route || typeof route !== 'object') return;
          const key = buildLegendRouteKey(route);
          const mapKey = key !== null ? key : `auto:${autoKeyCounter++}`;
          if (mergedMap.has(mapKey)) {
            if (shouldOverride) {
              mergedMap.set(mapKey, route);
            }
            return;
          }
          mergedMap.set(mapKey, route);
        };

        (Array.isArray(primaryRoutes) ? primaryRoutes : []).forEach(route => appendRoute(route, true));
        (Array.isArray(additionalRoutes) ? additionalRoutes : []).forEach(route => appendRoute(route, false));

        const mergedRoutes = Array.from(mergedMap.values());
        mergedRoutes.sort(compareLegendRoutes);
        return mergedRoutes;
      }

      function buildLegendEntryFromState(routeId) {
        const numericRouteId = Number(routeId);
        if (!Number.isFinite(numericRouteId)) return null;
        if (numericRouteId === 0) {
          return createOutOfServiceLegendEntry();
        }

        const storedRoute = allRoutes?.[numericRouteId] || allRoutes?.[`${numericRouteId}`] || {};
        const routeIdLabel = `${numericRouteId}`;

        const nameCandidates = [
          storedRoute.Description,
          storedRoute.Name,
          storedRoute.RouteName
        ];
        const legendName = nameCandidates.find(value => typeof value === 'string' && value.trim() !== '');
        const name = legendName ? legendName.trim() : (routeIdLabel ? `Route ${routeIdLabel}` : 'Route');

        const descriptionCandidates = [
          storedRoute.InfoText,
          storedRoute.Description,
          storedRoute.RouteDescription
        ];
        const legendDescription = descriptionCandidates.find(value => typeof value === 'string' && value.trim() !== '');
        const description = legendDescription ? legendDescription.trim() : '';

        const color = getRouteColor(numericRouteId);

        return {
          routeId: numericRouteId,
          name,
          description,
          color
        };
      }

      function deriveLegendRoutesFromState(options = {}) {
        const { includeAllAvailableRoutes = false } = options || {};
        const legendEntries = [];
        const seenRouteIds = new Set();

        const addRouteId = candidateId => {
          const numericRouteId = Number(candidateId);
          if (!Number.isFinite(numericRouteId)) return;
          if (seenRouteIds.has(numericRouteId)) return;
          if (!canDisplayRoute(numericRouteId)) return;
          if (!includeAllAvailableRoutes && !isRouteSelected(numericRouteId)) return;

          const legendEntry = buildLegendEntryFromState(numericRouteId);
          if (!legendEntry) return;

          seenRouteIds.add(numericRouteId);
          legendEntries.push(legendEntry);
        };

        if (includeAllAvailableRoutes) {
          Object.keys(allRoutes).forEach(routeIdKey => {
            if (!Object.prototype.hasOwnProperty.call(allRoutes, routeIdKey)) return;
            addRouteId(routeIdKey);
          });
        } else {
          if (activeRoutes instanceof Set) {
            activeRoutes.forEach(addRouteId);
          } else if (Array.isArray(activeRoutes)) {
            activeRoutes.forEach(addRouteId);
          }

          Object.keys(routeSelections).forEach(routeIdKey => {
            if (!Object.prototype.hasOwnProperty.call(routeSelections, routeIdKey)) return;
            if (!routeSelections[routeIdKey]) return;
            addRouteId(routeIdKey);
          });
        }

        legendEntries.sort((a, b) => a.routeId - b.routeId);

        return legendEntries;
      }

      function updateRouteLegend(displayedRoutes = [], options = {}) {
        const legend = document.getElementById("routeLegend");
        if (!legend) return;

        const { forceHide = false, preserveOnEmpty = false } = options || {};
        const shouldShowLegend = kioskMode || adminKioskMode;

        if (!shouldShowLegend || forceHide) {
          legend.style.display = "none";
          legend.innerHTML = "";
          lastRenderedLegendRoutes = [];
          return;
        }

        const normalizedRoutes = Array.isArray(displayedRoutes) ? displayedRoutes : [];
        const filteredRoutes = normalizedRoutes.filter(route => {
          const candidateId = route?.routeId ?? route?.routeID ?? route?.id;
          if (adminKioskMode) {
            return routeHasActiveVehicles(candidateId);
          }
          return isRoutePublicById(candidateId);
        });

        const sanitizedRoutes = filteredRoutes.map(route => {
          const rawRouteId = route.routeId ?? route.routeID ?? route.id;
          const routeIdLabel = rawRouteId === undefined || rawRouteId === null ? "" : `${rawRouteId}`;
          const rawName = typeof route.name === "string" ? route.name : "";
          const name = rawName.trim() !== "" ? rawName.trim() : (routeIdLabel ? `Route ${routeIdLabel}` : "Route");
          const rawDescription = typeof route.description === "string" ? route.description : "";
          const description = rawDescription.trim();
          const color = typeof route.color === "string" && route.color.trim() !== "" ? route.color : "#000000";
          return {
            routeId: rawRouteId,
            name,
            description,
            color
          };
        });

        const shouldIncludeOutOfServiceLegend = isRouteSelected(0) && routeHasActiveVehicles(0);
        if (shouldIncludeOutOfServiceLegend) {
          const hasOutOfServiceEntry = sanitizedRoutes.some(route => {
            const candidateId = route?.routeId ?? route?.routeID ?? route?.id;
            return Number(candidateId) === 0;
          });
          if (!hasOutOfServiceEntry) {
            sanitizedRoutes.push(createOutOfServiceLegendEntry());
          }
        }

        const filterAdminLegendRoutes = routes => {
          if (!adminKioskMode) {
            return Array.isArray(routes) ? routes : [];
          }
          if (!Array.isArray(routes)) return [];
          return routes.filter(route => {
            const candidateId = route?.routeId ?? route?.routeID ?? route?.id;
            return routeHasActiveVehicles(candidateId);
          });
        };

        let routesToRender = filterAdminLegendRoutes(sanitizedRoutes);

        if (routesToRender.length === 0) {
          let fallbackRoutes = deriveLegendRoutesFromState({
            includeAllAvailableRoutes: adminKioskMode
          });
          fallbackRoutes = filterAdminLegendRoutes(fallbackRoutes);
          if (fallbackRoutes.length > 0) {
            routesToRender = fallbackRoutes;
          } else if (preserveOnEmpty && lastRenderedLegendRoutes.length > 0) {
            renderRouteLegendContent(legend, lastRenderedLegendRoutes);
            return;
          } else {
            legend.style.display = "none";
            legend.innerHTML = "";
            lastRenderedLegendRoutes = [];
            return;
          }
        } else if (adminKioskMode) {
          let additionalRoutes = deriveLegendRoutesFromState({ includeAllAvailableRoutes: true });
          additionalRoutes = filterAdminLegendRoutes(additionalRoutes);
          if (additionalRoutes.length > 0) {
            routesToRender = mergeLegendRoutes(routesToRender, additionalRoutes);
          }
          routesToRender = filterAdminLegendRoutes(routesToRender);
        }

        if (routesToRender.length === 0) {
          if (preserveOnEmpty && lastRenderedLegendRoutes.length > 0) {
            renderRouteLegendContent(legend, lastRenderedLegendRoutes);
          } else {
            legend.style.display = "none";
            legend.innerHTML = "";
            lastRenderedLegendRoutes = [];
          }
          return;
        }

        lastRenderedLegendRoutes = routesToRender;
        renderRouteLegendContent(legend, routesToRender);
      }

      // refreshMap updates route paths and bus locations.
      function refreshMap() {
        fetchBusLocations().then(fetchRoutePaths);
        if (Array.isArray(stopDataCache) && stopDataCache.length > 0) {
          renderBusStops(stopDataCache);
        }
        fetchTrains().catch(error => console.error('Error refreshing trains:', error));
        if (catOverlayEnabled) {
          renderCatVehiclesUsingCache();
        }
      }

      function clearRefreshIntervals() {
        refreshIntervals.forEach(clearInterval);
        refreshIntervals = [];
      }

      function startRefreshIntervals() {
        refreshIntervals.push(setInterval(fetchBusLocations, 4000));
        refreshIntervals.push(setInterval(fetchBusStops, 60000));
        refreshIntervals.push(setInterval(fetchBlockAssignments, 60000));
        refreshIntervals.push(setInterval(() => {
          fetchStopArrivalTimes().then(allEtas => {
            cachedEtas = allEtas;
            updateCustomPopups();
          });
        }, 15000));
        refreshIntervals.push(setInterval(fetchRoutePaths, 15000));
        refreshIntervals.push(setInterval(() => {
          if (shouldFetchServiceAlerts()) {
            fetchServiceAlertsForCurrentAgency();
          }
        }, SERVICE_ALERT_REFRESH_INTERVAL_MS));
        if (incidentsAreAvailable()) {
          refreshIntervals.push(setInterval(refreshIncidents, INCIDENT_REFRESH_INTERVAL_MS));
          refreshIncidents();
        } else {
          setIncidentsVisibility(false);
        }
        refreshIntervals.push(setInterval(() => {
          fetchTrains().catch(error => console.error('Failed to fetch trains:', error));
        }, TRAIN_POLL_INTERVAL_MS));
        fetchTrains().catch(error => console.error('Failed to fetch trains:', error));
        if (shouldFetchServiceAlerts()) {
          fetchServiceAlertsForCurrentAgency();
        }
      }

      function showCookieBanner() {
        if (kioskMode || adminKioskMode) {
          return;
        }
        if (localStorage.getItem('agencyConsent') !== 'true') {
          const banner = document.getElementById('cookieBanner');
          banner.style.display = 'block';
          document.getElementById('cookieAccept').addEventListener('click', () => {
            localStorage.setItem('agencyConsent', 'true');
            localStorage.setItem('selectedAgency', baseURL);
            banner.style.display = 'none';
          });
        }
      }

      function loadAgencyData() {
        return fetchRouteColors().then(() => {
          const stopArrivalsPromise = fetchStopArrivalTimes().then(allEtas => {
            cachedEtas = allEtas || {};
            updateCustomPopups();
            return allEtas;
          });
          const headingCachePromise = loadVehicleHeadingCache();
          const tasks = [
            fetchBusStops(),
            fetchBlockAssignments(),
            headingCachePromise.then(() => fetchBusLocations().then(() => fetchRoutePaths())),
            stopArrivalsPromise
          ];
          if (shouldFetchServiceAlerts()) {
            tasks.push(fetchServiceAlertsForCurrentAgency());
          }
          return Promise.allSettled(tasks);
        });
      }

      function changeAgency(url) {
        if (localStorage.getItem('agencyConsent') === 'true') {
          localStorage.setItem('selectedAgency', url);
        }
        beginAgencyLoad();
        clearRefreshIntervals();
        baseURL = url;
        resetIncidentAlertState();
        resetServiceAlertsState();
        updateControlPanel();
        enforceIncidentVisibilityForCurrentAgency();
        Object.values(markers).forEach(m => map.removeLayer(m));
        markers = {};
        clearAllTrainMarkers();
        Object.values(nameBubbles).forEach(b => {
          if (b.speedMarker) map.removeLayer(b.speedMarker);
          if (b.nameMarker) map.removeLayer(b.nameMarker);
          if (b.blockMarker) map.removeLayer(b.blockMarker);
        });
        nameBubbles = {};
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
        routeLayers.forEach(l => map.removeLayer(l));
        routeLayers = [];
        routePolylineCache.clear();
        lastRouteRenderState = {
          selectionKey: '',
          colorSignature: '',
          geometrySignature: '',
          useOverlapRenderer: !!(enableOverlapDashRendering && overlapRenderer)
        };
        lastRouteSelectorSignature = null;
        if (overlapRenderer) {
          overlapRenderer.reset();
        }
        currentTranslocRendererGeometries = new Map();
        currentTranslocSelectedRouteIds = [];
        resetCatOverlapRenderingState();
        busBlocks = {};
        previousBusData = {};
        cachedEtas = {};
        customPopups.forEach(p => p.remove());
        customPopups = [];
        allRoutes = {};
        routeSelections = {};
        routeStopAddressMap = {};
        routeStopRouteMap = {};
        activeRoutes = new Set();
        routeColors = {};
        routeVisibility = {};
        allRouteBounds = null;
        mapHasFitAllRoutes = false;
        updateRouteLegend([], { forceHide: true });
        updateRouteSelector(new Set(), true);
        loadAgencyData()
          .then(() => {
            startRefreshIntervals();
          })
          .catch(error => {
            console.error('Error loading agency data:', error);
          })
          .finally(() => {
            completeAgencyLoad();
          });
      }

      function getRouteColor(routeID) {
        if (routeID === 0) return outOfServiceRouteColor;
        const numeric = Number(routeID);
        if (!Number.isNaN(numeric) && isCatOverlapRouteId(numeric)) {
          const info = catOverlapInfoByNumericId.get(numeric);
          if (info && info.color) {
            return info.color;
          }
          if (info && info.routeKey) {
            const fallbackColor = sanitizeCssColor(getCatRouteColor(info.routeKey));
            if (fallbackColor) {
              return fallbackColor;
            }
          }
          return CAT_VEHICLE_MARKER_DEFAULT_COLOR;
        }
        return routeColors[routeID] || '#000000';
      }

      function initMap() {
          map = L.map('map', {
              zoomControl: false,
              crs: L.CRS.EPSG3857,
              zoomAnimation: true,
              markerZoomAnimation: true
          }).setView([38.03799212281404, -78.50981502838886], 15);
          map.createPane(RADAR_PANE_NAME);
          const radarPane = map.getPane(RADAR_PANE_NAME);
          if (radarPane) {
              radarPane.style.zIndex = 350;
              radarPane.style.pointerEvents = 'none';
          }
          sharedRouteRenderer = L.svg({ padding: 0 });
          if (sharedRouteRenderer) {
              map.addLayer(sharedRouteRenderer);
          }
          map.createPane('stopsPane');
          const stopsPane = map.getPane('stopsPane');
          if (stopsPane) {
              stopsPane.style.zIndex = 450;
              stopsPane.style.pointerEvents = 'auto';
          }
          map.createPane('busesPane');
          const busesPane = map.getPane('busesPane');
          if (busesPane) {
              busesPane.style.zIndex = 500;
              busesPane.style.pointerEvents = 'auto';
          }
          map.createPane(catVehiclesPaneName);
          const catPane = map.getPane(catVehiclesPaneName);
          if (catPane) {
              catPane.style.zIndex = 505;
              catPane.style.pointerEvents = 'auto';
          }
          map.createPane('incidentHalosPane');
          const incidentHalosPane = map.getPane('incidentHalosPane');
          if (incidentHalosPane) {
              incidentHalosPane.style.zIndex = 540;
              incidentHalosPane.style.pointerEvents = 'none';
          }
          map.createPane('incidentsPane');
          const incidentsPane = map.getPane('incidentsPane');
          if (incidentsPane) {
              incidentsPane.style.zIndex = 550;
              incidentsPane.style.pointerEvents = 'auto';
          }
          incidentLayerGroup = L.layerGroup();
          incidentMarkers.forEach(entry => {
              if (entry && entry.marker) {
                  incidentLayerGroup.addLayer(entry.marker);
              }
          });
          if (incidentsVisible) {
              incidentLayerGroup.addTo(map);
          }
          if (!incidentHaloLayerGroup) {
              incidentHaloLayerGroup = L.layerGroup();
          }
          incidentMarkers.forEach(entry => {
              if (entry && entry.haloMarker) {
                  incidentHaloLayerGroup.addLayer(entry.haloMarker);
              }
          });
          if (incidentsVisible && incidentHaloLayerGroup) {
              incidentHaloLayerGroup.addTo(map);
          }
          const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
          });
          cartoLight.addTo(map);
          applyRadarState();

          if (enableOverlapDashRendering) {
            overlapRenderer = new OverlapRouteRenderer(map, {
              sampleStepPx: 8,
              dashLengthPx: 16,
              minDashLengthPx: 0.5,
              matchTolerancePx: 6,
              strokeWeight: DEFAULT_ROUTE_STROKE_WEIGHT,
              minStrokeWeight: MIN_ROUTE_STROKE_WEIGHT,
              maxStrokeWeight: MAX_ROUTE_STROKE_WEIGHT,
              renderer: sharedRouteRenderer,
              pane: routePaneName
            });
            map.on('zoomend', () => {
              if (overlapRenderer) {
                overlapRenderer.handleZoomEnd();
              }
            });
          }

          if (kioskMode || adminKioskMode) {
            document.getElementById("routeSelector").style.display = "none";
            document.getElementById("routeSelectorTab").style.display = "none";
            const controlPanel = document.getElementById("controlPanel");
            if (controlPanel) {
              controlPanel.style.display = "none";
            }
            const controlPanelTab = document.getElementById("controlPanelTab");
            if (controlPanelTab) {
              controlPanelTab.style.display = "none";
            }
          }
          map.on('zoom', () => {
              scheduleMarkerScaleUpdate();
              updatePopupPositions();
          });
          map.on('move', () => {
              updatePopupPositions();
          });
          map.on('moveend', () => {
              updateTrainMarkersVisibility().catch(error => console.error('Error updating train markers visibility:', error));
          });
          map.on('zoomend', () => {
              if (stopDataCache.length > 0) {
                  renderBusStops(stopDataCache);
              }
              scheduleMarkerScaleUpdate();
              updatePopupPositions();
              renderCatRoutes();
              updateTrainMarkersVisibility().catch(error => console.error('Error updating train markers visibility:', error));
          });
          if (planesVisible && window.PlaneLayer && typeof window.PlaneLayer.init === 'function') {
              try {
                  window.PlaneLayer.init(map);
              } catch (error) {
                  console.error('PlaneLayer init failed:', error);
                  planesVisible = false;
                  updateAircraftToggleButton();
              }
          }
          applyIncidentHaloStates();
      }

      function fetchBusStops() {
          const currentBaseURL = baseURL;
          const stopsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStops?APIKey=8882812681`;
          return fetch(stopsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  let stopsArray = data.stops || data;
                  if (stopsArray && Array.isArray(stopsArray)) {
                      stopDataCache = stopsArray;
                      renderBusStops(stopDataCache);
                  }
              })
              .catch(error => console.error("Error fetching bus stops:", error));
      }

      function groupStopsByPixelDistance(stops, thresholdPx) {
          if (!Array.isArray(stops) || stops.length === 0) {
              return [];
          }

          const validStops = stops.map(stop => {
              const latitude = parseFloat(stop.Latitude ?? stop.latitude ?? stop.lat);
              const longitude = parseFloat(stop.Longitude ?? stop.longitude ?? stop.lon);
              if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
                  return null;
              }
              return { latitude, longitude, stop };
          }).filter(entry => entry !== null);

          if (!map) {
              return validStops.map(entry => ({
                  latitude: entry.latitude,
                  longitude: entry.longitude,
                  stops: [entry.stop]
              }));
          }

          const groups = [];
          validStops.forEach(({ latitude, longitude, stop }) => {
              const stopPoint = map.latLngToLayerPoint([latitude, longitude]);
              let targetGroup = null;
              for (const group of groups) {
                  const groupPoint = map.latLngToLayerPoint([group.latitude, group.longitude]);
                  if (stopPoint.distanceTo(groupPoint) <= thresholdPx) {
                      targetGroup = group;
                      break;
                  }
              }
              if (targetGroup) {
                  targetGroup.stops.push(stop);
                  const totalStops = targetGroup.stops.length;
                  targetGroup.latitude = (targetGroup.latitude * (totalStops - 1) + latitude) / totalStops;
                  targetGroup.longitude = (targetGroup.longitude * (totalStops - 1) + longitude) / totalStops;
              } else {
                  groups.push({
                      latitude,
                      longitude,
                      stops: [stop]
                  });
              }
          });

          return groups;
      }

      function sanitizeStopName(name) {
          if (typeof name !== 'string') {
              return '';
          }
          return name.replace(/^Stop Name:\s*/i, '').trim();
      }

      function normalizeIdentifier(value) {
          if (value === undefined || value === null) {
              return null;
          }
          const str = `${value}`.trim();
          return str === '' ? null : str;
      }

      function getSelectedRouteIdSet() {
          const selected = new Set();
          Object.keys(allRoutes).forEach(routeId => {
              const numericId = Number(routeId);
              if (!Number.isNaN(numericId) && isRouteSelected(numericId)) {
                  selected.add(numericId);
              }
          });
          return selected;
      }

      function buildStopEntriesFromStops(stops) {
          if (!Array.isArray(stops)) {
              return [];
          }

          const entriesByKey = new Map();
          stops.forEach(stop => {
              if (!stop) {
                  return;
              }

              const latitude = stop.Latitude ?? stop.latitude ?? stop.lat;
              const longitude = stop.Longitude ?? stop.longitude ?? stop.lon;
              const routeStopId = normalizeIdentifier(stop.RouteStopID ?? stop.RouteStopId);
              const addressIdFromStop = normalizeIdentifier(stop.AddressID ?? stop.AddressId);
              const addressIdFromMap = routeStopId ? normalizeIdentifier(routeStopAddressMap[routeStopId]) : null;
              const fallbackStopId = normalizeIdentifier(stop.StopID ?? stop.StopId);

              const key = addressIdFromStop
                  || addressIdFromMap
                  || (routeStopId ? `ROUTESTOP_${routeStopId}`
                      : (fallbackStopId ? `STOP_${fallbackStopId}`
                          : `LOC_${latitude}_${longitude}`));

              if (!entriesByKey.has(key)) {
                  entriesByKey.set(key, {
                      addressId: addressIdFromStop || addressIdFromMap || null,
                      routeStopIds: new Set(),
                      stopIds: new Set(),
                      names: new Set(),
                      routeIds: new Set()
                  });
              }

              const entry = entriesByKey.get(key);

              if (routeStopId) {
                  entry.routeStopIds.add(routeStopId);
              }

              if (fallbackStopId) {
                  entry.stopIds.add(fallbackStopId);
              }

              const descriptionCandidates = [
                  stop.Description,
                  stop.Name,
                  stop.StopName,
                  stop.Line1,
                  stop.SignVerbiage
              ];
              const name = descriptionCandidates.find(value => typeof value === 'string' && value.trim() !== '');
              if (name) {
                  entry.names.add(sanitizeStopName(name));
              }

              const routeIdRaw = stop.RouteID ?? stop.RouteId;
              const routeIdNumeric = Number(routeIdRaw);
              if (!Number.isNaN(routeIdNumeric)) {
                  entry.routeIds.add(routeIdNumeric);
              }

              const routesArray = Array.isArray(stop.Routes) ? stop.Routes : [];
              routesArray.forEach(routeInfo => {
                  const candidateRouteId = Number(routeInfo?.RouteID ?? routeInfo?.RouteId ?? routeInfo?.Id);
                  if (!Number.isNaN(candidateRouteId)) {
                      entry.routeIds.add(candidateRouteId);
                  }
              });

              const routeIdsList = Array.isArray(stop.RouteIDs ?? stop.RouteIds)
                  ? (stop.RouteIDs ?? stop.RouteIds)
                  : [];
              routeIdsList.forEach(routeIdValue => {
                  const numericRouteId = Number(routeIdValue);
                  if (!Number.isNaN(numericRouteId)) {
                      entry.routeIds.add(numericRouteId);
                  }
              });
          });

          return Array.from(entriesByKey.values()).map(entry => ({
              addressId: entry.addressId,
              routeStopIds: Array.from(entry.routeStopIds),
              stopIdText: Array.from(entry.stopIds).join(', '),
              displayName: entry.names.size > 0 ? Array.from(entry.names).join(' / ') : 'Stop',
              routeIds: Array.from(entry.routeIds)
          }));
      }

      function collectRouteIdsForEntry(entry) {
          const routeIds = new Set();
          if (!entry) {
              return routeIds;
          }
          if (Array.isArray(entry.routeIds)) {
              entry.routeIds.forEach(routeId => {
                  const numeric = Number(routeId);
                  if (!Number.isNaN(numeric)) {
                      routeIds.add(numeric);
                  }
              });
          }
          if (Array.isArray(entry.routeStopIds)) {
              entry.routeStopIds.forEach(routeStopId => {
                  const mapped = routeStopRouteMap[routeStopId];
                  const numeric = Number(mapped);
                  if (!Number.isNaN(numeric)) {
                      routeIds.add(numeric);
                  }
              });
          }
          return routeIds;
      }

      function collectRouteIdsForStop(stop) {
          const routeIds = new Set();
          if (!stop) {
              return routeIds;
          }

          const addRouteId = value => {
              if (value === undefined || value === null) {
                  return;
              }
              let candidate = value;
              if (typeof candidate === 'string') {
                  candidate = candidate.trim();
                  if (candidate === '') {
                      return;
                  }
              }
              const numericRouteId = Number(candidate);
              if (!Number.isNaN(numericRouteId)) {
                  routeIds.add(numericRouteId);
              }
          };

          addRouteId(stop.RouteID ?? stop.RouteId);

          const routeStopId = normalizeIdentifier(stop.RouteStopID ?? stop.RouteStopId);
          if (routeStopId) {
              addRouteId(routeStopRouteMap[routeStopId]);
          }

          const routeIdsList = Array.isArray(stop.RouteIDs ?? stop.RouteIds)
              ? (stop.RouteIDs ?? stop.RouteIds)
              : [];
          routeIdsList.forEach(routeIdValue => addRouteId(routeIdValue));

          const routesArray = Array.isArray(stop.Routes) ? stop.Routes : [];
          routesArray.forEach(routeInfo => {
              addRouteId(routeInfo?.RouteID ?? routeInfo?.RouteId ?? routeInfo?.Id ?? routeInfo);
          });

          const singleRoute = stop.Route ?? stop.route;
          if (singleRoute && typeof singleRoute === 'object') {
              addRouteId(singleRoute.RouteID ?? singleRoute.RouteId ?? singleRoute.Id);
          }

          return routeIds;
      }

      function buildStopMarkerGradient(routeIds) {
          const colors = Array.from(new Set((Array.isArray(routeIds) ? routeIds : [])
              .map(routeId => getRouteColor(routeId))
              .filter(color => typeof color === 'string' && color.trim() !== '')));

          if (colors.length === 0) {
              return '#FFFFFF';
          }
          if (colors.length === 1) {
              return colors[0];
          }

          const segmentSize = 360 / colors.length;
          const segments = colors.map((color, index) => {
              const start = segmentSize * index;
              const end = segmentSize * (index + 1);
              return `${color} ${start}deg ${end}deg`;
          });
          return `conic-gradient(${segments.join(', ')})`;
      }

      function createStopMarkerIcon(routeIds) {
          const gradient = buildStopMarkerGradient(routeIds);
          const size = STOP_MARKER_ICON_SIZE;
          const outline = Math.max(0, Number(STOP_MARKER_OUTLINE_WIDTH) || 0);
          const html = `<div class="stop-marker-outer" style="--stop-marker-size:${size}px;--stop-marker-border-color:${STOP_MARKER_BORDER_COLOR};--stop-marker-outline-size:${outline}px;--stop-marker-outline-color:${STOP_MARKER_OUTLINE_COLOR};--stop-marker-gradient:${gradient};"></div>`;
          return L.divIcon({
              className: 'stop-marker-container leaflet-div-icon',
              html,
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2]
          });
      }

      function createStopGroupKey(routeStopIds, fallbackStopIdText) {
          const normalizedIds = Array.isArray(routeStopIds)
              ? Array.from(new Set(routeStopIds
                  .map(id => `${id}`)
                  .map(value => value.trim())
                  .filter(value => value !== '' && value.toLowerCase() !== 'undefined' && value.toLowerCase() !== 'null')))
                  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
              : [];
          return `${JSON.stringify(normalizedIds)}|${fallbackStopIdText || ''}`;
      }

      function sanitizeCssColor(color) {
          if (typeof color !== 'string') {
              return '';
          }
          let trimmed = color.trim();
          if (trimmed.length === 0) {
              return '';
          }
          if (/^#[0-9a-fA-F]{3,8}$/.test(trimmed)) {
              return trimmed;
          }
          if (/^[0-9a-fA-F]{3,8}$/.test(trimmed)) {
              return `#${trimmed}`;
          }
          if (/^rgba?\(\s*\d+(?:\.\d+)?\s*,\s*\d+(?:\.\d+)?\s*,\s*\d+(?:\.\d+)?(?:\s*,\s*(?:0|1|0?\.\d+))?\s*\)$/i.test(trimmed)) {
              return trimmed.replace(/\s+/g, ' ');
          }
          if (/^hsla?\(\s*\d+(?:\.\d+)?(?:deg|rad|turn)?\s*,\s*\d+(?:\.\d+)?%\s*,\s*\d+(?:\.\d+)?%(?:\s*,\s*(?:0|1|0?\.\d+))?\s*\)$/i.test(trimmed)) {
              return trimmed.replace(/\s+/g, ' ');
          }
          if (/^[a-zA-Z]+$/.test(trimmed)) {
              return trimmed;
          }
          return '';
      }

      function getColorWithAlpha(color, alpha) {
          const safeAlpha = Math.min(1, Math.max(0, Number(alpha) || 0));
          if (typeof color !== 'string' || color.trim() === '') {
              return `rgba(0, 0, 0, ${safeAlpha})`;
          }

          const trimmed = color.trim();
          if (trimmed.startsWith('#')) {
              let hex = trimmed.slice(1);
              if (hex.length === 3 || hex.length === 4) {
                  hex = hex.split('').map(char => char + char).join('');
              }
              if (hex.length === 6 || hex.length === 8) {
                  const r = parseInt(hex.slice(0, 2), 16);
                  const g = parseInt(hex.slice(2, 4), 16);
                  const b = parseInt(hex.slice(4, 6), 16);
                  const baseAlpha = hex.length === 8 ? parseInt(hex.slice(6, 8), 16) / 255 : 1;
                  if ([r, g, b, baseAlpha].some(value => Number.isNaN(value))) {
                      return `rgba(0, 0, 0, ${safeAlpha})`;
                  }
                  const combinedAlpha = Math.round(Math.min(1, Math.max(0, baseAlpha * safeAlpha)) * 1000) / 1000;
                  return `rgba(${r}, ${g}, ${b}, ${combinedAlpha})`;
              }
          } else {
              const rgbaMatch = trimmed.match(/rgba?\(([^)]+)\)/i);
              if (rgbaMatch) {
                  const parts = rgbaMatch[1].split(',').map(part => part.trim());
                  if (parts.length >= 3) {
                      const r = parseFloat(parts[0]);
                      const g = parseFloat(parts[1]);
                      const b = parseFloat(parts[2]);
                      if ([r, g, b].some(value => Number.isNaN(value))) {
                          return `rgba(0, 0, 0, ${safeAlpha})`;
                      }
                      let baseAlpha = parts.length >= 4 ? parseFloat(parts[3]) : 1;
                      if (Number.isNaN(baseAlpha)) {
                          baseAlpha = 1;
                      }
                      const combinedAlpha = Math.round(Math.min(1, Math.max(0, baseAlpha * safeAlpha)) * 1000) / 1000;
                      return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${combinedAlpha})`;
                  }
              }
          }

          return `rgba(0, 0, 0, ${safeAlpha})`;
      }

      function buildEtaTableHtml(routeStopIds) {
          const normalizedRouteStopIds = Array.isArray(routeStopIds) ? routeStopIds : [];
          const etas = [];
          normalizedRouteStopIds.forEach(routeStopId => {
              if (cachedEtas[routeStopId]) {
                  cachedEtas[routeStopId].forEach(eta => etas.push(eta));
              }
          });
          const etaRows = etas.length > 0
              ? etas.sort((a, b) => a.etaMinutes - b.etaMinutes || a.routeDescription.localeCompare(b.routeDescription))
                    .map(eta => {
                        const routeColor = getRouteColor(eta.RouteId);
                        const textColor = contrastBW(routeColor);
                        const shadowColor = getColorWithAlpha(routeColor, 0.35);
                        return `<tr><td style="padding: 5px; text-align: center;"><div class="route-pill" style="background: ${routeColor}; color: ${textColor}; --route-pill-shadow-color: ${shadowColor};">${eta.routeDescription}</div></td><td style="padding: 5px; text-align: center;">${eta.etaMinutes < 1 ? 'Arriving' : eta.etaMinutes + ' min'}</td></tr>`;
                    })
                    .join('')
              : '<tr><td colspan="2" style="padding: 5px; text-align: center;">No upcoming arrivals</td></tr>';
          return `
            <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
              <thead>
                <tr>
                  <th style="border-bottom: 1px solid white; padding: 5px;">Route</th>
                  <th style="border-bottom: 1px solid white; padding: 5px;">ETA</th>
                </tr>
              </thead>
              <tbody>
                ${etaRows}
              </tbody>
            </table>
          `;
      }

      function buildStopEntriesSectionHtml(stopEntries, multipleStops) {
          if (!Array.isArray(stopEntries) || stopEntries.length === 0) {
              return '<div style="margin-top: 10px;">No upcoming arrivals</div>';
          }

          if (!multipleStops) {
              const entry = stopEntries[0];
              return buildEtaTableHtml(entry?.routeStopIds || []);
          }

          return stopEntries.map(entry => {
              const entryTitle = entry.displayName ? `<span class="stop-entry-title">${sanitizeStopName(entry.displayName)}</span>` : '';
              const entryIdLine = entry.stopIdText ? `<span class="stop-entry-id">Stop ID: ${entry.stopIdText}</span>` : '';
              const entryAddressIdText = normalizeIdentifier(entry?.addressId);
              const entryAddressLine = entryAddressIdText ? `<span class="stop-entry-id">Stop ID: ${entryAddressIdText}</span>` : '';
              const tableHtml = buildEtaTableHtml(entry.routeStopIds || []);
              return `<div class="stop-entry">${entryTitle}${entryIdLine}${entryAddressLine}${tableHtml}</div>`;
          }).join('');
      }

      function attachPopupCloseHandler(popupElement) {
          const closeButton = popupElement.querySelector('.custom-popup-close');
          if (!closeButton) {
              return;
          }
          closeButton.addEventListener('click', () => {
              popupElement.remove();
              customPopups = customPopups.filter(popup => popup !== popupElement);
          });
      }

      function setStopPopupContent(popupElement, groupInfo) {
          if (!popupElement || !groupInfo) {
              return;
          }

          popupElement.dataset.popupType = 'stop';
          const stopEntries = Array.isArray(groupInfo.stopEntries) ? groupInfo.stopEntries : [];
          const aggregatedRouteStopIds = Array.isArray(groupInfo.aggregatedRouteStopIds)
              ? groupInfo.aggregatedRouteStopIds
              : [];
          const fallbackStopIdText = typeof groupInfo.fallbackStopId === 'string'
              ? groupInfo.fallbackStopId
              : normalizeIdentifier(groupInfo.fallbackStopId) || '';
          const sanitizedStopName = sanitizeStopName(groupInfo.stopName || '');
          const multipleStops = stopEntries.length > 1;
          const primaryStopIdText = !multipleStops
              ? (stopEntries[0]?.stopIdText || fallbackStopIdText)
              : '';
          const entriesHtml = buildStopEntriesSectionHtml(stopEntries, multipleStops);
          const groupKey = groupInfo.groupKey || createStopGroupKey(aggregatedRouteStopIds, fallbackStopIdText);
          const primaryAddressIdText = !multipleStops
              ? normalizeIdentifier(stopEntries[0]?.addressId)
              : '';

          popupElement.dataset.routeStopIds = JSON.stringify(aggregatedRouteStopIds);
          popupElement.dataset.stopEntries = JSON.stringify(stopEntries);
          popupElement.dataset.stopName = sanitizedStopName;
          popupElement.dataset.fallbackStopId = fallbackStopIdText;
          popupElement.dataset.stopId = primaryStopIdText || '';
          popupElement.dataset.addressId = primaryAddressIdText || '';
          popupElement.dataset.groupKey = groupKey;

          const stopNameLine = (!multipleStops && sanitizedStopName)
              ? `<span class="stop-entry-title">${sanitizedStopName}</span><br>`
              : '';
          const addressIdLine = primaryAddressIdText ? `<span class="stop-entry-id">Address ID: ${primaryAddressIdText}</span><br>` : '';
          const stopIdLine = primaryStopIdText ? `<span class="stop-entry-id">Stop ID: ${primaryStopIdText}</span><br>` : '';

          popupElement.innerHTML = `
            <button class="custom-popup-close">&times;</button>
            ${stopNameLine}
            ${addressIdLine}
            ${stopIdLine}
            ${entriesHtml}
            <div class="custom-popup-arrow"></div>
          `;

          attachPopupCloseHandler(popupElement);
      }

      function getIncidentLocationText(incident) {
          if (!incident) return '';
          const candidates = [
              incident.FullDisplayAddress,
              incident.DisplayAddress,
              incident.Address,
              incident.AddressName,
              incident.IncidentAddress,
              incident.LocationDescription,
              incident.Location,
              incident.CrossStreet,
              incident.Intersection,
              incident.NearestIntersection,
              incident.CommonName,
              incident.CommonLocation
          ];
          for (const value of candidates) {
              if (typeof value !== 'string') continue;
              const trimmed = value.trim();
              if (trimmed) {
                  return trimmed;
              }
          }
          return '';
      }

      function setIncidentPopupContent(popupElement, config) {
          if (!popupElement) {
              return;
          }

          popupElement.dataset.popupType = 'incident';
          const incident = config && config.incident ? config.incident : null;
          const idValue = typeof config?.id === 'string'
              ? config.id
              : (typeof config?.incidentId === 'string' ? config.incidentId : '');
          if (idValue) {
              popupElement.dataset.incidentId = idValue;
          } else {
              delete popupElement.dataset.incidentId;
          }

          if (!incident) {
              popupElement.innerHTML = `
                <button class="custom-popup-close">&times;</button>
                <div class="incident-popup">
                  <div>Incident information is unavailable.</div>
                </div>
                <div class="custom-popup-arrow"></div>
              `;
              attachPopupCloseHandler(popupElement);
              return;
          }

          const typeLabel = getIncidentTypeLabel(incident) || 'Incident';
          const safeTypeLabel = escapeHtml(typeLabel);
          const iconUrl = buildPulsePointListIconUrl(getIncidentTypeCode(incident));
          const iconAlt = typeLabel ? `${typeLabel} icon` : 'Incident icon';
          const iconHtml = iconUrl
              ? `<div class="incident-popup__icon"><img src="${escapeAttribute(iconUrl)}" alt="${escapeAttribute(iconAlt)}" onerror="this.style.display='none';"></div>`
              : `<div class="incident-popup__icon"><span class="incident-popup__icon-fallback">${escapeHtml((typeLabel || 'I').charAt(0))}</span></div>`;

          const timeInfo = getIncidentReceivedTimeInfo(incident);
          const receivedLine = timeInfo
              ? `<div class="incident-popup__meta-line" title="${escapeAttribute(timeInfo.full)}">Received ${escapeHtml(timeInfo.display)}</div>`
              : '';
          const statusCandidates = [incident.Status, incident.IncidentStatus, incident.Stage];
          let statusText = '';
          for (const value of statusCandidates) {
              if (typeof value !== 'string') continue;
              const trimmed = value.trim();
              if (trimmed) {
                  statusText = trimmed;
                  break;
              }
          }
          const statusLine = statusText
              ? `<div class="incident-popup__meta-line">Status: ${escapeHtml(statusText)}</div>`
              : '';
          const locationText = getIncidentLocationText(incident);
          const locationLine = locationText
              ? `<div class="incident-popup__meta-line">Location: ${escapeHtml(locationText)}</div>`
              : '';
          const metaLines = [receivedLine, statusLine, locationLine].filter(Boolean).join('');
          const metaHtml = metaLines ? `<div class="incident-popup__meta">${metaLines}</div>` : '';

          const routes = Array.isArray(config?.routes) ? config.routes : [];
          const routeBadges = Array.isArray(routes)
              ? routes
                  .map(route => {
                      if (!route) return '';
                      if (typeof route === 'string') {
                          const trimmed = route.trim();
                          if (!trimmed) return '';
                          return `<span class="incident-popup__route">${escapeHtml(trimmed)}</span>`;
                      }
                      const nameCandidates = [route.name, route.RouteName, route.Description, route.Label];
                      let routeName = '';
                      for (const value of nameCandidates) {
                          if (typeof value !== 'string') continue;
                          const trimmed = value.trim();
                          if (trimmed) {
                              routeName = trimmed;
                              break;
                          }
                      }
                      if (!routeName) return '';
                      const colorCandidates = [route.color, route.Color, route.routeColor, route.RouteColor, route.fillColor, route.FillColor];
                      let routeColor = '';
                      for (const candidate of colorCandidates) {
                          const sanitized = sanitizeCssColor(candidate);
                          if (sanitized) {
                              routeColor = sanitized;
                              break;
                          }
                      }
                      if (!routeColor) {
                          const idCandidates = [route.routeId, route.RouteId, route.RouteID];
                          for (const idCandidate of idCandidates) {
                              if (idCandidate === undefined || idCandidate === null) continue;
                              const directColor = sanitizeCssColor(routeColors ? routeColors[idCandidate] : '');
                              if (directColor) {
                                  routeColor = directColor;
                                  break;
                              }
                              const numericId = Number(idCandidate);
                              if (!Number.isFinite(numericId)) continue;
                              const numericColor = sanitizeCssColor(routeColors ? routeColors[numericId] : '');
                              if (numericColor) {
                                  routeColor = numericColor;
                                  break;
                              }
                              const storedRoute = allRoutes ? (allRoutes[numericId] || allRoutes[`${numericId}`] || null) : null;
                              if (storedRoute) {
                                  const storedColor = sanitizeCssColor(storedRoute.MapLineColor || storedRoute.Color || storedRoute.RouteColor);
                                  if (storedColor) {
                                      routeColor = storedColor;
                                      break;
                                  }
                              }
                          }
                      }
                      const styleParts = [];
                      if (routeColor) {
                          styleParts.push(`background:${escapeAttribute(routeColor)}`);
                          styleParts.push(`border-color:${escapeAttribute(routeColor)}`);
                          const textColor = contrastBW(routeColor);
                          if (textColor) {
                              styleParts.push(`color:${escapeAttribute(textColor)}`);
                          }
                          const shadowColor = getColorWithAlpha(routeColor, 0.35);
                          if (shadowColor) {
                              styleParts.push(`box-shadow:0 10px 24px ${escapeAttribute(shadowColor)}`);
                          }
                      }
                      const styleAttr = styleParts.length ? ` style="${styleParts.join(';')}"` : '';
                      return `<span class="incident-popup__route"${styleAttr}>${escapeHtml(routeName)}</span>`;
                  })
                  .filter(Boolean)
              : [];
          const routesHtml = routeBadges.length
              ? `<div class="incident-popup__section"><div class="incident-popup__section-title">Routes Nearby</div><div class="incident-popup__routes-list">${routeBadges.join('')}</div></div>`
              : '';

          const units = extractIncidentUnits(incident);
          const unitsHtml = renderIncidentPopupUnitsSection(units);

          popupElement.innerHTML = `
            <button class="custom-popup-close">&times;</button>
            <div class="incident-popup">
              <div class="incident-popup__header">
                ${iconHtml}
                <div class="incident-popup__details">
                  <div class="incident-popup__title">${safeTypeLabel}</div>
                  ${metaHtml}
                </div>
              </div>
              ${routesHtml}
              ${unitsHtml}
            </div>
            <div class="custom-popup-arrow"></div>
          `;

          attachPopupCloseHandler(popupElement);
      }

      function getIncidentPopupElementById(id) {
          const normalizedId = getNormalizedIncidentId(id);
          if (!normalizedId) {
              return null;
          }
          for (const popupElement of customPopups) {
              if (!popupElement) continue;
              if (popupElement.dataset.popupType !== 'incident') continue;
              const popupId = popupElement.dataset.incidentId || '';
              if (popupId && getNormalizedIncidentId(popupId) === normalizedId) {
                  return popupElement;
              }
          }
          return null;
      }

      function buildIncidentPopupConfig(id) {
          const normalizedId = getNormalizedIncidentId(id);
          if (!normalizedId) {
              return null;
          }
          const entry = incidentMarkers.get(normalizedId);
          if (!entry || !entry.marker || typeof entry.marker.getLatLng !== 'function') {
              return null;
          }
          const latLng = entry.marker.getLatLng();
          if (!latLng) {
              return null;
          }
          const lat = Number(latLng.lat);
          const lng = Number(latLng.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
              return null;
          }
          const routesEntry = incidentsNearRoutesLookup.get(normalizedId);
          const routes = routesEntry && Array.isArray(routesEntry.routes) ? routesEntry.routes : [];
          return {
              popupType: 'incident',
              position: [lat, lng],
              incident: entry.data || null,
              id: normalizedId,
              routes
          };
      }

      function refreshIncidentPopup(id) {
          const popupElement = getIncidentPopupElementById(id);
          if (!popupElement) {
              return;
          }
          const config = buildIncidentPopupConfig(id);
          if (!config) {
              popupElement.remove();
              customPopups = customPopups.filter(popup => popup !== popupElement);
              return;
          }
          popupElement.dataset.position = `${config.position[0]},${config.position[1]}`;
          setIncidentPopupContent(popupElement, config);
          updatePopupPosition(popupElement, config.position);
      }

      function refreshOpenIncidentPopups() {
          const ids = customPopups
              .filter(popupElement => popupElement && popupElement.dataset.popupType === 'incident')
              .map(popupElement => popupElement.dataset.incidentId || '')
              .filter(Boolean);
          ids.forEach(id => {
              refreshIncidentPopup(id);
          });
      }

      function removeIncidentPopupById(id) {
          const popupElement = getIncidentPopupElementById(id);
          if (!popupElement) {
              return;
          }
          popupElement.remove();
          customPopups = customPopups.filter(popup => popup !== popupElement);
      }

      function removeAllIncidentPopups() {
          customPopups = customPopups.filter(popupElement => {
              if (!popupElement) {
                  return false;
              }
              if (popupElement.dataset.popupType === 'incident') {
                  popupElement.remove();
                  return false;
              }
              return true;
          });
      }

      function renderBusStops(stopsArray) {
          if (!Array.isArray(stopsArray) || !map) {
              return;
          }

          stopMarkers.forEach(marker => map.removeLayer(marker));
          stopMarkers = [];

          const selectedRouteIdsSet = getSelectedRouteIdSet();

          const stopsForSelectedRoutes = selectedRouteIdsSet.size > 0
              ? stopsArray.filter(stop => {
                  const routeIds = collectRouteIdsForStop(stop);
                  if (routeIds.size === 0) {
                      return false;
                  }
                  for (const routeId of routeIds) {
                      if (selectedRouteIdsSet.has(routeId)) {
                          return true;
                      }
                  }
                  return false;
              })
              : [];

          const groupedStops = groupStopsByPixelDistance(stopsForSelectedRoutes, STOP_GROUPING_PIXEL_DISTANCE);
          const groupedData = [];

          groupedStops.forEach(group => {
              const stopEntries = buildStopEntriesFromStops(group.stops);
              if (stopEntries.length === 0) {
                  return;
              }

              const allRouteIdsForMarker = new Set();
              stopEntries.forEach(entry => {
                  collectRouteIdsForEntry(entry).forEach(routeId => {
                      if (!Number.isNaN(routeId)) {
                          allRouteIdsForMarker.add(routeId);
                      }
                  });
              });

              if (allRouteIdsForMarker.size === 0) {
                  group.stops.forEach(stop => {
                      collectRouteIdsForStop(stop).forEach(routeId => {
                          allRouteIdsForMarker.add(routeId);
                      });
                  });
              }

              const servesSelectedRoute = selectedRouteIdsSet.size > 0
                  ? Array.from(allRouteIdsForMarker).some(routeId => selectedRouteIdsSet.has(routeId))
                  : false;

              if (!servesSelectedRoute) {
                  return;
              }

              const stopPosition = [group.latitude, group.longitude];
              const aggregatedRouteStopIds = Array.from(new Set(stopEntries.flatMap(entry => entry.routeStopIds)))
                  .map(id => `${id}`)
                  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
              const fallbackStopIdSet = new Set();
              stopEntries.forEach(entry => {
                  if (typeof entry.stopIdText === 'string' && entry.stopIdText.trim() !== '') {
                      entry.stopIdText.split(',').forEach(value => {
                          const trimmed = value.trim();
                          if (trimmed) {
                              fallbackStopIdSet.add(trimmed);
                          }
                      });
                  }
              });
              const fallbackStopIdText = Array.from(fallbackStopIdSet)
                  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
                  .join(', ');
              const displayStopName = Array.from(new Set(stopEntries
                  .map(entry => sanitizeStopName(entry.displayName))
                  .filter(Boolean)))
                  .join(' / ') || 'Stop';
              const groupKey = createStopGroupKey(aggregatedRouteStopIds, fallbackStopIdText);
              const markerRouteIds = Array.from(allRouteIdsForMarker)
                  .filter(routeId => selectedRouteIdsSet.has(routeId))
                  .sort((a, b) => a - b);
              const markerIcon = createStopMarkerIcon(markerRouteIds);

              const groupInfo = {
                  position: stopPosition,
                  stopName: displayStopName,
                  fallbackStopId: fallbackStopIdText,
                  stopEntries,
                  aggregatedRouteStopIds,
                  groupKey
              };

              const stopMarker = L.marker(stopPosition, {
                  icon: markerIcon,
                  pane: 'stopsPane'
              }).addTo(map);

              stopMarker.on('click', () => {
                  createCustomPopup(Object.assign({ popupType: 'stop' }, groupInfo));
              });

              stopMarkers.push(stopMarker);
              groupedData.push(groupInfo);
          });

          stopMarkers.forEach(marker => {
              if (!marker) return;
              if (typeof marker.bringToFront === 'function') {
                  marker.bringToFront();
                  return;
              }
              if (typeof marker.setZIndexOffset === 'function') {
                  marker.setZIndexOffset(1000);
              }
          });

          if (customPopups.length > 0) {
              const groupByKey = new Map();
              groupedData.forEach(groupInfo => {
                  groupByKey.set(groupInfo.groupKey, groupInfo);
              });

              customPopups = customPopups.filter(popupElement => {
                  if (!popupElement) {
                      return false;
                  }
                  if (popupElement.dataset.popupType === 'incident') {
                      return true;
                  }
                  let parsedRouteStopIds = [];
                  try {
                      parsedRouteStopIds = JSON.parse(popupElement.dataset.routeStopIds || '[]');
                  } catch (error) {
                      parsedRouteStopIds = [];
                  }
                  const fallbackId = popupElement.dataset.fallbackStopId || '';
                  const key = popupElement.dataset.groupKey || createStopGroupKey(parsedRouteStopIds, fallbackId);
                  const matchingGroup = groupByKey.get(key);
                  if (matchingGroup) {
                      popupElement.dataset.position = `${matchingGroup.position[0]},${matchingGroup.position[1]}`;
                      setStopPopupContent(popupElement, matchingGroup);
                      updatePopupPosition(popupElement, matchingGroup.position);
                      return true;
                  }
                  popupElement.remove();
                  return false;
              });
          }
      }

      function createCustomPopup(config) {
          if (!config || !Array.isArray(config.position) || config.position.length !== 2) {
              return;
          }
          const popupType = typeof config.popupType === 'string' ? config.popupType : 'stop';
          const position = config.position;
          customPopups.forEach(popup => popup.remove());
          customPopups = [];
          const popupElement = document.createElement('div');
          popupElement.className = 'custom-popup';
          document.body.appendChild(popupElement);
          popupElement.dataset.position = `${position[0]},${position[1]}`;
          popupElement.dataset.popupType = popupType;
          if (popupType === 'incident') {
              setIncidentPopupContent(popupElement, config);
          } else {
              setStopPopupContent(popupElement, config);
          }
          updatePopupPosition(popupElement, position);
          customPopups.push(popupElement);
          if (typeof requestAnimationFrame === 'function') {
              requestAnimationFrame(() => centerPopupOnMap(popupElement));
          } else {
              centerPopupOnMap(popupElement);
          }
      }

      function updatePopupPosition(popupElement, position) {
          if (!map || typeof map?.latLngToContainerPoint !== 'function') {
              return;
          }
          const mapPos = map.latLngToContainerPoint(position);
          popupElement.style.left = `${mapPos.x}px`;
          popupElement.style.top = `${mapPos.y}px`;
      }

      function centerPopupOnMap(popupElement) {
          if (!popupElement || !map || typeof map?.panBy !== 'function') {
              return;
          }
          const mapContainer = typeof map.getContainer === 'function' ? map.getContainer() : null;
          if (!mapContainer) {
              return;
          }
          const mapRect = mapContainer.getBoundingClientRect();
          const popupRect = popupElement.getBoundingClientRect();
          if (mapRect.width === 0 || mapRect.height === 0 || popupRect.width === 0 || popupRect.height === 0) {
              return;
          }
          const mapCenterX = mapRect.width / 2;
          const mapCenterY = mapRect.height / 2;
          const popupCenterX = (popupRect.left - mapRect.left) + (popupRect.width / 2);
          const popupCenterY = (popupRect.top - mapRect.top) + (popupRect.height / 2);
          const deltaX = popupCenterX - mapCenterX;
          const deltaY = popupCenterY - mapCenterY;
          if (Math.abs(deltaX) < 1 && Math.abs(deltaY) < 1) {
              return;
          }
          map.panBy([deltaX, deltaY], { animate: true, duration: 0.35, easeLinearity: 0.25 });
      }

      function updatePopupPositions() {
          if (!map || typeof map?.latLngToContainerPoint !== 'function') {
              return;
          }
          const zooming = !!(map?._animatingZoom || (map?._zoomAnimated && map?._zooming));
          if (zooming) {
              return;
          }
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  const [latitude, longitude] = position.split(',').map(Number);
                  updatePopupPosition(popupElement, [latitude, longitude]);
              }
          });
      }

      function updateCustomPopups() {
          customPopups.forEach(popupElement => {
              if (!popupElement) {
                  return;
              }
              if (popupElement.dataset.popupType === 'incident') {
                  const popupId = popupElement.dataset.incidentId || '';
                  if (popupId) {
                      refreshIncidentPopup(popupId);
                  }
                  return;
              }
              const position = popupElement.dataset.position;
              if (position) {
                  let routeStopIds = [];
                  let stopEntries = [];
                  try {
                      routeStopIds = JSON.parse(popupElement.dataset.routeStopIds || '[]');
                  } catch (error) {
                      routeStopIds = [];
                  }
                  try {
                      stopEntries = JSON.parse(popupElement.dataset.stopEntries || '[]');
                  } catch (error) {
                      stopEntries = [];
                  }
                  const fallbackStopId = popupElement.dataset.fallbackStopId || '';
                  const stopName = popupElement.dataset.stopName || '';
                  const groupKey = popupElement.dataset.groupKey || createStopGroupKey(routeStopIds, fallbackStopId);
                  const groupInfo = {
                      position: position.split(',').map(Number),
                      stopName,
                      fallbackStopId,
                      stopEntries,
                      aggregatedRouteStopIds: routeStopIds,
                      groupKey
                  };
                  setStopPopupContent(popupElement, groupInfo);
              }
          });
      }

      function fetchStopArrivalTimes() {
          const currentBaseURL = baseURL;
          const arrivalTimesApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStopArrivalTimes?APIKey=8882812681`;
          return fetch(arrivalTimesApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return {};
                  let allEtas = {};
                  data.forEach(arrival => {
                      if (!allEtas[arrival.RouteStopId]) {
                          allEtas[arrival.RouteStopId] = [];
                      }
                      arrival.Times.forEach(time => {
                          const etaMinutes = Math.round(time.Seconds / 60);
                          allEtas[arrival.RouteStopId].push({
                              routeDescription: (arrival.RouteDescription === 'Night Pilot' ? arrival.RouteDescription : arrival.RouteDescription),
                              etaMinutes: etaMinutes,
                              RouteId: arrival.RouteId
                          });
                      });
                  });
                  return allEtas;
              })
              .catch(error => {
                  console.error("Error fetching stop arrival times:", error);
                  return {};
              });
      }


      class OverlapRouteRenderer {
        constructor(map, options = {}) {
          this.map = map;
          this.options = Object.assign({
            sampleStepPx: 8,
            dashLengthPx: 16,
            minDashLengthPx: 0.5,
            matchTolerancePx: 6,
            headingToleranceDeg: 20,
            simplifyTolerancePx: 0.75,
            latLngEqualityMargin: 1e-9,
            strokeWeight: DEFAULT_ROUTE_STROKE_WEIGHT,
            minStrokeWeight: MIN_ROUTE_STROKE_WEIGHT,
            maxStrokeWeight: MAX_ROUTE_STROKE_WEIGHT
          }, options);
          this.layers = [];
          this.routeGeometries = new Map();
          this.selectedRoutes = [];
          this.currentZoom = typeof map?.getZoom === 'function' ? map.getZoom() : null;
          this.renderer = options.renderer || null;
          this.routePaneName = typeof options.pane === 'string' && options.pane ? options.pane : routePaneName;
        }

        reset() {
          this.clearLayers();
          this.routeGeometries.clear();
          this.selectedRoutes = [];
        }

        clearLayers() {
          this.layers.forEach(layer => {
            if (layer && this.map.hasLayer(layer)) {
              this.map.removeLayer(layer);
            }
          });
          this.layers = [];
        }

        updateRoutes(routeGeometryMap, selectedRouteIds) {
          if (!Array.isArray(selectedRouteIds) || selectedRouteIds.length === 0) {
            this.reset();
            return this.getLayers();
          }

          const geometryEntries = routeGeometryMap instanceof Map
            ? Array.from(routeGeometryMap.entries())
            : Object.entries(routeGeometryMap || {});

          const desiredIds = new Set(
            selectedRouteIds
              .map(id => Number(id))
              .filter(id => !Number.isNaN(id))
          );

          const nextGeometries = new Map();
          geometryEntries.forEach(([key, value]) => {
            const numericKey = Number(key);
            if (!Number.isNaN(numericKey) && desiredIds.has(numericKey) && Array.isArray(value)) {
              nextGeometries.set(numericKey, value);
            }
          });

          this.routeGeometries = nextGeometries;
          this.selectedRoutes = Array.from(this.routeGeometries.keys()).sort((a, b) => a - b);

          const mapZoom = typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null;
          if (Number.isFinite(mapZoom)) {
            this.currentZoom = mapZoom;
          }

          this.render();
          return this.getLayers();
        }

        handleZoomFrame(targetZoom) {
          if (this.routeGeometries.size === 0 || this.selectedRoutes.length === 0) {
            return this.getLayers();
          }

          const zoom = Number.isFinite(targetZoom)
            ? targetZoom
            : (typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null);
          if (!Number.isFinite(zoom)) {
            return this.getLayers();
          }

          this.currentZoom = zoom;
          this.render();
          return this.getLayers();
        }

        handleZoomEnd() {
          const zoom = typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null;
          return this.handleZoomFrame(zoom);
        }

        getLayers() {
          return this.layers.slice();
        }

        hasPersistentPixelCache() {
          return false;
        }

        computeStrokeWeight(zoom = this.currentZoom) {
          const minWeight = Number.isFinite(this.options.minStrokeWeight)
            ? this.options.minStrokeWeight
            : MIN_ROUTE_STROKE_WEIGHT;
          const maxWeight = Number.isFinite(this.options.maxStrokeWeight)
            ? this.options.maxStrokeWeight
            : MAX_ROUTE_STROKE_WEIGHT;
          const computed = computeRouteStrokeWeight(zoom);
          if (!Number.isFinite(computed)) {
            return Math.max(minWeight, Math.min(maxWeight, DEFAULT_ROUTE_STROKE_WEIGHT));
          }
          return Math.max(minWeight, Math.min(maxWeight, computed));
        }

        render() {
          if (!this.map) return;
          if (this.routeGeometries.size === 0 || this.selectedRoutes.length === 0) {
            this.clearLayers();
            return;
          }

          const zoom = Number.isFinite(this.currentZoom)
            ? this.currentZoom
            : (typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null);
          if (!Number.isFinite(zoom)) {
            this.clearLayers();
            return;
          }

          this.clearLayers();

          const step = Number.isFinite(this.options.sampleStepPx) && this.options.sampleStepPx > 0
            ? this.options.sampleStepPx
            : 8;
          const tolerance = Number.isFinite(this.options.matchTolerancePx)
            ? this.options.matchTolerancePx
            : 6;
          const headingToleranceRad = (Number.isFinite(this.options.headingToleranceDeg)
            ? this.options.headingToleranceDeg
            : 20) * Math.PI / 180;

          const segmentsByRoute = new Map();
          const spatialItems = [];

          this.routeGeometries.forEach((latlngs, routeId) => {
            if (!Array.isArray(latlngs) || latlngs.length < 2) {
              return;
            }

            const segments = this.resampleRoute(routeId, latlngs, zoom, step);
            if (!Array.isArray(segments) || segments.length === 0) {
              return;
            }

            segmentsByRoute.set(routeId, segments);

            segments.forEach(segment => {
              spatialItems.push({
                minX: segment.bounds.minX - tolerance,
                minY: segment.bounds.minY - tolerance,
                maxX: segment.bounds.maxX + tolerance,
                maxY: segment.bounds.maxY + tolerance,
                segment
              });
            });
          });

          if (spatialItems.length === 0) {
            this.clearLayers();
            return;
          }

          const tree = createSpatialIndex({ maxEntries: this.options.maxEntries });
          if (!tree || typeof tree.load !== 'function' || typeof tree.search !== 'function') {
            console.error('RBush spatial index instance is invalid; skipping overlap rendering.');
            this.clearLayers();
            return;
          }

          tree.clear?.();
          tree.load(spatialItems);
          this.populateSharedRoutes(spatialItems, tree, tolerance, headingToleranceRad);

          const groups = this.buildGroups(segmentsByRoute, zoom);
          this.drawGroups(groups);
        }

        populateSharedRoutes(spatialItems, tree, tolerance, headingToleranceRad) {
          const processedPairs = new Set();

          spatialItems.forEach(item => {
            const segment = item.segment;
            if (!segment) return;

            const candidates = tree.search(item);
            candidates.forEach(candidate => {
              const other = candidate.segment;
              if (!other || other === segment) return;
              if (other.routeId === segment.routeId) return;

              const pairKey = segment.routeId < other.routeId
                ? `${segment.routeId}:${segment.index}|${other.routeId}:${other.index}`
                : `${other.routeId}:${other.index}|${segment.routeId}:${segment.index}`;
              if (processedPairs.has(pairKey)) return;

              processedPairs.add(pairKey);
              if (!this.segmentsOverlap(segment, other, tolerance, headingToleranceRad)) return;

              segment.sharedRoutes.add(other.routeId);
              other.sharedRoutes.add(segment.routeId);

              this.applyRouteOffset(segment, other);
              this.applyRouteOffset(other, segment);
            });
          });
        }

        applyRouteOffset(target, source) {
          if (!target || !source) return;
          if (!target.routeOffsets) {
            target.routeOffsets = {};
          }

          const sourceOffset = this.extractRouteOffset(source, source.routeId);
          if (!Number.isFinite(sourceOffset)) {
            return;
          }

          const existing = target.routeOffsets[source.routeId];
          const candidate = Number.isFinite(existing?.min) ? Math.min(existing.min, sourceOffset) : sourceOffset;
          target.routeOffsets[source.routeId] = { min: candidate };
        }

        extractRouteOffset(segment, routeId) {
          if (!segment) return null;
          const offsets = segment.routeOffsets || {};
          const direct = offsets[routeId];
          if (direct && Number.isFinite(direct.min)) {
            return direct.min;
          }

          const values = [];
          const startVal = Number(segment.start?.cumulativeLength);
          if (Number.isFinite(startVal)) values.push(startVal);
          const endVal = Number(segment.end?.cumulativeLength);
          if (Number.isFinite(endVal)) values.push(endVal);
          return values.length > 0 ? Math.min(...values) : null;
        }

        buildGroups(segmentsByRoute, zoom) {
          const groups = [];

          segmentsByRoute.forEach((segments, routeId) => {
            const ordered = segments.slice().sort((a, b) => {
              const aOffset = Number(a.start?.cumulativeLength) || 0;
              const bOffset = Number(b.start?.cumulativeLength) || 0;
              return aOffset - bOffset;
            });

            let current = null;

            ordered.forEach(segment => {
              const sharedRoutes = Array.from(segment.sharedRoutes || []).sort((a, b) => a - b);
              if (sharedRoutes.length === 0) return;

              const primary = sharedRoutes[0];
              if (primary !== routeId) {
                return;
              }

              const needsNewGroup = !current
                || !this.sameRouteSet(current.routes, sharedRoutes)
                || !this.latLngsClose(current.lastLatLng, segment.start.latlng);

              if (needsNewGroup) {
                if (current) {
                  const finalized = this.finalizeGroup(current, zoom);
                  if (finalized) {
                    groups.push(finalized);
                  }
                }

                current = {
                  routes: sharedRoutes,
                  segments: [],
                  points: [],
                  offsets: new Map(),
                  lastLatLng: null
                };
              }

              current.segments.push(segment);

              if (current.points.length === 0) {
                current.points.push(segment.start.latlng);
              } else if (!this.latLngsClose(current.points[current.points.length - 1], segment.start.latlng)) {
                current.points.push(segment.start.latlng);
              }
              current.points.push(segment.end.latlng);
              current.lastLatLng = segment.end.latlng;

              const routeOffsets = segment.routeOffsets || {};
              current.routes.forEach(routeKey => {
                const candidate = Number(routeOffsets?.[routeKey]?.min ?? routeOffsets?.[routeKey]);
                if (Number.isFinite(candidate)) {
                  const existing = current.offsets.get(routeKey);
                  if (!Number.isFinite(existing) || candidate < existing) {
                    current.offsets.set(routeKey, candidate);
                  }
                }
              });
            });

            if (current) {
              const finalized = this.finalizeGroup(current, zoom);
              if (finalized) {
                groups.push(finalized);
              }
              current = null;
            }
          });

          return groups;
        }

        finalizeGroup(group, zoom) {
          const points = this.collapsePoints(group.points || []);
          if (points.length < 2) {
            return null;
          }

          const lengthPx = group.segments.reduce((sum, segment) => {
            const value = Number(segment.lengthPx);
            return sum + (Number.isFinite(value) ? value : 0);
          }, 0);

          const primaryRoute = group.routes[0];
          const offsetCandidates = group.segments
            .map(segment => Number(segment.routeOffsets?.[primaryRoute]?.min ?? segment.routeOffsets?.[primaryRoute]))
            .filter(value => Number.isFinite(value));
          const offsetPx = offsetCandidates.length > 0 ? Math.min(...offsetCandidates) : 0;

          const offsetMap = new Map();
          group.offsets.forEach((value, key) => {
            if (Number.isFinite(value)) {
              offsetMap.set(key, value);
            }
          });

          return {
            routes: group.routes.slice(),
            points,
            lengthPx,
            offsetPx,
            routeOffsets: offsetMap
          };
        }

        collapsePoints(points) {
          const collapsed = [];
          points.forEach(point => {
            if (collapsed.length === 0 || !this.latLngsClose(collapsed[collapsed.length - 1], point)) {
              collapsed.push(point);
            }
          });
          return collapsed;
        }

        sameRouteSet(a, b) {
          if (!Array.isArray(a) || !Array.isArray(b)) return false;
          if (a.length !== b.length) return false;
          for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false;
          }
          return true;
        }

        latLngsClose(a, b) {
          if (!a || !b) return false;
          const tolerance = this.options.latLngEqualityMargin || 1e-9;
          const latA = a.lat ?? a?.latlng?.lat ?? 0;
          const lngA = a.lng ?? a?.latlng?.lng ?? 0;
          const latB = b.lat ?? b?.latlng?.lat ?? 0;
          const lngB = b.lng ?? b?.latlng?.lng ?? 0;
          return Math.abs(latA - latB) <= tolerance && Math.abs(lngA - lngB) <= tolerance;
        }

        drawGroups(groups) {
          const newLayers = [];
          const dashBase = this.options.dashLengthPx;
          const minDash = this.options.minDashLengthPx;
          const weight = this.computeStrokeWeight();

          groups.forEach(group => {
            if (!group || !Array.isArray(group.routes) || group.routes.length === 0) return;
            if (!Array.isArray(group.points) || group.points.length < 2) return;

            const coords = group.points.map(latlng => [latlng.lat, latlng.lng]);
            const sortedRoutes = group.routes.slice().sort((a, b) => a - b);
            const offsetsByRoute = new Map();

            if (group.routeOffsets instanceof Map) {
              group.routeOffsets.forEach((value, routeId) => {
                const numericRoute = Number(routeId);
                const numericValue = Number(value);
                if (Number.isFinite(numericRoute) && Number.isFinite(numericValue)) {
                  const existing = offsetsByRoute.get(numericRoute);
                  if (!Number.isFinite(existing) || numericValue < existing) {
                    offsetsByRoute.set(numericRoute, numericValue);
                  }
                }
              });
            } else if (group.routeOffsets && typeof group.routeOffsets === 'object') {
              Object.entries(group.routeOffsets).forEach(([routeKey, info]) => {
                const numericRoute = Number(routeKey);
                const numericValue = Number(info?.min ?? info);
                if (Number.isFinite(numericRoute) && Number.isFinite(numericValue)) {
                  const existing = offsetsByRoute.get(numericRoute);
                  if (!Number.isFinite(existing) || numericValue < existing) {
                    offsetsByRoute.set(numericRoute, numericValue);
                  }
                }
              });
            }

            if (sortedRoutes.length === 1) {
              const routeId = sortedRoutes[0];
              const layer = L.polyline(coords, mergeRouteLayerOptions({
                color: getRouteColor(routeId),
                weight,
                opacity: 1,
                lineCap: 'round',
                lineJoin: 'round'
              }, this.renderer, this.routePaneName)).addTo(this.map);
              newLayers.push(layer);
              return;
            }

            const groupLength = group.lengthPx || 0;
            if (!(groupLength > 0)) return;
            const stripeCount = sortedRoutes.length;
            let dashLength = dashBase;
            if (dashLength * stripeCount > groupLength) {
              dashLength = groupLength / stripeCount;
            }
            if (!(dashLength > 0)) {
              dashLength = minDash;
            }

            const gapLength = dashLength * (stripeCount - 1);
            const patternLength = dashLength + gapLength;

            let baseOffsetValue;
            const tolerance = 1e-9;
            let anchorRouteId = null;
            let anchorOffset = -Infinity;

            sortedRoutes.forEach(routeId => {
              const offsetValue = offsetsByRoute.get(routeId);
              if (Number.isFinite(offsetValue)) {
                if (
                  anchorRouteId === null ||
                  offsetValue > anchorOffset + tolerance ||
                  (Math.abs(offsetValue - anchorOffset) <= tolerance && routeId < anchorRouteId)
                ) {
                  anchorRouteId = routeId;
                  anchorOffset = offsetValue;
                }
              }
            });

            if (anchorRouteId !== null && Number.isFinite(anchorOffset)) {
              const anchorIndex = sortedRoutes.indexOf(anchorRouteId);
              baseOffsetValue = anchorOffset - dashLength * anchorIndex;
            } else {
              const rawOffset = Number(group.offsetPx);
              baseOffsetValue = Number.isFinite(rawOffset) ? rawOffset : 0;
            }

            sortedRoutes.forEach((routeId, index) => {
              let dashOffsetValue = baseOffsetValue + dashLength * index;
              if (patternLength > 0) {
                const targetOffset = offsetsByRoute.get(routeId);
                if (Number.isFinite(targetOffset)) {
                  const diff = targetOffset - dashOffsetValue;
                  const adjustment = Math.round(diff / patternLength);
                  if (Number.isFinite(adjustment) && adjustment !== 0) {
                    dashOffsetValue += adjustment * patternLength;
                  }
                }
                dashOffsetValue = ((dashOffsetValue % patternLength) + patternLength) % patternLength;
              }

              const layer = L.polyline(coords, mergeRouteLayerOptions({
                color: getRouteColor(routeId),
                weight,
                opacity: 1,
                dashArray: `${dashLength} ${gapLength}`,
                dashOffset: `${dashOffsetValue}`,
                lineCap: 'butt',
                lineJoin: 'round'
              }, this.renderer, this.routePaneName)).addTo(this.map);
              newLayers.push(layer);
            });
          });

          this.layers = newLayers;
        }

        simplifyLatLngs(latlngs, zoom) {
          if (!Array.isArray(latlngs) || latlngs.length === 0) {
            return [];
          }

          const projected = latlngs.map(latlng => this.map.project(latlng, zoom));
          let simplified = projected;
          if (projected.length > 2 && this.options.simplifyTolerancePx > 0 && L.LineUtil && L.LineUtil.simplify) {
            simplified = L.LineUtil.simplify(projected, this.options.simplifyTolerancePx);
          }

          return simplified.map(pt => ({
            point: L.point(pt.x, pt.y),
            latlng: this.map.unproject(pt, zoom)
          }));
        }

        resampleRoute(routeId, latlngs, zoom, step) {
          const simplified = this.simplifyLatLngs(latlngs, zoom);
          if (simplified.length < 2) {
            return [];
          }

          const samples = [];
          const first = simplified[0];
          samples.push({
            latlng: first.latlng,
            point: first.point,
            cumulativeLength: 0
          });

          let traversed = 0;
          let distanceSinceLast = 0;

          for (let i = 1; i < simplified.length; i++) {
            const prev = simplified[i - 1];
            const curr = simplified[i];
            const segmentLength = this.distance(prev.point, curr.point);
            if (segmentLength === 0) {
              continue;
            }

            let consumed = 0;
            while (distanceSinceLast + (segmentLength - consumed) >= step) {
              const remaining = step - distanceSinceLast;
              consumed += remaining;
              const ratio = consumed / segmentLength;
              const samplePoint = this.interpolatePoint(prev.point, curr.point, ratio);
              const sampleLatLng = this.map.unproject(samplePoint, zoom);
              traversed += remaining;
              samples.push({
                latlng: sampleLatLng,
                point: samplePoint,
                cumulativeLength: traversed
              });
              distanceSinceLast = 0;
            }

            const leftover = segmentLength - consumed;
            traversed += leftover;
            distanceSinceLast += leftover;
          }

          const last = simplified[simplified.length - 1];
          const lastSample = samples[samples.length - 1];
          if (!this.latLngsClose(lastSample.latlng, last.latlng)) {
            samples.push({
              latlng: last.latlng,
              point: last.point,
              cumulativeLength: traversed
            });
          } else {
            lastSample.cumulativeLength = traversed;
          }

          const segments = [];
          for (let i = 0; i < samples.length - 1; i++) {
            const start = samples[i];
            const end = samples[i + 1];
            const lengthPx = this.distance(start.point, end.point);
            if (!(lengthPx > 0)) {
              continue;
            }

            const bounds = {
              minX: Math.min(start.point.x, end.point.x),
              minY: Math.min(start.point.y, end.point.y),
              maxX: Math.max(start.point.x, end.point.x),
              maxY: Math.max(start.point.y, end.point.y)
            };
            const midpoint = L.point(
              (start.point.x + end.point.x) / 2,
              (start.point.y + end.point.y) / 2
            );
            const heading = Math.atan2(end.point.y - start.point.y, end.point.x - start.point.x);
            const offsetValues = [];
            const startOffset = Number(start.cumulativeLength);
            if (Number.isFinite(startOffset)) offsetValues.push(startOffset);
            const endOffset = Number(end.cumulativeLength);
            if (Number.isFinite(endOffset)) offsetValues.push(endOffset);

            const routeOffsets = {};
            if (offsetValues.length > 0) {
              routeOffsets[routeId] = { min: Math.min(...offsetValues) };
            }

            segments.push({
              routeId,
              index: segments.length,
              start,
              end,
              lengthPx,
              bounds,
              midpoint,
              heading,
              routeOffsets,
              sharedRoutes: new Set([routeId])
            });
          }

          return segments;
        }

        interpolatePoint(a, b, t) {
          return L.point(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t
          );
        }

        distance(a, b) {
          const ax = a?.x ?? 0;
          const ay = a?.y ?? 0;
          const bx = b?.x ?? 0;
          const by = b?.y ?? 0;
          const dx = bx - ax;
          const dy = by - ay;
          return Math.sqrt(dx * dx + dy * dy);
        }

        segmentsOverlap(a, b, tolerance, headingToleranceRad) {
          const midpointDistance = this.distance(a.midpoint, b.midpoint);
          if (midpointDistance > tolerance) {
            return false;
          }

          const headingDiff = this.smallestHeadingDifference(a.heading, b.heading);
          if (headingDiff > headingToleranceRad && Math.abs(Math.PI - headingDiff) > headingToleranceRad) {
            return false;
          }

          const startDistance = this.distance(a.start.point, b.start.point);
          const endDistance = this.distance(a.end.point, b.end.point);
          const crossStart = this.distance(a.start.point, b.end.point);
          const crossEnd = this.distance(a.end.point, b.start.point);
          const closeEnough = Math.min(startDistance, endDistance, crossStart, crossEnd) <= tolerance * 2;

          return closeEnough;
        }

        smallestHeadingDifference(a, b) {
          let diff = Math.abs(a - b);
          diff = diff % (Math.PI * 2);
          if (diff > Math.PI) diff = (Math.PI * 2) - diff;
          return diff;
        }
      }
      // Fetch routes from GetRoutes.
      function fetchRouteColors() {
        console.log('Fetching route colors...');
        const routesApiUrl = `${baseURL}/Services/JSONPRelay.svc/GetRoutes?APIKey=8882812681`;
        return fetch(routesApiUrl)
          .then(response => response.json())
          .then(data => {
            if (Array.isArray(data)) {
              data.forEach(route => {
                setRouteVisibility(route);
                allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                if (canDisplayRoute(route.RouteID)) {
                  routeColors[route.RouteID] = route.MapLineColor;
                  console.log(`Route ID: ${route.RouteID}, Color: ${route.MapLineColor}`);
                } else {
                  delete routeColors[route.RouteID];
                  console.log(`Route ID: ${route.RouteID} hidden due to display settings`);
                }
              });
            }
          })
          .catch(error => console.error("Error fetching route colors:", error));
      }

      // Fetch route paths from GetRoutesForMapWithSchedule and center map on relevant routes.
      function fetchRoutePaths() {
          const currentBaseURL = baseURL;
          const routePathsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=8882812681`;
          return fetch(routePathsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  const activeRoutesForBounds = new Set();
                  activeRoutes.forEach(routeId => {
                      const numericRouteId = Number(routeId);
                      if (Number.isFinite(numericRouteId) && numericRouteId !== 0) {
                          activeRoutesForBounds.add(numericRouteId);
                      }
                  });
                  const hasActiveServiceRoutes = activeRoutesForBounds.size > 0;
                  let bounds = null;
                  let fallbackBounds = null;
                  const displayedRoutes = new Map();
                  const rendererGeometries = new Map();
                  const simpleGeometries = [];
                  const selectedRouteIds = [];
                  const updatedRouteStopAddressMap = {};
                  const updatedRouteStopRouteMap = {};
                  const useOverlapRenderer = enableOverlapDashRendering && overlapRenderer;
                  const seenRouteIds = new Set();
                  let geometryChanged = false;

                  if (Array.isArray(data)) {
                      data.forEach(route => {
                          setRouteVisibility(route);
                          allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                  const numericRouteId = Number(route.RouteID);
                  const isNumericRoute = !Number.isNaN(numericRouteId);

                  if (Array.isArray(route.Stops)) {
                      route.Stops.forEach(stop => {
                          const routeStopId = Number(stop.RouteStopID ?? stop.RouteStopId);
                          const addressId = stop.AddressID ?? stop.AddressId;
                          if (!Number.isNaN(routeStopId)) {
                              if (isNumericRoute) {
                                  updatedRouteStopRouteMap[routeStopId] = numericRouteId;
                              }
                              if (addressId !== undefined && addressId !== null && `${addressId}`.trim() !== '') {
                                  updatedRouteStopAddressMap[routeStopId] = `${addressId}`;
                              }
                          }
                      });
                  }

                  const routeAllowed = canDisplayRoute(route.RouteID);
                          if (isNumericRoute && route.EncodedPolyline) {
                              seenRouteIds.add(numericRouteId);
                          }

                          if (!routeAllowed) {
                              return;
                          }

                          const isSelected = isRouteSelected(route.RouteID);
                          if (route.EncodedPolyline && isNumericRoute) {
                              const shouldIncludeInBounds = !hasActiveServiceRoutes || activeRoutesForBounds.has(numericRouteId);
                              let cacheEntry = routePolylineCache.get(numericRouteId);
                              let latLngPath;
                              let polyBounds = null;

                              if (!cacheEntry || cacheEntry.encoded !== route.EncodedPolyline) {
                                  const decodedPolyline = polyline.decode(route.EncodedPolyline);
                                  latLngPath = decodedPolyline.map(coords => L.latLng(coords[0], coords[1]));
                                  if (Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                      polyBounds = L.latLngBounds(latLngPath);
                                  }
                                  const entry = {
                                      encoded: route.EncodedPolyline,
                                      latLngPath,
                                      bounds: polyBounds
                                  };
                                  routePolylineCache.set(numericRouteId, entry);
                                  ensureRouteProjectedPath(entry);
                                  cacheEntry = routePolylineCache.get(numericRouteId);
                                  if (isSelected) {
                                      geometryChanged = true;
                                  }
                              } else {
                                  latLngPath = cacheEntry.latLngPath;
                                  polyBounds = cacheEntry.bounds || null;
                                  if (!polyBounds && Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                      polyBounds = L.latLngBounds(latLngPath);
                                      cacheEntry.bounds = polyBounds;
                                  }
                                  ensureRouteProjectedPath(cacheEntry);
                              }

                              let candidateBounds = polyBounds;
                              if (!candidateBounds && Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                  candidateBounds = L.latLngBounds(latLngPath);
                                  if (cacheEntry) {
                                      cacheEntry.bounds = candidateBounds;
                                  } else {
                                      const existing = routePolylineCache.get(numericRouteId);
                                      if (existing) {
                                          existing.bounds = candidateBounds;
                                      }
                                  }
                              }

                              if (candidateBounds) {
                                  fallbackBounds = fallbackBounds
                                      ? fallbackBounds.extend(candidateBounds)
                                      : L.latLngBounds(candidateBounds);
                                  if (shouldIncludeInBounds) {
                                      bounds = bounds
                                          ? bounds.extend(candidateBounds)
                                          : L.latLngBounds(candidateBounds);
                                  }
                              }

                              if (isSelected && Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                  const routeColor = getRouteColor(route.RouteID);
                                  selectedRouteIds.push(numericRouteId);
                                  if (useOverlapRenderer) {
                                      rendererGeometries.set(numericRouteId, latLngPath);
                                  } else {
                                      simpleGeometries.push({ routeId: numericRouteId, latLngPath, routeColor });
                                  }

                                  const storedRoute = allRoutes[route.RouteID] || {};
                                  const legendNameCandidates = [
                                      storedRoute.Description,
                                      route.Description,
                                      storedRoute.Name,
                                      route.Name,
                                      storedRoute.RouteName,
                                      route.RouteName
                                  ];
                                  let legendName = legendNameCandidates.find(value => typeof value === 'string' && value.trim() !== '');
                                  legendName = legendName ? legendName.trim() : `Route ${route.RouteID}`;
                                  const rawDescription = storedRoute.InfoText ?? route.InfoText ?? '';
                                  const legendDescription = typeof rawDescription === 'string' ? rawDescription.trim() : '';
                                  const legendRouteId = isNumericRoute ? numericRouteId : route.RouteID;
                                  displayedRoutes.set(route.RouteID, {
                                      routeId: legendRouteId,
                                      color: routeColor,
                                      name: legendName,
                                      description: legendDescription
                                  });
                              }
                          } else if (isSelected && isNumericRoute) {
                              if (routePolylineCache.has(numericRouteId)) {
                                  routePolylineCache.delete(numericRouteId);
                              }
                              geometryChanged = true;
                          }
                      });

                      const previousSelectedIds = new Set(lastRouteRenderState.selectionKey
                          ? lastRouteRenderState.selectionKey.split('|').filter(Boolean).map(id => Number(id))
                          : []);
                      Array.from(routePolylineCache.keys()).forEach(routeId => {
                          if (!seenRouteIds.has(routeId)) {
                              if (previousSelectedIds.has(routeId)) {
                                  geometryChanged = true;
                              }
                              routePolylineCache.delete(routeId);
                          }
                      });

                      const selectedRouteIdsSorted = selectedRouteIds.slice().sort((a, b) => a - b);
                      currentTranslocSelectedRouteIds = selectedRouteIdsSorted.slice();
                      currentTranslocRendererGeometries = new Map(rendererGeometries);
                      const selectionKey = selectedRouteIdsSorted.join('|');
                      const colorSignature = selectedRouteIdsSorted.map(id => `${id}:${getRouteColor(id)}`).join('|');
                      const geometrySignature = selectedRouteIdsSorted
                          .map(id => `${id}:${getRouteGeometrySignature(id, rendererGeometries)}`)
                          .join('|');
                      const rendererFlag = !!useOverlapRenderer;

                      let shouldRender = routeLayers.length === 0 ||
                        rendererFlag !== lastRouteRenderState.useOverlapRenderer ||
                        selectionKey !== lastRouteRenderState.selectionKey ||
                        colorSignature !== lastRouteRenderState.colorSignature ||
                        geometrySignature !== lastRouteRenderState.geometrySignature ||
                        geometryChanged;

                      if (useOverlapRenderer) {
                          updateOverlapRendererWithCatRoutes();
                      } else if (shouldRender) {
                          routeLayers.forEach(layer => map.removeLayer(layer));
                          routeLayers = [];
                          const currentStrokeWeight = computeRouteStrokeWeight(typeof map?.getZoom === 'function' ? map.getZoom() : null);
                          simpleGeometries.forEach(({ routeId, latLngPath, routeColor }) => {
                              const routeLayer = L.polyline(latLngPath, mergeRouteLayerOptions({
                                      color: routeColor,
                                      weight: currentStrokeWeight,
                                      opacity: 1,
                                      lineCap: 'round',
                                      lineJoin: 'round'
                                  })).addTo(map);
                                  routeLayers.push(routeLayer);
                          });
                      }

                      if (!rendererFlag) {
                          lastRouteRenderState = {
                              selectionKey,
                              colorSignature,
                              geometrySignature,
                              useOverlapRenderer: rendererFlag
                          };
                      }

                      routeStopAddressMap = updatedRouteStopAddressMap;
                      routeStopRouteMap = updatedRouteStopRouteMap;
                      updateCustomPopups();
                      if (Array.isArray(stopDataCache) && stopDataCache.length > 0) {
                          renderBusStops(stopDataCache);
                      }
                      if (!bounds && fallbackBounds) {
                          bounds = fallbackBounds;
                      }
                      if (bounds) {
                          allRouteBounds = bounds;
                          if (!mapHasFitAllRoutes) {
                              if (!kioskMode && !adminKioskMode) {
                                  map.fitBounds(allRouteBounds, { padding: [20, 20] });
                              }
                              mapHasFitAllRoutes = true;
                          }
                      }
                      evaluateIncidentRouteAlerts();
                      updateRouteSelector(activeRoutes);
                      stopMarkers.forEach(stopMarker => {
                          if (!stopMarker) {
                              return;
                          }
                          if (typeof stopMarker.bringToFront === 'function') {
                              stopMarker.bringToFront();
                              return;
                          }
                          if (typeof stopMarker.setZIndexOffset === 'function') {
                              stopMarker.setZIndexOffset(1000);
                          }
                      });
                  }
                  updateRouteLegend(Array.from(displayedRoutes.values()), { preserveOnEmpty: true });
              })
              .catch(error => {
                  console.error("Error fetching route paths:", error);
                  if (kioskMode || adminKioskMode) {
                      updateRouteLegend(lastRenderedLegendRoutes, { preserveOnEmpty: true });
                  } else {
                      updateRouteLegend([], { forceHide: true });
                  }
              });
      }

      function fetchBlockAssignments() {
          const currentBaseURL = baseURL;
          const d = new Date();
          const ds = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
          const schedUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetScheduleVehicleCalendarByDateAndRoute?dateString=${encodeURIComponent(ds)}`;
          return fetch(schedUrl)
              .then(response => response.json())
              .then(sched => {
                  if (currentBaseURL !== baseURL) return;
                  const ids = (sched || []).map(s => s.ScheduleVehicleCalendarID).join(',');
                  if (!ids) {
                      busBlocks = {};
                      return;
                  }
                  const blockUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetDispatchBlockGroupData?scheduleVehicleCalendarIdsString=${ids}`;
                  return fetch(blockUrl).then(r => r.json());
              })
              .then(data => {
                  if (currentBaseURL !== baseURL || !data) return;
                  const groups = data?.BlockGroups || [];
                  const alias = {
                      "[01]": "[01]/[04]",
                      "[03]": "[05]/[03]",
                      "[04]": "[01]/[04]",
                      "[05]": "[05]/[03]",
                      "[06]": "[22]/[06]",
                      "[10]": "[20]/[10]",
                      "[15]": "[26]/[15]",
                      "[16] AM": "[21]/[16] AM",
                      "[17]": "[23]/[17]",
                      "[18] AM": "[24]/[18] AM",
                      "[20] AM": "[20]/[10]",
                      "[21] AM": "[21]/[16] AM",
                      "[22] AM": "[22]/[06]",
                      "[23]": "[23]/[17]",
                      "[24] AM": "[24]/[18] AM",
                      "[26] AM": "[26]/[15]"
                  };
                  let mapping = {};
                  groups.forEach(g => {
                      const block = (g.BlockGroupId || '').trim();
                      const vehicleId = g.Blocks?.[0]?.Trips?.[0]?.VehicleID ?? g.VehicleId;
                      if (block && block.includes('[') && vehicleId != null) {
                          mapping[vehicleId] = alias[block] || block;
                      }
                  });
                  busBlocks = mapping;
              })
              .catch(error => console.error("Error fetching block assignments:", error));
      }

      async function fetchBusLocations() {
          try {
              const headingPromise = loadVehicleHeadingCache();
              if (headingPromise && typeof headingPromise.then === 'function') {
                  await headingPromise;
              }
          } catch (error) {
              console.info('Proceeding without cached vehicle headings.', error);
          }
          const currentBaseURL = baseURL;
          const apiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetMapVehiclePoints?APIKey=8882812681&returnVehiclesNotAssignedToRoute=true`;
          try {
              await loadBusSVG();
          } catch (error) {
              console.error('Failed to load bus marker SVG before fetching locations:', error);
          }
          try {
              const response = await fetch(apiUrl);
              if (!response.ok) {
                  throw new Error(`Network response was not ok: ${response.statusText}`);
              }
              const data = await response.json();
              if (currentBaseURL !== baseURL || !Array.isArray(data)) {
                  return;
              }
              const currentBusData = {};
              const activeRoutesSet = new Set();
              const vehicles = [];

              data.forEach(vehicle => {
                  const vehicleID = vehicle.VehicleID;
                  const newPosition = [vehicle.Latitude, vehicle.Longitude];
                  const isMoving = vehicle.GroundSpeed > 0;
                  const busName = vehicle.Name;
                  let routeID = vehicle.RouteID;
                  if (!routeID && adminMode) {
                      routeID = 0;
                  } else if (!routeID) {
                      return;
                  }
                  const numericRouteId = Number(routeID);
                  const effectiveRouteId = Number.isNaN(numericRouteId) ? routeID : numericRouteId;
                  if (!canDisplayRoute(effectiveRouteId)) return;
                  if (!adminMode && !routeColors.hasOwnProperty(effectiveRouteId)) return;
                  activeRoutesSet.add(effectiveRouteId);
                  vehicles.push({
                      vehicleID,
                      newPosition,
                      isMoving,
                      busName,
                      routeID: effectiveRouteId,
                      heading: vehicle.Heading,
                      groundSpeed: vehicle.GroundSpeed
                  });
              });

              activeRoutes = activeRoutesSet;
              updateRouteSelector(activeRoutesSet);

              const markerMetricsForZoom = computeBusMarkerMetrics(map && typeof map?.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM);

              for (const v of vehicles) {
                  const { vehicleID, newPosition, busName, routeID, heading, groundSpeed } = v;
                  if (!isRouteSelected(routeID)) continue;
                  currentBusData[vehicleID] = true;
                  const state = ensureBusMarkerState(vehicleID);
                  const routeColor = getRouteColor(routeID) || outOfServiceRouteColor;
                  const glyphColor = computeBusMarkerGlyphColor(routeColor);
                  const fallbackHeading = getVehicleHeadingFallback(vehicleID, heading);
                  const headingDeg = updateBusMarkerHeading(state, newPosition, fallbackHeading, groundSpeed);
                  const accessibleLabel = buildBusMarkerAccessibleLabel(busName, headingDeg, groundSpeed);
                  const gpsIsStale = isVehicleGpsStale(v);
                  const isStopped = isBusConsideredStopped(groundSpeed);

                  state.busName = busName;
                  state.routeID = routeID;
                  state.fillColor = routeColor;
                  state.glyphColor = glyphColor;
                  state.headingDeg = headingDeg;
                  state.accessibleLabel = accessibleLabel;
                  state.isStale = gpsIsStale;
                  state.isStopped = isStopped;
                  state.groundSpeed = groundSpeed;
                  state.lastUpdateTimestamp = Date.now();
                  rememberCachedVehicleHeading(vehicleID, headingDeg, state.lastUpdateTimestamp);

                  if (!state.size) {
                      setBusMarkerSize(state, markerMetricsForZoom);
                  }

                  if (markers[vehicleID]) {
                      animateMarkerTo(markers[vehicleID], newPosition);
                      markers[vehicleID].routeID = routeID;
                      queueBusMarkerVisualUpdate(vehicleID, {
                          fillColor: routeColor,
                          glyphColor,
                          headingDeg,
                          stale: gpsIsStale,
                          accessibleLabel,
                          stopped: isStopped
                      });
                  } else {
                      try {
                          const icon = await createBusMarkerDivIcon(vehicleID, state);
                          if (!icon) {
                              continue;
                          }
                          const marker = L.marker(newPosition, { icon, pane: 'busesPane', interactive: false, keyboard: false });
                          marker.routeID = routeID;
                          marker.addTo(map);
                          markers[vehicleID] = marker;
                          state.marker = marker;
                          registerBusMarkerElements(vehicleID);
                          attachBusMarkerInteractions(vehicleID);
                          updateBusMarkerRootClasses(state);
                          updateBusMarkerZIndex(state);
                          applyBusMarkerOutlineWidth(state);
                      } catch (error) {
                          console.error(`Failed to create bus marker icon for vehicle ${vehicleID}:`, error);
                      }
                  }

                  if (adminMode && displayMode === DISPLAY_MODES.SPEED && !kioskMode) {
                      const speedIcon = createSpeedBubbleDivIcon(routeColor, groundSpeed, markerMetricsForZoom.scale, headingDeg);
                      if (speedIcon) {
                          nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                          if (nameBubbles[vehicleID].speedMarker) {
                              animateMarkerTo(nameBubbles[vehicleID].speedMarker, newPosition);
                              nameBubbles[vehicleID].speedMarker.setIcon(speedIcon);
                          } else {
                              nameBubbles[vehicleID].speedMarker = L.marker(newPosition, { icon: speedIcon, interactive: false, pane: 'busesPane' }).addTo(map);
                          }
                      } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                          map.removeLayer(nameBubbles[vehicleID].speedMarker);
                          delete nameBubbles[vehicleID].speedMarker;
                      }
                  } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                      map.removeLayer(nameBubbles[vehicleID].speedMarker);
                      delete nameBubbles[vehicleID].speedMarker;
                  }

                  if (adminMode && !kioskMode) {
                      const nameIcon = createNameBubbleDivIcon(busName, routeColor, markerMetricsForZoom.scale, headingDeg);
                      if (nameIcon) {
                          nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                          if (nameBubbles[vehicleID].nameMarker) {
                              animateMarkerTo(nameBubbles[vehicleID].nameMarker, newPosition);
                              nameBubbles[vehicleID].nameMarker.setIcon(nameIcon);
                          } else {
                              nameBubbles[vehicleID].nameMarker = L.marker(newPosition, { icon: nameIcon, interactive: false, pane: 'busesPane' }).addTo(map);
                          }
                      } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                          map.removeLayer(nameBubbles[vehicleID].nameMarker);
                          delete nameBubbles[vehicleID].nameMarker;
                      }

                      const blockName = busBlocks[vehicleID];
                      if (displayMode === DISPLAY_MODES.BLOCK && blockName && blockName.includes('[')) {
                          const blockIcon = createBlockBubbleDivIcon(blockName, routeColor, markerMetricsForZoom.scale, headingDeg);
                          if (blockIcon) {
                              nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                              if (nameBubbles[vehicleID].blockMarker) {
                                  animateMarkerTo(nameBubbles[vehicleID].blockMarker, newPosition);
                                  nameBubbles[vehicleID].blockMarker.setIcon(blockIcon);
                              } else {
                                  nameBubbles[vehicleID].blockMarker = L.marker(newPosition, { icon: blockIcon, interactive: false, pane: 'busesPane' }).addTo(map);
                              }
                          } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                              map.removeLayer(nameBubbles[vehicleID].blockMarker);
                              delete nameBubbles[vehicleID].blockMarker;
                          }
                      } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                          map.removeLayer(nameBubbles[vehicleID].blockMarker);
                          delete nameBubbles[vehicleID].blockMarker;
                      }
                  } else {
                      if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                          map.removeLayer(nameBubbles[vehicleID].nameMarker);
                          delete nameBubbles[vehicleID].nameMarker;
                      }
                      if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                          map.removeLayer(nameBubbles[vehicleID].blockMarker);
                          delete nameBubbles[vehicleID].blockMarker;
                      }
                  }

                  if (nameBubbles[vehicleID]) {
                      const hasMarkers = Boolean(nameBubbles[vehicleID].speedMarker || nameBubbles[vehicleID].nameMarker || nameBubbles[vehicleID].blockMarker);
                      if (hasMarkers) {
                          nameBubbles[vehicleID].lastScale = markerMetricsForZoom.scale;
                      } else {
                          delete nameBubbles[vehicleID];
                      }
                  }
              }

              Object.keys(markers).forEach(vehicleID => {
                  if (!currentBusData[vehicleID] || !isRouteSelected(markers[vehicleID].routeID)) {
                      map.removeLayer(markers[vehicleID]);
                      delete markers[vehicleID];
                      clearBusMarkerState(vehicleID);
                      if (nameBubbles[vehicleID]) {
                          if (nameBubbles[vehicleID].speedMarker) map.removeLayer(nameBubbles[vehicleID].speedMarker);
                          if (nameBubbles[vehicleID].nameMarker) map.removeLayer(nameBubbles[vehicleID].nameMarker);
                          if (nameBubbles[vehicleID].blockMarker) map.removeLayer(nameBubbles[vehicleID].blockMarker);
                          delete nameBubbles[vehicleID];
                      }
                  }
              });
              previousBusData = currentBusData;
          } catch (error) {
              console.error("Error fetching bus locations:", error);
          }
      }

      function clamp(value, min, max) {
          return Math.min(Math.max(value, min), max);
      }

      function computeMarkerScale(zoom) {
          return 1;
      }

      function computeBusMarkerMetrics(zoom) {
          const scale = computeMarkerScale(zoom);
          const width = BUS_MARKER_BASE_WIDTH_PX * scale;
          const height = width * BUS_MARKER_ASPECT_RATIO;
          return { scale, widthPx: width, heightPx: height };
      }

      function rememberCachedVehicleHeading(vehicleID, headingDeg, timestamp) {
          if (!Number.isFinite(headingDeg)) {
              return;
          }
          if (vehicleID === undefined || vehicleID === null) {
              return;
          }
          const key = `${vehicleID}`;
          if (!key || key === 'undefined' || key === 'null') {
              return;
          }
          const normalizedHeading = normalizeHeadingDegrees(headingDeg);
          const updatedAt = Number.isFinite(timestamp) ? Number(timestamp) : Date.now();
          vehicleHeadingCache.set(key, { heading: normalizedHeading, updatedAt });
      }

      function getCachedVehicleHeading(vehicleID) {
          if (vehicleID === undefined || vehicleID === null) {
              return null;
          }
          const key = `${vehicleID}`;
          const entry = vehicleHeadingCache.get(key);
          if (!entry) {
              return null;
          }
          const heading = Number(entry.heading ?? entry.Heading);
          if (!Number.isFinite(heading)) {
              return null;
          }
          return normalizeHeadingDegrees(heading);
      }

      function getVehicleHeadingFallback(vehicleID, headingFromFeed) {
          const cached = getCachedVehicleHeading(vehicleID);
          if (cached !== null) {
              return cached;
          }
          const fromFeed = Number(headingFromFeed);
          if (Number.isFinite(fromFeed)) {
              return normalizeHeadingDegrees(fromFeed);
          }
          return BUS_MARKER_DEFAULT_HEADING;
      }

      function loadVehicleHeadingCache() {
          if (vehicleHeadingCachePromise) {
              return vehicleHeadingCachePromise;
          }
          if (typeof fetch !== 'function') {
              vehicleHeadingCachePromise = Promise.resolve(vehicleHeadingCache);
              return vehicleHeadingCachePromise;
          }
          vehicleHeadingCachePromise = (async () => {
              try {
                  const response = await fetch(VEHICLE_HEADING_CACHE_ENDPOINT, { cache: 'no-store' });
                  if (!response.ok) {
                      throw new Error(`HTTP ${response.status}`);
                  }
                  const data = await response.json();
                  if (data && typeof data === 'object' && data.headings && typeof data.headings === 'object') {
                      Object.entries(data.headings).forEach(([vehicleID, entry]) => {
                          if (!vehicleID) {
                              return;
                          }
                          let headingValue = entry;
                          let updatedAt = undefined;
                          if (entry && typeof entry === 'object') {
                              headingValue = entry.heading ?? entry.Heading;
                              const tsCandidate = entry.updated_at ?? entry.updatedAt ?? entry.timestamp ?? entry.ts_ms ?? entry.ts;
                              if (Number.isFinite(Number(tsCandidate))) {
                                  updatedAt = Number(tsCandidate);
                              }
                          }
                          const headingNumber = Number(headingValue);
                          if (!Number.isFinite(headingNumber)) {
                              return;
                          }
                          rememberCachedVehicleHeading(vehicleID, headingNumber, updatedAt);
                      });
                  }
              } catch (error) {
                  console.info('Vehicle heading cache unavailable; continuing without it.', error);
              }
              return vehicleHeadingCache;
          })();
          return vehicleHeadingCachePromise;
      }

      function toggleCatOverlay() {
          if (catOverlayEnabled) {
              disableCatOverlay();
          } else {
              enableCatOverlay();
          }
      }

      function enableCatOverlay() {
          catOverlayEnabled = true;
          ensureCatLayerGroup();
          ensureCatBusMarkerSvgLoaded();
          updateCatToggleButtonState();
          refreshServiceAlertsUI();
          updateRouteSelector(activeRoutes, true);
          renderCatRoutes();
          fetchCatRoutes().catch(error => console.error('Failed to fetch CAT routes:', error));
          fetchCatStops().catch(error => console.error('Failed to fetch CAT stops:', error));
          fetchCatRoutePatterns().catch(error => console.error('Failed to fetch CAT route patterns:', error));
          fetchCatVehicles().catch(error => console.error('Failed to fetch CAT vehicles:', error));
          fetchCatServiceAlerts().catch(error => console.error('Failed to fetch CAT service alerts:', error));
          startCatRefreshIntervals();
      }

      function disableCatOverlay() {
          catOverlayEnabled = false;
          stopCatRefreshIntervals();
          clearCatVehicleMarkers();
          if (catLayerGroup && map && map.hasLayer(catLayerGroup)) {
              map.removeLayer(catLayerGroup);
          }
          catActiveRouteKeys = new Set();
          catRouteSelections.clear();
          catServiceAlerts = [];
          catServiceAlertsLoading = false;
          catServiceAlertsError = null;
          catServiceAlertsFetchPromise = null;
          catServiceAlertsLastFetchTime = 0;
          resetCatOverlapRenderingState();
          updateCatToggleButtonState();
          refreshServiceAlertsUI();
          updateRouteSelector(activeRoutes, true);
          if (enableOverlapDashRendering && overlapRenderer) {
              updateOverlapRendererWithCatRoutes();
          }
      }

      function ensureCatLayerGroup() {
          if (!map) {
              return null;
          }
          if (!catLayerGroup) {
              catLayerGroup = L.layerGroup();
          }
          if (!map.hasLayer(catLayerGroup)) {
              catLayerGroup.addTo(map);
          }
          return catLayerGroup;
      }

      function startCatRefreshIntervals() {
          stopCatRefreshIntervals();
          if (!catOverlayEnabled) {
              return;
          }
          catRefreshIntervals.push(setInterval(() => {
              fetchCatVehicles().catch(error => console.error('Failed to refresh CAT vehicles:', error));
          }, CAT_VEHICLE_FETCH_INTERVAL_MS));
          catRefreshIntervals.push(setInterval(() => {
              fetchCatRoutes().catch(error => console.error('Failed to refresh CAT routes:', error));
              fetchCatStops().catch(error => console.error('Failed to refresh CAT stops:', error));
              fetchCatRoutePatterns().catch(error => console.error('Failed to refresh CAT route patterns:', error));
          }, CAT_METADATA_REFRESH_INTERVAL_MS));
          catRefreshIntervals.push(setInterval(() => {
              fetchCatServiceAlerts().catch(error => console.error('Failed to refresh CAT service alerts:', error));
          }, CAT_SERVICE_ALERT_REFRESH_INTERVAL_MS));
      }

      function stopCatRefreshIntervals() {
          if (Array.isArray(catRefreshIntervals)) {
              catRefreshIntervals.forEach(intervalId => clearInterval(intervalId));
          }
          catRefreshIntervals = [];
      }

      function ensureCatBusMarkerSvgLoaded() {
          if (BUS_MARKER_SVG_TEXT) {
              return Promise.resolve(true);
          }
          if (!catBusMarkerSvgPromise && typeof loadBusSVG === 'function') {
              catBusMarkerSvgPromise = loadBusSVG()
                  .then(() => {
                      catBusMarkerSvgPromise = null;
                      return !!BUS_MARKER_SVG_TEXT;
                  })
                  .catch(error => {
                      catBusMarkerSvgPromise = null;
                      console.error('Failed to load bus marker SVG for CAT overlay:', error);
                      return false;
                  });
          }
          return catBusMarkerSvgPromise || Promise.resolve(false);
      }

      function isCatOutOfServiceRouteValue(value) {
          if (value === undefined || value === null) {
              return false;
          }
          const text = `${value}`.trim();
          if (text === '') {
              return false;
          }
          if (text === CAT_OUT_OF_SERVICE_ROUTE_KEY) {
              return true;
          }
          const numeric = Number(text);
          if (Number.isFinite(numeric) && numeric === CAT_OUT_OF_SERVICE_NUMERIC_ROUTE_ID) {
              return true;
          }
          return false;
      }

      function catRouteKey(routeId) {
          if (routeId === undefined || routeId === null) {
              return '';
          }
          const text = `${routeId}`.trim();
          if (text === '') {
              return '';
          }
          if (isCatOutOfServiceRouteValue(text)) {
              return CAT_OUT_OF_SERVICE_ROUTE_KEY;
          }
          return text;
      }

      function catStopKey(stopId) {
          if (stopId === undefined || stopId === null) {
              return '';
          }
          return `${stopId}`.trim();
      }

      function isCatOverlapRouteId(routeId) {
          const numeric = Number(routeId);
          if (Number.isNaN(numeric)) {
              return false;
          }
          return catOverlapInfoByNumericId.has(numeric);
      }

      function resetCatOverlapRenderingState() {
          catOverlapPatternIdMap.clear();
          catOverlapInfoByNumericId.clear();
          nextCatOverlapNumericId = 1000000;
      }

      function mergeNumericRouteIds(...lists) {
          const merged = new Set();
          lists.forEach(list => {
              if (!Array.isArray(list)) {
                  return;
              }
              list.forEach(id => {
                  const numeric = Number(id);
                  if (!Number.isNaN(numeric)) {
                      merged.add(numeric);
                  }
              });
          });
          return Array.from(merged).sort((a, b) => a - b);
      }

      function buildLatLngSignature(latLngs) {
          if (!Array.isArray(latLngs) || latLngs.length === 0) {
              return '';
          }
          const parts = [];
          const limit = Math.min(latLngs.length, 256);
          for (let i = 0; i < limit; i += 1) {
              const point = latLngs[i];
              if (!point) {
                  continue;
              }
              const lat = Number(point.lat ?? point.latitude ?? (Array.isArray(point) ? point[0] : null));
              const lng = Number(point.lng ?? point.lon ?? point.longitude ?? (Array.isArray(point) ? point[1] : null));
              if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                  continue;
              }
              parts.push(`${lat.toFixed(6)},${lng.toFixed(6)}`);
          }
          return parts.join(';');
      }

      function ensureCatOverlapPatternEntry(patternKey, geometry) {
          if (!patternKey || !geometry) {
              return null;
          }
          let numericId = catOverlapPatternIdMap.get(patternKey);
          if (!Number.isFinite(numericId)) {
              numericId = nextCatOverlapNumericId;
              nextCatOverlapNumericId += 1;
              catOverlapPatternIdMap.set(patternKey, numericId);
          }
          const normalizedRouteKey = catRouteKey(geometry.routeKey);
          const color = sanitizeCssColor(geometry.color)
              || sanitizeCssColor(getCatRouteColor(normalizedRouteKey))
              || CAT_VEHICLE_MARKER_DEFAULT_COLOR;
          const encoded = typeof geometry.encoded === 'string' ? geometry.encoded : '';
          const latLngs = Array.isArray(geometry.latLngs) ? geometry.latLngs : [];
          const geometrySignature = encoded || buildLatLngSignature(latLngs);
          catOverlapInfoByNumericId.set(numericId, {
              patternKey,
              routeKey: normalizedRouteKey,
              color,
              geometrySignature,
              encoded
          });
          return numericId;
      }

      function buildCatOverlapRendererData() {
          const geometries = new Map();
          const routeIds = [];
          if (!catOverlayEnabled) {
              return { geometries, routeIds };
          }
          catRoutePatternGeometries.forEach((geometry, patternKey) => {
              if (!geometry || !Array.isArray(geometry.latLngs) || geometry.latLngs.length < 2) {
                  return;
              }
              if (!isCatRouteVisible(geometry.routeKey)) {
                  return;
              }
              const numericId = ensureCatOverlapPatternEntry(patternKey, geometry);
              if (!Number.isFinite(numericId)) {
                  return;
              }
              geometries.set(numericId, geometry.latLngs);
              routeIds.push(numericId);
          });
          return {
              geometries,
              routeIds: mergeNumericRouteIds(routeIds)
          };
      }

      function getRouteGeometrySignature(routeId, geometryMap = currentTranslocRendererGeometries) {
          const numeric = Number(routeId);
          if (!Number.isNaN(numeric) && routePolylineCache.has(numeric)) {
              const cacheEntry = routePolylineCache.get(numeric);
              if (cacheEntry && typeof cacheEntry.encoded === 'string') {
                  return cacheEntry.encoded;
              }
          }
          if (!Number.isNaN(numeric) && catOverlapInfoByNumericId.has(numeric)) {
              const info = catOverlapInfoByNumericId.get(numeric);
              if (info && info.geometrySignature) {
                  return info.geometrySignature;
              }
          }
          if (geometryMap instanceof Map && geometryMap.has(numeric)) {
              return buildLatLngSignature(geometryMap.get(numeric));
          }
          return '';
      }

      function getUniqueCatRoutes() {
          const unique = new Map();
          catRoutesById.forEach(route => {
              if (!route || typeof route !== 'object') {
                  return;
              }
              const key = route.idKey ? `${route.idKey}`.trim() : '';
              if (!key || key === CAT_OUT_OF_SERVICE_ROUTE_KEY || unique.has(key)) {
                  return;
              }
              unique.set(key, route);
          });
          return Array.from(unique.values());
      }

      function getSortedCatRoutes() {
          const routes = getUniqueCatRoutes();
          routes.sort((a, b) => {
              const nameA = (a.displayName || a.shortName || a.longName || a.idKey || '').trim().toUpperCase();
              const nameB = (b.displayName || b.shortName || b.longName || b.idKey || '').trim().toUpperCase();
              if (nameA < nameB) return -1;
              if (nameA > nameB) return 1;
              return 0;
          });
          return routes;
      }

      function getCatRouteCheckboxId(routeKey) {
          const normalized = catRouteKey(routeKey);
          const safeId = normalized ? normalized.replace(/[^A-Za-z0-9_-]/g, '_') : 'unassigned';
          return `cat_route_${safeId}`;
      }

      function getCatRouteSelectionState(routeKey, activeFallbackSet = catActiveRouteKeys) {
          const normalized = catRouteKey(routeKey);
          if (!normalized) {
              return false;
          }
          if (normalized === CAT_OUT_OF_SERVICE_ROUTE_KEY) {
              return isOutOfServiceRouteVisible();
          }
          if (catRouteSelections.has(normalized)) {
              return !!catRouteSelections.get(normalized);
          }
          return activeFallbackSet instanceof Set ? activeFallbackSet.has(normalized) : false;
      }

      function isOutOfServiceRouteVisible() {
          if (!canDisplayRoute(0)) {
              return false;
          }
          if (Object.prototype.hasOwnProperty.call(routeSelections, 0)) {
              return !!routeSelections[0];
          }
          return activeRoutes instanceof Set ? activeRoutes.has(0) : false;
      }

      function getEffectiveCatRouteKey(vehicle) {
          if (!vehicle || typeof vehicle !== 'object') {
              return CAT_OUT_OF_SERVICE_ROUTE_KEY;
          }
          const candidates = [vehicle.routeKey, vehicle.routeId];
          for (let i = 0; i < candidates.length; i += 1) {
              const normalized = catRouteKey(candidates[i]);
              if (normalized) {
                  return normalized;
              }
          }
          return CAT_OUT_OF_SERVICE_ROUTE_KEY;
      }

      function isCatRouteVisible(routeKey, activeFallbackSet = catActiveRouteKeys) {
          if (isCatOutOfServiceRouteValue(routeKey)) {
              return isOutOfServiceRouteVisible();
          }
          const normalized = catRouteKey(routeKey);
          if (!normalized) {
              return false;
          }
          if (catRouteSelections.has(normalized)) {
              return !!catRouteSelections.get(normalized);
          }
          return activeFallbackSet instanceof Set ? activeFallbackSet.has(normalized) : false;
      }

      function toNonEmptyString(value) {
          if (value === undefined || value === null) {
              return '';
          }
          const text = `${value}`.trim();
          return text;
      }

      function toNumberOrNull(value) {
          const num = Number(value);
          return Number.isFinite(num) ? num : null;
      }

      function getFirstDefined(source, keys) {
          if (!source || typeof source !== 'object' || !Array.isArray(keys)) {
              return undefined;
          }
          for (const key of keys) {
              if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== undefined && source[key] !== null) {
                  return source[key];
              }
          }
          return undefined;
      }

      function toCatLatLng(latCandidate, lonCandidate) {
          let lat = Number(latCandidate);
          let lon = Number(lonCandidate);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
              return null;
          }
          if (Math.abs(lat) > 90 && Math.abs(lon) <= 90) {
              const swappedLat = Number(lonCandidate);
              const swappedLon = Number(latCandidate);
              if (Number.isFinite(swappedLat) && Number.isFinite(swappedLon)) {
                  lat = swappedLat;
                  lon = swappedLon;
              }
          }
          if (Math.abs(lat) > 90 || Math.abs(lon) > 180) {
              return null;
          }
          try {
              return L.latLng(lat, lon);
          } catch (error) {
              return null;
          }
      }

      function decodeCatPolyline(encoded) {
          if (typeof encoded !== 'string') {
              return [];
          }
          const trimmed = encoded.trim();
          if (trimmed.length === 0) {
              return [];
          }
          try {
              const coords = polyline.decode(trimmed);
              if (!Array.isArray(coords)) {
                  return [];
              }
              return coords
                  .map(pair => {
                      if (!Array.isArray(pair) || pair.length < 2) {
                          return null;
                      }
                      const lat = Number(pair[0]);
                      const lon = Number(pair[1]);
                      if (!Number.isFinite(lat) || !Number.isFinite(lon)) {
                          return null;
                      }
                      try {
                          return L.latLng(lat, lon);
                      } catch (error) {
                          return null;
                      }
                  })
                  .filter(Boolean);
          } catch (error) {
              console.warn('Failed to decode CAT pattern polyline:', error);
              return [];
          }
      }

      function normalizeCatPatternCoordinates(entry) {
          const encoded = toNonEmptyString(getFirstDefined(entry, [
              'encLine',
              'EncLine',
              'encodedPolyline',
              'EncodedPolyline',
              'polyline',
              'Polyline'
          ]));
          if (encoded) {
              const encodedCoords = decodeCatPolyline(encoded);
              if (encodedCoords.length >= 2) {
                  return { latLngs: encodedCoords, encoded };
              }
          }

          const decodedLine = entry && typeof entry === 'object'
              ? (entry.decLine || entry.DecLine || entry.decodedLine || entry.DecodedLine)
              : null;
          const latLngs = [];
          if (Array.isArray(decodedLine)) {
              decodedLine.forEach(point => {
                  let candidate = null;
                  if (Array.isArray(point) && point.length >= 2) {
                      candidate = toCatLatLng(point[0], point[1]) || toCatLatLng(point[1], point[0]);
                  } else if (point && typeof point === 'object') {
                      const latValue = getFirstDefined(point, ['lat', 'Lat', 'latitude', 'Latitude', 'y', 'Y']);
                      const lonValue = getFirstDefined(point, ['lon', 'Lon', 'lng', 'Lng', 'long', 'Long', 'longitude', 'Longitude', 'x', 'X']);
                      candidate = toCatLatLng(latValue, lonValue);
                  }
                  if (candidate) {
                      latLngs.push(candidate);
                  }
              });
          }

          if (latLngs.length >= 2) {
              return { latLngs, encoded: encoded || '' };
          }

          return { latLngs: [], encoded: encoded || '' };
      }

      function extractCatArray(root, candidateKeys = []) {
          if (Array.isArray(root)) {
              return root;
          }
          if (!root || typeof root !== 'object') {
              return [];
          }
          const candidateList = Array.isArray(candidateKeys) ? candidateKeys : (candidateKeys ? [candidateKeys] : []);
          const extendedCandidateKeys = candidateList.concat([
                  'get_routes',
                  'get_stops',
                  'get_vehicles',
                  'get_patterns',
                  'get_service_announcements',
                  'GetRoutes',
                  'GetStops',
                  'GetVehicles',
                  'GetPatterns',
                  'GetServiceAnnouncements'
              ]);
          for (const key of extendedCandidateKeys) {
              const value = root[key];
              if (Array.isArray(value)) {
                  return value;
              }
          }
          const fallbackKeys = ['data', 'Data', 'result', 'Result', 'results', 'Results', 'items', 'Items', 'values', 'Values'];
          for (const key of fallbackKeys) {
              const value = root[key];
              if (Array.isArray(value)) {
                  return value;
              }
          }
          for (const key of Object.keys(root)) {
              const value = root[key];
              if (Array.isArray(value)) {
                  return value;
              }
          }
          return [];
      }

      function normalizeCatRoute(entry) {
          if (!entry || typeof entry !== 'object') {
              return null;
          }
          const rawId = getFirstDefined(entry, ['RouteID', 'routeID', 'RouteId', 'routeId', 'ID', 'Id', 'id']);
          const idKey = catRouteKey(rawId);
          if (!idKey || idKey === CAT_OUT_OF_SERVICE_ROUTE_KEY) {
              return null;
          }
          const numericId = toNumberOrNull(rawId);
          const colorValue = getFirstDefined(entry, ['Color', 'color', 'RouteColor', 'RouteHexColor', 'HexColor', 'DisplayColor', 'MapColor', 'RGB']);
          const color = sanitizeCssColor(colorValue) || CAT_VEHICLE_MARKER_DEFAULT_COLOR;
          const shortName = toNonEmptyString(getFirstDefined(entry, ['RouteAbbreviation', 'routeAbbreviation', 'RouteShortName', 'routeShortName', 'ShortName', 'shortName', 'Abbreviation', 'abbreviation', 'abbr']));
          const longName = toNonEmptyString(getFirstDefined(entry, ['RouteName', 'routeName', 'Description', 'description', 'LongName', 'longName', 'Name', 'name']));
          const displayName = shortName || longName || `Route ${idKey}`;
          return {
              id: numericId,
              idKey,
              color,
              shortName,
              longName,
              displayName
          };
      }

      function normalizeCatRoutes(root) {
          const entries = extractCatArray(root, ['routes', 'Routes']);
          const routes = [];
          entries.forEach(entry => {
              const normalized = normalizeCatRoute(entry);
              if (normalized) {
                  routes.push(normalized);
              }
          });
          return routes;
      }

      function normalizeCatPattern(entry) {
          if (!entry || typeof entry !== 'object') {
              return null;
          }

          const coordinates = normalizeCatPatternCoordinates(entry);
          if (!Array.isArray(coordinates.latLngs) || coordinates.latLngs.length < 2) {
              return null;
          }

          const routeCandidates = [];
          [entry.routes, entry.Routes, entry.routeIDs, entry.RouteIDs, entry.routeIds, entry.RouteIds]
              .filter(Array.isArray)
              .forEach(list => {
                  list.forEach(value => routeCandidates.push(value));
              });
          [
              entry.routeID,
              entry.RouteID,
              entry.routeId,
              entry.RouteId,
              entry.route,
              entry.Route
          ].forEach(value => {
              if (value !== undefined && value !== null) {
                  routeCandidates.push(value);
              }
          });

          const extIdText = toNonEmptyString(getFirstDefined(entry, ['extID', 'ExtID', 'externalId', 'ExternalId']));
          if (extIdText) {
              const extMatch = extIdText.match(/^(\s*\d+)/);
              if (extMatch && extMatch[1]) {
                  routeCandidates.push(extMatch[1]);
              }
          }

          const nameText = toNonEmptyString(getFirstDefined(entry, ['name', 'Name']));
          if (nameText) {
              const nameMatch = nameText.match(/^(\s*\d+)/);
              if (nameMatch && nameMatch[1]) {
                  routeCandidates.push(nameMatch[1]);
              }
          }

          const uniqueRouteKeys = new Set();
          routeCandidates.forEach(value => {
              const key = catRouteKey(value);
              if (key && key !== CAT_OUT_OF_SERVICE_ROUTE_KEY) {
                  uniqueRouteKeys.add(key);
              }
          });

          if (uniqueRouteKeys.size === 0) {
              return null;
          }

          const colorValue = sanitizeCssColor(getFirstDefined(entry, [
              'color',
              'Color',
              'routeColor',
              'RouteColor',
              'lineColor',
              'LineColor',
              'displayColor',
              'DisplayColor'
          ]));

          const idText = toNonEmptyString(getFirstDefined(entry, ['id', 'Id', 'patternId', 'PatternId', 'PatternID', 'patternID']));

          return {
              id: idText,
              extId: extIdText,
              name: nameText,
              routeKeys: Array.from(uniqueRouteKeys.values()),
              latLngs: coordinates.latLngs,
              color: colorValue || '',
              encoded: coordinates.encoded || ''
          };
      }

      function normalizeCatPatterns(root) {
          const entries = extractCatArray(root, ['patterns', 'Patterns']);
          const patterns = [];
          entries.forEach(entry => {
              const normalized = normalizeCatPattern(entry);
              if (normalized) {
                  patterns.push(normalized);
              }
          });
          return patterns;
      }

      async function fetchCatRoutes(force = false) {
          if (!catOverlayEnabled && !force) {
              return [];
          }
          const now = Date.now();
          if (!force && catRoutesById.size > 0 && (now - catRoutesLastFetchTime) < CAT_METADATA_REFRESH_INTERVAL_MS) {
              return Array.from(catRoutesById.values());
          }
          const params = new URLSearchParams({ service: 'get_routes', token: CAT_API_TOKEN });
          const url = `${CAT_API_BASE_URL}?${params.toString()}`;
          try {
              const response = await fetch(url, { cache: 'no-store' });
              if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
              }
              const payload = await response.json();
              const routes = normalizeCatRoutes(payload);
              if (!catOverlayEnabled && !force) {
                  return routes;
              }
              catRoutesById.clear();
              routes.forEach(route => {
                  if (!route || route.idKey === CAT_OUT_OF_SERVICE_ROUTE_KEY) {
                      return;
                  }
                  catRoutesById.set(route.idKey, route);
                  catRoutesById.set(`${route.idKey}`, route);
                  if (Number.isFinite(route.id)) {
                      catRoutesById.set(`${route.id}`, route);
                  }
              });
              catRoutesLastFetchTime = now;
              if (catOverlayEnabled) {
                  updateRouteSelector(activeRoutes);
                  renderCatRoutes();
              }
              return routes;
          } catch (error) {
              console.error('Failed to fetch CAT routes:', error);
              return [];
          }
      }

      function normalizeCatStop(entry) {
          if (!entry || typeof entry !== 'object') {
              return null;
          }
          const rawId = getFirstDefined(entry, ['StopID', 'stopID', 'StopId', 'stopId', 'ID', 'Id', 'id']);
          const idKey = catStopKey(rawId);
          if (!idKey) {
              return null;
          }
          const name = toNonEmptyString(getFirstDefined(entry, ['StopName', 'stopName', 'Name', 'name', 'Description', 'description'])) || `Stop ${idKey}`;
          const lat = toNumberOrNull(getFirstDefined(entry, ['Latitude', 'latitude', 'Lat', 'lat']));
          const lon = toNumberOrNull(getFirstDefined(entry, ['Longitude', 'longitude', 'Lon', 'lon', 'Lng', 'lng']));
          return {
              id: idKey,
              rawId,
              name,
              latitude: lat,
              longitude: lon
          };
      }

      function normalizeCatStops(root) {
          const entries = extractCatArray(root, ['stops', 'Stops']);
          const stops = [];
          entries.forEach(entry => {
              const normalized = normalizeCatStop(entry);
              if (normalized) {
                  stops.push(normalized);
              }
          });
          return stops;
      }

      async function fetchCatStops(force = false) {
          if (!catOverlayEnabled && !force) {
              return [];
          }
          const now = Date.now();
          if (!force && catStopsById.size > 0 && (now - catStopsLastFetchTime) < CAT_METADATA_REFRESH_INTERVAL_MS) {
              return Array.from(catStopsById.values());
          }
          const params = new URLSearchParams({ service: 'get_stops', token: CAT_API_TOKEN });
          const url = `${CAT_API_BASE_URL}?${params.toString()}`;
          try {
              const response = await fetch(url, { cache: 'no-store' });
              if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
              }
              const payload = await response.json();
              const stops = normalizeCatStops(payload);
              if (!catOverlayEnabled && !force) {
                  return stops;
              }
              catStopsById.clear();
              stops.forEach(stop => {
                  catStopsById.set(stop.id, stop);
              });
              catStopsLastFetchTime = now;
              return stops;
          } catch (error) {
              console.error('Failed to fetch CAT stops:', error);
              return [];
          }
      }

      async function fetchCatRoutePatterns(force = false) {
          if (!catOverlayEnabled && !force) {
              return catRoutePatternsCache.slice();
          }
          const now = Date.now();
          if (!force && catRoutePatternGeometries.size > 0 && (now - catRoutePatternsLastFetchTime) < CAT_METADATA_REFRESH_INTERVAL_MS) {
              return catRoutePatternsCache.slice();
          }
          const params = new URLSearchParams({ service: 'get_patterns', token: CAT_API_TOKEN });
          const url = `${CAT_API_BASE_URL}?${params.toString()}`;
          try {
              const response = await fetch(url, { cache: 'no-store' });
              if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
              }
              const payload = await response.json();
              const patterns = normalizeCatPatterns(payload);
              if (!catOverlayEnabled && !force) {
                  return patterns;
              }
              const newGeometries = new Map();
              patterns.forEach((pattern, index) => {
                  if (!pattern || !Array.isArray(pattern.routeKeys) || pattern.routeKeys.length === 0) {
                      return;
                  }
                  const baseKey = pattern.id || pattern.extId || pattern.name || (pattern.encoded ? `enc:${pattern.encoded}` : `idx:${index}`);
                  pattern.routeKeys.forEach(routeKey => {
                      const key = `${routeKey}::${baseKey}`;
                      newGeometries.set(key, {
                          routeKey,
                          color: sanitizeCssColor(pattern.color) || '',
                          latLngs: Array.isArray(pattern.latLngs) ? pattern.latLngs.slice() : [],
                          encoded: pattern.encoded || ''
                      });
                  });
              });

              const keysToRemove = new Set(catRoutePatternGeometries.keys());
              newGeometries.forEach((geometry, key) => {
                  catRoutePatternGeometries.set(key, geometry);
                  keysToRemove.delete(key);
              });
              keysToRemove.forEach(key => {
                  catRoutePatternGeometries.delete(key);
                  const numericId = catOverlapPatternIdMap.get(key);
                  if (Number.isFinite(numericId)) {
                      catOverlapPatternIdMap.delete(key);
                      catOverlapInfoByNumericId.delete(numericId);
                  }
              });

              catRoutePatternsLastFetchTime = now;
              catRoutePatternsCache = patterns;
              renderCatRoutes();
              return patterns;
          } catch (error) {
              console.error('Failed to fetch CAT route patterns:', error);
              return [];
          }
      }

      function normalizeCatEta(entry) {
          if (!entry || typeof entry !== 'object') {
              return null;
          }
          const rawStopId = getFirstDefined(entry, ['StopID', 'stopID', 'StopId', 'stopId', 'Stop', 'stop']);
          const stopId = catStopKey(rawStopId);
          const stopInfo = stopId ? catStopsById.get(stopId) : null;
          const stopName = toNonEmptyString(getFirstDefined(entry, ['StopName', 'stopName', 'Name', 'name', 'Description', 'description'])) || (stopInfo ? stopInfo.name : '');
          let minutes = toNumberOrNull(getFirstDefined(entry, ['Minutes', 'minutes', 'Min', 'min', 'EtaMinutes', 'etaMinutes']));
          const seconds = toNumberOrNull(getFirstDefined(entry, ['Seconds', 'seconds', 'Sec', 'sec', 'EtaSeconds', 'etaSeconds']));
          if (!Number.isFinite(minutes) && Number.isFinite(seconds)) {
              minutes = seconds / 60;
          }
          let text = toNonEmptyString(getFirstDefined(entry, ['DisplayTime', 'displayTime', 'Display', 'display', 'Text', 'text', 'Formatted', 'formatted']));
          if (!text) {
              if (Number.isFinite(minutes)) {
                  const rounded = Math.max(0, Math.round(minutes));
                  text = rounded <= 0 ? 'Due' : `${rounded} min`;
              } else if (Number.isFinite(seconds)) {
                  const roundedSeconds = Math.max(0, Math.round(seconds));
                  text = roundedSeconds <= 30 ? 'Due' : `${Math.round(roundedSeconds / 60)} min`;
              }
          }
          if (!text) {
              const fallbackTime = toNonEmptyString(getFirstDefined(entry, ['Time', 'time', 'ArrivalTime', 'arrivalTime', 'Scheduled', 'scheduled']));
              if (fallbackTime) {
                  text = fallbackTime;
              }
          }
          return {
              stopId,
              stopName,
              minutes: Number.isFinite(minutes) ? minutes : null,
              seconds: Number.isFinite(seconds) ? seconds : null,
              text: text || ''
          };
      }

      function normalizeCatEtas(root) {
          const entries = extractCatArray(root, ['ETAs', 'etas', 'Eta', 'eta', 'Predictions', 'predictions']);
          const etas = [];
          entries.forEach(entry => {
              const normalized = normalizeCatEta(entry);
              if (normalized) {
                  etas.push(normalized);
              }
          });
          return etas;
      }

      function normalizeCatVehicle(entry) {
          if (!entry || typeof entry !== 'object') {
              return null;
          }
          const rawId = getFirstDefined(entry, ['VehicleID', 'vehicleID', 'VehicleId', 'vehicleId', 'ID', 'Id', 'id', 'Name', 'name', 'EquipmentID', 'equipmentID', 'EquipmentId', 'equipmentId']);
          const vehicleId = toNonEmptyString(rawId);
          if (!vehicleId) {
              return null;
          }
          const latitude = toNumberOrNull(getFirstDefined(entry, ['Latitude', 'latitude', 'Lat', 'lat']));
          const longitude = toNumberOrNull(getFirstDefined(entry, ['Longitude', 'longitude', 'Lon', 'lon', 'Lng', 'lng']));
          if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
              return null;
          }
          const heading = toNumberOrNull(getFirstDefined(entry, ['Heading', 'heading', 'Direction', 'direction']));
          const speed = toNumberOrNull(getFirstDefined(entry, ['Speed', 'speed', 'Velocity', 'velocity', 'GpsSpeed', 'GPSSpeed', 'GroundSpeed', 'groundSpeed']));
          const rawRouteId = getFirstDefined(entry, ['RouteID', 'routeID', 'RouteId', 'routeId', 'Route', 'route']);
          const routeKey = catRouteKey(rawRouteId);
          const routeAbbrev = toNonEmptyString(getFirstDefined(entry, ['RouteAbbreviation', 'routeAbbreviation', 'RouteShortName', 'routeShortName', 'ShortName', 'shortName']));
          const routeName = toNonEmptyString(getFirstDefined(entry, ['RouteName', 'routeName', 'Description', 'description']));
          const displayName = toNonEmptyString(getFirstDefined(entry, ['VehicleName', 'vehicleName', 'Name', 'name', 'Label', 'label'])) || `Vehicle ${vehicleId}`;
          const etas = normalizeCatEtas(getFirstDefined(entry, ['ETAs', 'etas', 'Eta', 'eta', 'Predictions', 'predictions']));
          return {
              id: vehicleId,
              latitude,
              longitude,
              heading,
              speed,
              routeKey,
              routeId: rawRouteId,
              routeAbbrev,
              routeName,
              displayName,
              etas
          };
      }

      function normalizeCatVehicles(root) {
          const entries = extractCatArray(root, ['vehicles', 'Vehicles']);
          const vehicles = [];
          entries.forEach(entry => {
              const normalized = normalizeCatVehicle(entry);
              if (normalized) {
                  vehicles.push(normalized);
              }
          });
          return vehicles;
      }

      function getCatRouteInfo(routeKey) {
          if (!routeKey) {
              return null;
          }
          const key = `${routeKey}`.trim();
          if (key === '' || key === CAT_OUT_OF_SERVICE_ROUTE_KEY) {
              return null;
          }
          if (catRoutesById.has(key)) {
              return catRoutesById.get(key);
          }
          if (Number.isFinite(Number(routeKey))) {
              const numericKey = `${Number(routeKey)}`;
              return catRoutesById.get(numericKey) || null;
          }
          return null;
      }

      function getCatRouteColor(routeKey) {
          const routeInfo = getCatRouteInfo(routeKey);
          if (routeInfo && routeInfo.color) {
              return routeInfo.color;
          }
          return CAT_VEHICLE_MARKER_DEFAULT_COLOR;
      }

      function buildLegacyCatVehicleIcon(label, color) {
          const fallbackLabel = label || CAT_VEHICLE_MARKER_MIN_LABEL;
          const safeColor = escapeAttribute(color || CAT_VEHICLE_MARKER_DEFAULT_COLOR);
          const safeLabel = escapeHtml(fallbackLabel);
          const html = `<div class="cat-vehicle-marker" style="--cat-marker-color:${safeColor};"><span class="cat-vehicle-marker__label">${safeLabel}</span></div>`;
          return L.divIcon({ className: 'cat-vehicle-icon', html, iconSize: [38, 38], iconAnchor: [19, 19] });
      }

      function buildCatVehicleIcon(vehicle, routeKeyOverride) {
          if (!vehicle || !vehicle.id) {
              return null;
          }
          const effectiveRouteKey = routeKeyOverride || vehicle.catEffectiveRouteKey || getEffectiveCatRouteKey(vehicle);
          const routeInfo = getCatRouteInfo(effectiveRouteKey);
          const label = vehicle.routeAbbrev
              || routeInfo?.shortName
              || routeInfo?.displayName
              || vehicle.routeName
              || vehicle.id
              || CAT_VEHICLE_MARKER_MIN_LABEL;
          const routeColor = sanitizeCssColor(getCatRouteColor(effectiveRouteKey)) || CAT_VEHICLE_MARKER_DEFAULT_COLOR;
          const headingDeg = normalizeHeadingDegrees(Number(vehicle.heading));
          const groundSpeed = Number(vehicle.speed);
          const accessibleName = vehicle.displayName || label;
          const accessibleLabel = buildBusMarkerAccessibleLabel(accessibleName, headingDeg, groundSpeed);
          const glyphColor = computeBusMarkerGlyphColor(routeColor);
          const markerMetrics = computeBusMarkerMetrics(map && typeof map?.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM);
          const state = {
              fillColor: routeColor,
              glyphColor,
              accessibleLabel,
              headingDeg,
              isStopped: isBusConsideredStopped(groundSpeed),
              isStale: false,
              isSelected: false,
              isHovered: false,
              size: {
                  widthPx: markerMetrics.widthPx,
                  heightPx: markerMetrics.heightPx,
                  scale: markerMetrics.scale
              }
          };
          const icon = BUS_MARKER_SVG_TEXT ? buildBusMarkerDivIconSync(`cat-${vehicle.id}`, state) : null;
          if (icon) {
              return icon;
          }
          return buildLegacyCatVehicleIcon(label, routeColor);
      }

      function buildCatVehicleTooltip(vehicle, routeKeyOverride) {
          const parts = [];
          const headerPieces = [];
          const effectiveRouteKey = routeKeyOverride || vehicle.catEffectiveRouteKey || getEffectiveCatRouteKey(vehicle);
          const routeInfo = getCatRouteInfo(effectiveRouteKey);
          const routeLabel = vehicle.routeAbbrev || routeInfo?.shortName || routeInfo?.displayName || vehicle.routeName;
          if (routeLabel) {
              headerPieces.push(routeLabel);
          }
          if (vehicle.displayName && vehicle.displayName !== routeLabel) {
              headerPieces.push(vehicle.displayName);
          }
          if (headerPieces.length) {
              parts.push(`<strong>${escapeHtml(headerPieces.join('  '))}</strong>`);
          }
          const etaLines = [];
          const etas = Array.isArray(vehicle.etas) ? vehicle.etas.slice(0, CAT_MAX_TOOLTIP_ETAS) : [];
          etas.forEach(eta => {
              const stopLabel = eta.stopName || (eta.stopId ? `Stop ${eta.stopId}` : 'Stop');
              const text = eta.text || (Number.isFinite(eta.minutes) ? `${Math.max(0, Math.round(eta.minutes))} min` : 'Scheduled');
              etaLines.push(`<span>${escapeHtml(stopLabel)}: ${escapeHtml(text)}</span>`);
          });
          if (etaLines.length) {
              parts.push(`<div class="cat-vehicle-tooltip__etas">${etaLines.join('')}</div>`);
          } else {
              parts.push(`<span>${escapeHtml('No upcoming ETAs')}</span>`);
          }
          return parts.join('');
      }

      function updateCatVehicleCache(vehicles) {
          catVehiclesById.clear();
          const activeKeys = new Set();
          if (!Array.isArray(vehicles)) {
              catActiveRouteKeys = activeKeys;
              return;
          }
          vehicles.forEach(vehicle => {
              if (!vehicle || typeof vehicle !== 'object') {
                  return;
              }
              const vehicleId = vehicle.id;
              if (!vehicleId) {
                  return;
              }
              const effectiveRouteKey = getEffectiveCatRouteKey(vehicle);
              const cachedVehicle = Object.assign({}, vehicle, { catEffectiveRouteKey: effectiveRouteKey });
              catVehiclesById.set(vehicleId, cachedVehicle);
              if (effectiveRouteKey !== CAT_OUT_OF_SERVICE_ROUTE_KEY) {
                  activeKeys.add(effectiveRouteKey);
              }
          });
          catActiveRouteKeys = activeKeys;
          renderCatRoutes();
      }

      function renderCatVehiclesUsingCache() {
          if (!catOverlayEnabled) {
              return;
          }
          const busMarkerReady = !!BUS_MARKER_SVG_TEXT;
          if (!busMarkerReady) {
              ensureCatBusMarkerSvgLoaded().then(loaded => {
                  if (loaded && catOverlayEnabled) {
                      renderCatVehiclesUsingCache();
                  }
              });
          }
          const layerGroup = ensureCatLayerGroup();
          if (!layerGroup) {
              return;
          }
          const seen = new Set();
          catVehiclesById.forEach(vehicle => {
              if (!vehicle || !vehicle.id) {
                  return;
              }
              const markerKey = `cat-${vehicle.id}`;
              const effectiveRouteKey = vehicle.catEffectiveRouteKey || getEffectiveCatRouteKey(vehicle);
              const shouldDisplay = isCatRouteVisible(effectiveRouteKey);
              let marker = catVehicleMarkers.get(markerKey);
              if (!shouldDisplay) {
                  if (marker) {
                      if (layerGroup.hasLayer(marker)) {
                          layerGroup.removeLayer(marker);
                      }
                      if (typeof marker.remove === 'function') {
                          marker.remove();
                      }
                      catVehicleMarkers.delete(markerKey);
                  }
                  return;
              }
              seen.add(markerKey);
              const icon = buildCatVehicleIcon(vehicle, effectiveRouteKey);
              if (!marker) {
                  marker = L.marker([vehicle.latitude, vehicle.longitude], { icon, pane: catVehiclesPaneName, keyboard: false });
                  marker.addTo(layerGroup);
                  catVehicleMarkers.set(markerKey, marker);
              } else {
                  marker.setLatLng([vehicle.latitude, vehicle.longitude]);
                  marker.setIcon(icon);
                  if (!layerGroup.hasLayer(marker)) {
                      layerGroup.addLayer(marker);
                  }
              }
              const tooltipHtml = buildCatVehicleTooltip(vehicle, effectiveRouteKey);
              const existingTooltip = marker.getTooltip && marker.getTooltip();
              if (tooltipHtml) {
                  if (existingTooltip) {
                      existingTooltip.setContent(tooltipHtml);
                  } else {
                      marker.bindTooltip(tooltipHtml, { direction: 'top', offset: [0, -26], className: 'cat-vehicle-tooltip' });
                  }
              } else if (existingTooltip) {
                  marker.unbindTooltip();
              }
          });
          catVehicleMarkers.forEach((marker, key) => {
              if (!seen.has(key)) {
                  if (catLayerGroup && catLayerGroup.hasLayer(marker)) {
                      catLayerGroup.removeLayer(marker);
                  }
                  if (marker && typeof marker.remove === 'function') {
                      marker.remove();
                  }
                  catVehicleMarkers.delete(key);
              }
          });
      }

      function removeCatRouteLayer(layer) {
          if (!layer) {
              return;
          }
          if (catLayerGroup && catLayerGroup.hasLayer(layer)) {
              catLayerGroup.removeLayer(layer);
          }
          if (typeof layer.remove === 'function') {
              layer.remove();
          }
      }

      function clearCatRouteLayers() {
          catRoutePatternLayers.forEach(layer => {
              removeCatRouteLayer(layer);
          });
          catRoutePatternLayers.clear();
      }

      function renderCatRoutes() {
          if (!catOverlayEnabled) {
              clearCatRouteLayers();
              if (enableOverlapDashRendering && overlapRenderer) {
                  updateOverlapRendererWithCatRoutes();
              }
              return;
          }
          if (enableOverlapDashRendering && overlapRenderer) {
              clearCatRouteLayers();
              updateOverlapRendererWithCatRoutes();
              return;
          }
          const layerGroup = ensureCatLayerGroup();
          if (!layerGroup || !map) {
              return;
          }
          const zoom = typeof map?.getZoom === 'function' ? map.getZoom() : null;
          const strokeWeight = computeRouteStrokeWeight(zoom);
          const seenKeys = new Set();

          catRoutePatternGeometries.forEach((geometry, key) => {
              if (!geometry || !Array.isArray(geometry.latLngs) || geometry.latLngs.length < 2) {
                  const existingLayer = catRoutePatternLayers.get(key);
                  if (existingLayer) {
                      removeCatRouteLayer(existingLayer);
                      catRoutePatternLayers.delete(key);
                  }
                  return;
              }
              const routeKey = geometry.routeKey;
              if (!isCatRouteVisible(routeKey)) {
                  const existingLayer = catRoutePatternLayers.get(key);
                  if (existingLayer) {
                      removeCatRouteLayer(existingLayer);
                      catRoutePatternLayers.delete(key);
                  }
                  return;
              }
              const color = sanitizeCssColor(geometry.color) || sanitizeCssColor(getCatRouteColor(routeKey)) || CAT_VEHICLE_MARKER_DEFAULT_COLOR;
              const options = {
                  color,
                  weight: strokeWeight,
                  opacity: 1,
                  lineCap: 'round',
                  lineJoin: 'round'
              };
              let layer = catRoutePatternLayers.get(key);
              if (!layer) {
                  layer = L.polyline(geometry.latLngs, mergeRouteLayerOptions(options));
                  layer.addTo(layerGroup);
                  catRoutePatternLayers.set(key, layer);
              } else {
                  if (typeof layer.setLatLngs === 'function') {
                      layer.setLatLngs(geometry.latLngs);
                  }
                  if (typeof layer.setStyle === 'function') {
                      layer.setStyle(options);
                  }
                  if (!layerGroup.hasLayer(layer)) {
                      layerGroup.addLayer(layer);
                  }
              }
              seenKeys.add(key);
          });

          catRoutePatternLayers.forEach((layer, key) => {
              if (!seenKeys.has(key)) {
                  removeCatRouteLayer(layer);
                  catRoutePatternLayers.delete(key);
              }
          });
      }

      function clearCatVehicleMarkers() {
          catVehicleMarkers.forEach(marker => {
              if (catLayerGroup) {
                  catLayerGroup.removeLayer(marker);
              }
              if (marker && typeof marker.remove === 'function') {
                  marker.remove();
              }
          });
          catVehicleMarkers.clear();
          catVehiclesById.clear();
          catActiveRouteKeys = new Set();
          clearCatRouteLayers();
      }

      function updateCatVehicleMarkers(vehicles) {
          if (!catOverlayEnabled) {
              return;
          }
          updateCatVehicleCache(vehicles);
          renderCatVehiclesUsingCache();
          updateRouteSelector(activeRoutes);
      }

      function updateOverlapRendererWithCatRoutes() {
          if (!enableOverlapDashRendering || !overlapRenderer) {
              return;
          }
          const baseGeometries = currentTranslocRendererGeometries instanceof Map
              ? new Map(currentTranslocRendererGeometries)
              : new Map();
          const baseRouteIds = Array.isArray(currentTranslocSelectedRouteIds)
              ? currentTranslocSelectedRouteIds.slice()
              : [];
          const catData = buildCatOverlapRendererData();
          catData.geometries.forEach((latLngs, routeId) => {
              baseGeometries.set(routeId, latLngs);
          });
          const combinedRouteIds = mergeNumericRouteIds(baseRouteIds, catData.routeIds);
          const selectionKey = combinedRouteIds.join('|');
          const colorSignature = combinedRouteIds.map(id => `${id}:${getRouteColor(id)}`).join('|');
          const geometrySignature = combinedRouteIds
              .map(id => `${id}:${getRouteGeometrySignature(id, baseGeometries)}`)
              .join('|');
          const rendererFlag = true;
          const shouldUpdate = routeLayers.length === 0
              || !lastRouteRenderState.useOverlapRenderer
              || lastRouteRenderState.selectionKey !== selectionKey
              || lastRouteRenderState.colorSignature !== colorSignature
              || lastRouteRenderState.geometrySignature !== geometrySignature;
          if (!shouldUpdate) {
              return;
          }
          routeLayers.forEach(layer => {
              if (layer && map && typeof map.hasLayer === 'function' && map.hasLayer(layer)) {
                  map.removeLayer(layer);
              }
          });
          const layers = overlapRenderer.updateRoutes(baseGeometries, combinedRouteIds);
          routeLayers = layers;
          lastRouteRenderState = {
              selectionKey,
              colorSignature,
              geometrySignature,
              useOverlapRenderer: rendererFlag
          };
      }

      async function fetchCatVehicles() {
          if (!catOverlayEnabled) {
              return [];
          }
          const params = new URLSearchParams({
              service: 'get_vehicles',
              token: CAT_API_TOKEN,
              includeETAData: '1',
              inService: '0',
              orderedETAArray: '1'
          });
          const url = `${CAT_API_BASE_URL}?${params.toString()}`;
          try {
              const response = await fetch(url, { cache: 'no-store' });
              if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
              }
              const payload = await response.json();
              const vehicles = normalizeCatVehicles(payload);
              updateCatVehicleMarkers(vehicles);
              return vehicles;
          } catch (error) {
              console.error('Failed to fetch CAT vehicles:', error);
              return [];
          }
      }

      function normalizeCatServiceAlert(entry) {
          if (!entry || typeof entry !== 'object') {
              return null;
          }
          const id = toNonEmptyString(getFirstDefined(entry, ['ID', 'Id', 'id', 'AlertID', 'alertID', 'alertId', 'Guid', 'guid']));
          const title = toNonEmptyString(getFirstDefined(entry, ['Title', 'title', 'Name', 'name', 'Headline', 'headline'])) || 'Service Alert';
          const message = toNonEmptyString(getFirstDefined(entry, ['Message', 'message', 'Description', 'description', 'Details', 'details']));
          const routesRaw = getFirstDefined(entry, ['Routes', 'routes', 'Route', 'route', 'RouteNames', 'routeNames']);
          let routes = [];
          if (Array.isArray(routesRaw)) {
              routes = routesRaw.map(value => toNonEmptyString(value)).filter(Boolean);
          } else if (typeof routesRaw === 'string') {
              routes = routesRaw.split(/[,;]+/).map(part => part.trim()).filter(Boolean);
          }
          const startRaw = toNonEmptyString(getFirstDefined(entry, ['StartDate', 'startDate', 'Start', 'start', 'Effective', 'effective', 'EffectiveDate', 'effectiveDate']));
          const endRaw = toNonEmptyString(getFirstDefined(entry, ['EndDate', 'endDate', 'End', 'end', 'Expiration', 'expiration', 'Expires', 'expires']));
          const isActiveField = getFirstDefined(entry, ['IsActive', 'isActive', 'Active', 'active', 'Status', 'status']);
          let isActive = undefined;
          if (typeof isActiveField === 'string') {
              isActive = !/^false$/i.test(isActiveField) && !/^inactive$/i.test(isActiveField);
          } else if (typeof isActiveField === 'boolean') {
              isActive = isActiveField;
          } else if (typeof isActiveField === 'number') {
              isActive = isActiveField !== 0;
          }
          if (isActive === undefined && endRaw) {
              const endTime = Date.parse(endRaw);
              if (Number.isFinite(endTime)) {
                  isActive = endTime > Date.now();
              }
          }
          return {
              id,
              title,
              message,
              routes,
              startDisplay: startRaw || '',
              startRaw,
              endDisplay: endRaw || '',
              endRaw,
              isActive: isActive !== undefined ? !!isActive : true
          };
      }

      function normalizeCatServiceAlerts(root) {
          const entries = extractCatArray(root, ['announcements', 'Announcements', 'alerts', 'Alerts']);
          const alerts = [];
          entries.forEach(entry => {
              const normalized = normalizeCatServiceAlert(entry);
              if (normalized) {
                  alerts.push(normalized);
              }
          });
          return alerts;
      }

      async function fetchCatServiceAlerts() {
          if (!catOverlayEnabled) {
              return [];
          }
          if (catServiceAlertsFetchPromise) {
              return catServiceAlertsFetchPromise;
          }
          const now = Date.now();
          if (catServiceAlerts.length > 0 && (now - catServiceAlertsLastFetchTime) < CAT_SERVICE_ALERT_REFRESH_INTERVAL_MS) {
              return catServiceAlerts;
          }
          catServiceAlertsLoading = true;
          catServiceAlertsError = null;
          refreshServiceAlertsUI();
          const params = new URLSearchParams({ service: 'get_service_announcements', token: CAT_API_TOKEN });
          const url = `${CAT_API_BASE_URL}?${params.toString()}`;
          const requestPromise = (async () => {
              const response = await fetch(url, { cache: 'no-store' });
              if (!response.ok) {
                  throw new Error(`HTTP ${response.status}`);
              }
              const payload = await response.json();
              return normalizeCatServiceAlerts(payload);
          })();
          catServiceAlertsFetchPromise = requestPromise;
          try {
              const alerts = await requestPromise;
              if (!catOverlayEnabled) {
                  return alerts;
              }
              catServiceAlerts = alerts;
              catServiceAlertsError = null;
              catServiceAlertsLoading = false;
              catServiceAlertsLastFetchTime = Date.now();
              refreshServiceAlertsUI();
              return alerts;
          } catch (error) {
              console.error('Failed to fetch CAT service alerts:', error);
              if (catOverlayEnabled) {
                  catServiceAlerts = [];
                  catServiceAlertsError = CAT_SERVICE_ALERT_UNAVAILABLE_MESSAGE;
                  catServiceAlertsLoading = false;
                  catServiceAlertsLastFetchTime = Date.now();
                  refreshServiceAlertsUI();
              }
              return [];
          } finally {
              if (catServiceAlertsFetchPromise === requestPromise) {
                  catServiceAlertsFetchPromise = null;
              }
          }
      }

      function updateCatToggleButtonState() {
          const button = document.getElementById('catToggleButton');
          if (!button) {
              return;
          }
          button.classList.toggle('is-active', !!catOverlayEnabled);
          button.setAttribute('aria-pressed', catOverlayEnabled ? 'true' : 'false');
          const indicator = button.querySelector('.toggle-indicator');
          if (indicator) {
              indicator.textContent = catOverlayEnabled ? 'On' : 'Off';
          }
      }

      function ensureBusMarkerState(vehicleID) {
          if (!busMarkerStates[vehicleID]) {
              const defaultRouteColor = BUS_MARKER_DEFAULT_ROUTE_COLOR;
              const cachedHeading = getCachedVehicleHeading(vehicleID);
              busMarkerStates[vehicleID] = {
                  vehicleID,
                  positionHistory: [],
                  headingDeg: Number.isFinite(cachedHeading) ? cachedHeading : BUS_MARKER_DEFAULT_HEADING,
                  fillColor: defaultRouteColor,
                  glyphColor: computeBusMarkerGlyphColor(defaultRouteColor),
                  accessibleLabel: '',
                  isStale: false,
                  isStopped: false,
                  isSelected: false,
                  isHovered: false,
                  lastUpdateTimestamp: 0,
                  size: null,
                  elements: null,
                  marker: null,
                  markerEventsBound: false
              };
          }
          return busMarkerStates[vehicleID];
      }

      function setBusMarkerSize(state, metrics) {
          if (!state || !metrics) {
              return;
          }
          state.size = {
              widthPx: metrics.widthPx,
              heightPx: metrics.heightPx,
              scale: metrics.scale
          };
      }
 
      function computeBusMarkerGlyphColor(routeColor) {
          if (typeof busMarkerContrastOverrideColor === 'string' && busMarkerContrastOverrideColor.trim().length > 0) {
              return busMarkerContrastOverrideColor;
          }
          const fallback = BUS_MARKER_DEFAULT_CONTRAST_COLOR;
          const candidate = typeof routeColor === 'string' && routeColor.trim().length > 0 ? routeColor : BUS_MARKER_DEFAULT_ROUTE_COLOR;
          const contrast = contrastBW(candidate);
          return contrast || fallback;
      }

      function normalizeRouteColor(color) {
          if (typeof color === 'string') {
              const trimmed = color.trim();
              if (trimmed.length > 0) {
                  return trimmed;
              }
          } else if (color !== undefined && color !== null) {
              const stringValue = `${color}`.trim();
              if (stringValue.length > 0) {
                  return stringValue;
              }
          }
          return BUS_MARKER_DEFAULT_ROUTE_COLOR;
      }

      function normalizeGlyphColor(color, routeColor) {
          if (typeof color === 'string') {
              const trimmed = color.trim();
              if (trimmed.length > 0) {
                  return trimmed;
              }
          } else if (color !== undefined && color !== null) {
              const stringValue = `${color}`.trim();
              if (stringValue.length > 0) {
                  return stringValue;
              }
          }
          const fallbackRouteColor = normalizeRouteColor(routeColor);
          return computeBusMarkerGlyphColor(fallbackRouteColor);
      }

      function applyColorsToBusMarkerSvg(svgEl, routeColor, glyphColor) {
          if (!svgEl) {
              return;
          }
          const fillColor = normalizeRouteColor(routeColor);
          const contrastColor = normalizeGlyphColor(glyphColor, fillColor);
          const routeShape = svgEl.querySelector('#route_color');
          const centerRing = svgEl.querySelector(`#${BUS_MARKER_CENTER_RING_ID}`);
          const centerSquare = svgEl.querySelector(`#${BUS_MARKER_STOPPED_SQUARE_ID}`);
          const heading = svgEl.querySelector('#heading');
          if (routeShape) {
              routeShape.setAttribute('fill', fillColor);
              routeShape.style.fill = fillColor;
          }
          if (centerRing) {
              centerRing.setAttribute('fill', contrastColor);
              centerRing.style.fill = contrastColor;
          }
          if (centerSquare) {
              centerSquare.setAttribute('fill', contrastColor);
              centerSquare.style.fill = contrastColor;
          }
          if (heading) {
              heading.setAttribute('fill', contrastColor);
              heading.style.fill = contrastColor;
          }
      }

      function updateBusMarkerColorElements(state) {
          if (!state) {
              return;
          }
          const normalizedFill = normalizeRouteColor(state.fillColor);
          const normalizedGlyph = normalizeGlyphColor(state.glyphColor, normalizedFill);
          state.fillColor = normalizedFill;
          state.glyphColor = normalizedGlyph;
          if (state.elements?.routeColor) {
              state.elements.routeColor.setAttribute('fill', normalizedFill);
              state.elements.routeColor.style.fill = normalizedFill;
          }
          if (state.elements?.centerRing) {
              state.elements.centerRing.setAttribute('fill', normalizedGlyph);
              state.elements.centerRing.style.fill = normalizedGlyph;
          }
          if (state.elements?.centerSquare) {
              state.elements.centerSquare.setAttribute('fill', normalizedGlyph);
              state.elements.centerSquare.style.fill = normalizedGlyph;
          }
          if (state.elements?.heading) {
              state.elements.heading.setAttribute('fill', normalizedGlyph);
              state.elements.heading.style.fill = normalizedGlyph;
          }
      }

      function ensureCenterSquareElement(svgEl) {
          if (!svgEl) {
              return null;
          }
          let square = svgEl.querySelector(`#${BUS_MARKER_STOPPED_SQUARE_ID}`);
          if (square) {
              return square;
          }
          const namespace = 'http://www.w3.org/2000/svg';
          square = document.createElementNS(namespace, 'rect');
          square.setAttribute('id', BUS_MARKER_STOPPED_SQUARE_ID);
          square.setAttribute('width', `${BUS_MARKER_STOPPED_SQUARE_SIZE_PX}`);
          square.setAttribute('height', `${BUS_MARKER_STOPPED_SQUARE_SIZE_PX}`);
          const halfSize = BUS_MARKER_STOPPED_SQUARE_SIZE_PX / 2;
          const x = BUS_MARKER_CENTER_RING_CENTER_X - halfSize;
          const y = BUS_MARKER_CENTER_RING_CENTER_Y - halfSize;
          square.setAttribute('x', x.toFixed(2));
          square.setAttribute('y', y.toFixed(2));
          square.style.display = 'none';
          square.style.pointerEvents = 'none';
          const centerRing = svgEl.querySelector(`#${BUS_MARKER_CENTER_RING_ID}`);
          const centerRingClass = centerRing?.getAttribute('class');
          if (centerRingClass) {
              square.setAttribute('class', centerRingClass);
          }
          const heading = svgEl.querySelector('#heading');
          if (heading && heading.parentNode) {
              heading.parentNode.insertBefore(square, heading);
          } else if (centerRing && centerRing.parentNode) {
              centerRing.parentNode.insertBefore(square, centerRing.nextSibling);
          } else {
              svgEl.appendChild(square);
          }
          return square;
      }

      function setCenterShapeDisplay(centerRing, centerSquare, isStopped) {
          const showSquare = Boolean(isStopped);
          if (centerRing) {
              centerRing.style.display = showSquare ? 'none' : 'inline';
          }
          if (centerSquare) {
              centerSquare.style.display = showSquare ? 'inline' : 'none';
          }
      }

      function applyStoppedVisualStateToSvg(svgEl, isStopped) {
          if (!svgEl) {
              return;
          }
          const centerSquare = ensureCenterSquareElement(svgEl);
          const centerRing = svgEl.querySelector(`#${BUS_MARKER_CENTER_RING_ID}`);
          setCenterShapeDisplay(centerRing, centerSquare, isStopped);
      }

      function ensureBusMarkerStoppedElements(state) {
          if (!state?.elements?.svg) {
              return;
          }
          const square = ensureCenterSquareElement(state.elements.svg);
          if (square) {
              state.elements.centerSquare = square;
          }
          if (!state.elements.centerRing || !state.elements.centerRing.isConnected) {
              const ring = state.elements.svg.querySelector(`#${BUS_MARKER_CENTER_RING_ID}`);
              if (ring) {
                  state.elements.centerRing = ring;
              }
          }
      }

      function applyBusMarkerStoppedVisualState(state) {
          if (!state?.elements?.svg) {
              return;
          }
          ensureBusMarkerStoppedElements(state);
          setCenterShapeDisplay(state.elements.centerRing, state.elements.centerSquare, state.isStopped);
      }

      function setBusMarkerContrastOverrideColor(color) {
          if (typeof color === 'string' && color.trim().length > 0) {
              busMarkerContrastOverrideColor = color.trim();
          } else {
              busMarkerContrastOverrideColor = null;
          }
          Object.keys(busMarkerStates).forEach(vehicleID => {
              const state = busMarkerStates[vehicleID];
              if (!state) {
                  return;
              }
              const routeColor = state.fillColor || BUS_MARKER_DEFAULT_ROUTE_COLOR;
              const glyphColor = computeBusMarkerGlyphColor(routeColor);
              state.glyphColor = glyphColor;
              queueBusMarkerVisualUpdate(vehicleID, { glyphColor });
          });
      }

      if (typeof window !== 'undefined') {
          window.setBusMarkerContrastOverrideColor = setBusMarkerContrastOverrideColor;
      }

      function getTextMeasurementContext() {
          if (!textMeasurementCanvas && typeof document !== 'undefined') {
              textMeasurementCanvas = document.createElement('canvas');
          }
          return textMeasurementCanvas ? textMeasurementCanvas.getContext('2d') : null;
      }

      function measureLabelTextWidth(text, fontSizePx, fontWeight = 'bold') {
          const ctx = getTextMeasurementContext();
          const normalizedFontSize = Math.max(1, Number(fontSizePx) || 0);
          if (!ctx) {
              return (typeof text === 'string' ? text.length : 0) * normalizedFontSize * 0.6;
          }
          ctx.font = `${fontWeight} ${normalizedFontSize}px ${BUS_MARKER_LABEL_FONT_FAMILY}`;
          const metrics = ctx.measureText(text || '');
          return metrics && Number.isFinite(metrics.width)
              ? metrics.width
              : (typeof text === 'string' ? text.length : 0) * normalizedFontSize * 0.6;
      }

      function roundToTwoDecimals(value) {
          return Math.round((Number(value) || 0) * 100) / 100;
      }

      function getBusMarkerVisibleExtents() {
          if (busMarkerVisibleExtents) {
              return busMarkerVisibleExtents;
          }

          const fallbackExtents = {
              top: BUS_MARKER_PIVOT_Y,
              bottom: BUS_MARKER_VIEWBOX_HEIGHT - BUS_MARKER_PIVOT_Y,
              left: BUS_MARKER_PIVOT_X,
              right: BUS_MARKER_VIEWBOX_WIDTH - BUS_MARKER_PIVOT_X
          };

          if (!BUS_MARKER_SVG_TEXT || typeof document === 'undefined') {
              return fallbackExtents;
          }

          try {
              const template = document.createElement('template');
              template.innerHTML = BUS_MARKER_SVG_TEXT.trim();
              const svgEl = template.content.firstElementChild;
              if (!svgEl) {
                  throw new Error('Failed to parse bus marker SVG for bounds computation.');
              }
              const clone = svgEl.cloneNode(true);

              clone.querySelectorAll('rect').forEach(rect => {
                  const width = Number(rect.getAttribute('width'));
                  const height = Number(rect.getAttribute('height'));
                  if (width === 0 && height === 0) {
                      rect.remove();
                  }
              });

              clone.querySelectorAll('circle').forEach(circle => {
                  const radius = Number(circle.getAttribute('r'));
                  if (radius === 0) {
                      circle.remove();
                  }
              });

              clone.setAttribute('width', `${BUS_MARKER_VIEWBOX_WIDTH}`);
              clone.setAttribute('height', `${BUS_MARKER_VIEWBOX_HEIGHT}`);
              clone.style.position = 'absolute';
              clone.style.visibility = 'hidden';
              clone.style.pointerEvents = 'none';
              clone.style.left = '-9999px';
              clone.style.top = '-9999px';

              const host = document.body || document.documentElement;
              if (!host) {
                  throw new Error('Document does not have an attachable host element for bounds computation.');
              }

              host.appendChild(clone);
              let bbox = null;
              try {
                  bbox = clone.getBBox();
              } finally {
                  clone.remove();
              }

              if (bbox && Number.isFinite(bbox.x) && Number.isFinite(bbox.y) && Number.isFinite(bbox.width) && Number.isFinite(bbox.height)) {
                  busMarkerVisibleExtents = {
                      top: BUS_MARKER_PIVOT_Y - bbox.y,
                      bottom: (bbox.y + bbox.height) - BUS_MARKER_PIVOT_Y,
                      left: BUS_MARKER_PIVOT_X - bbox.x,
                      right: (bbox.x + bbox.width) - BUS_MARKER_PIVOT_X
                  };
                  return busMarkerVisibleExtents;
              }
          } catch (error) {
              console.error('Failed to compute bus marker visible extents:', error);
          }

          busMarkerVisibleExtents = fallbackExtents;
          return busMarkerVisibleExtents;
      }

      function computeBusMarkerVerticalExtentsForHeading(headingDeg) {
          const extents = getBusMarkerVisibleExtents();
          if (!extents) {
              return null;
          }

          const normalizedHeading = normalizeHeadingDegrees(Number.isFinite(headingDeg) ? headingDeg : BUS_MARKER_DEFAULT_HEADING);
          const radians = normalizedHeading * Math.PI / 180;
          const sin = Math.sin(radians);
          const cos = Math.cos(radians);

          const corners = [
              { x: -extents.left, y: -extents.top },
              { x: extents.right, y: -extents.top },
              { x: extents.right, y: extents.bottom },
              { x: -extents.left, y: extents.bottom }
          ];

          let minY = Infinity;
          let maxY = -Infinity;
          for (const corner of corners) {
              const rotatedY = corner.x * sin + corner.y * cos;
              if (rotatedY < minY) {
                  minY = rotatedY;
              }
              if (rotatedY > maxY) {
                  maxY = rotatedY;
              }
          }

          if (!Number.isFinite(minY) || !Number.isFinite(maxY)) {
              return null;
          }

          return {
              top: Math.abs(minY),
              bottom: Math.abs(maxY)
          };
      }

      function computeLabelLeaderOffset(scale, headingDeg, position = 'above') {
          const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
          const normalizedHeading = normalizeHeadingDegrees(
              Number.isFinite(headingDeg) ? headingDeg : BUS_MARKER_DEFAULT_HEADING
          );
          const conversionFactor = (BUS_MARKER_BASE_WIDTH_PX * safeScale) / BUS_MARKER_VIEWBOX_WIDTH;
          const fallbackWidth = BUS_MARKER_BASE_WIDTH_PX * safeScale;
          const fallbackHeight = fallbackWidth * BUS_MARKER_ASPECT_RATIO;
          const fallbackHalfDiagonal = Math.sqrt(fallbackWidth * fallbackWidth + fallbackHeight * fallbackHeight) / 2;
          const clearance = LABEL_VERTICAL_CLEARANCE_PX * safeScale;

          const headingRelativeToVertical = normalizedHeading % 180;
          const deviationFromVertical = Math.min(headingRelativeToVertical, 180 - headingRelativeToVertical);
          const verticality = Math.pow(
              Math.max(0, Math.cos(deviationFromVertical * Math.PI / 180)),
              LABEL_VERTICAL_ALIGNMENT_EXPONENT
          );
          const verticalAlignmentBonus = LABEL_VERTICAL_ALIGNMENT_BONUS_PX * safeScale * verticality;
          const horizontalAlignmentBonus = LABEL_HORIZONTAL_ALIGNMENT_BONUS_PX * safeScale * (1 - verticality);

          const verticalExtents = computeBusMarkerVerticalExtentsForHeading(normalizedHeading);
          if (!verticalExtents) {
              return Math.max(0, fallbackHalfDiagonal + clearance + verticalAlignmentBonus + horizontalAlignmentBonus);
          }

          let extentSvgUnits;
          if (position === 'below') {
              extentSvgUnits = verticalExtents.bottom;
          } else if (position === 'above') {
              extentSvgUnits = verticalExtents.top;
          } else {
              extentSvgUnits = Math.max(verticalExtents.top, verticalExtents.bottom);
          }

          if (!Number.isFinite(extentSvgUnits)) {
              return Math.max(0, fallbackHalfDiagonal + clearance + verticalAlignmentBonus + horizontalAlignmentBonus);
          }

          const extentPx = extentSvgUnits * conversionFactor;
          const totalOffset = extentPx + clearance + verticalAlignmentBonus + horizontalAlignmentBonus;
          return totalOffset > 0 ? totalOffset : 0;
      }

      function createSpeedBubbleDivIcon(routeColor, groundSpeed, scale, headingDeg) {
          if (!Number.isFinite(groundSpeed)) {
              return null;
          }
          const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
          const fillColor = typeof routeColor === 'string' && routeColor.trim().length > 0
              ? routeColor
              : BUS_MARKER_DEFAULT_ROUTE_COLOR;
          const textColor = computeBusMarkerGlyphColor(fillColor);
          const normalizedSpeed = Math.max(0, Math.round(groundSpeed));
          const label = `${normalizedSpeed} MPH`;
          const fontSize = Math.max(BUS_MARKER_LABEL_MIN_FONT_PX, SPEED_BUBBLE_BASE_FONT_PX * safeScale);
          const horizontalPadding = SPEED_BUBBLE_HORIZONTAL_PADDING * safeScale;
          const verticalPadding = SPEED_BUBBLE_VERTICAL_PADDING * safeScale;
          const textWidth = measureLabelTextWidth(label, fontSize);
          const width = Math.max(SPEED_BUBBLE_MIN_WIDTH * safeScale, textWidth + horizontalPadding * 2);
          const height = Math.max(SPEED_BUBBLE_MIN_HEIGHT * safeScale, fontSize + verticalPadding * 2);
          const radius = SPEED_BUBBLE_CORNER_RADIUS * safeScale;
          const strokeWidth = Math.max(1, LABEL_BASE_STROKE_WIDTH * safeScale);
          const svgWidth = roundToTwoDecimals(width);
          const svgHeight = roundToTwoDecimals(height);
          const radiusRounded = roundToTwoDecimals(radius);
          const strokeWidthRounded = roundToTwoDecimals(strokeWidth);
          const textX = roundToTwoDecimals(svgWidth / 2);
          const baselineShift = fontSize * LABEL_TEXT_VERTICAL_ADJUSTMENT_RATIO;
          const textY = roundToTwoDecimals(svgHeight / 2 + baselineShift);
          const anchorX = roundToTwoDecimals(svgWidth / 2);
          const leaderOffset = roundToTwoDecimals(computeLabelLeaderOffset(safeScale, headingDeg, 'below'));
          const anchorY = -leaderOffset;
          const svg = `
              <svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg" style="pointer-events: none;">
                  <g>
                      <rect x="0" y="0" width="${svgWidth}" height="${svgHeight}" rx="${radiusRounded}" ry="${radiusRounded}" fill="${fillColor}" stroke="white" stroke-width="${strokeWidthRounded}" />
                      <text x="${textX}" y="${textY}" dominant-baseline="middle" alignment-baseline="middle" text-anchor="middle" font-size="${roundToTwoDecimals(fontSize)}" font-weight="bold" fill="${textColor}" font-family="FGDC">${escapeHtml(label)}</text>
                  </g>
              </svg>`;
          return L.divIcon({
              html: svg,
              className: 'leaflet-div-icon bus-label-icon',
              iconSize: [svgWidth, svgHeight],
              iconAnchor: [anchorX, anchorY]
          });
      }

      function createNameBubbleDivIcon(busName, routeColor, scale, headingDeg) {
          if (typeof busName !== 'string' || busName.trim().length === 0) {
              return null;
          }
          const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
          const name = busName.trim();
          const fillColor = typeof routeColor === 'string' && routeColor.trim().length > 0
              ? routeColor
              : BUS_MARKER_DEFAULT_ROUTE_COLOR;
          const fontSize = Math.max(BUS_MARKER_LABEL_MIN_FONT_PX, NAME_BUBBLE_BASE_FONT_PX * safeScale);
          const horizontalPadding = NAME_BUBBLE_HORIZONTAL_PADDING * safeScale;
          const verticalPadding = NAME_BUBBLE_VERTICAL_PADDING * safeScale;
          const frameInset = NAME_BUBBLE_FRAME_INSET * safeScale;
          const textWidth = measureLabelTextWidth(name, fontSize);
          const rectWidth = Math.max(NAME_BUBBLE_MIN_WIDTH * safeScale, textWidth + horizontalPadding * 2);
          const rectHeight = Math.max(NAME_BUBBLE_MIN_HEIGHT * safeScale, fontSize + verticalPadding * 2);
          const svgWidth = roundToTwoDecimals(rectWidth);
          const svgHeight = roundToTwoDecimals(rectHeight + frameInset * 2);
          const radius = NAME_BUBBLE_CORNER_RADIUS * safeScale;
          const strokeWidth = Math.max(1, LABEL_BASE_STROKE_WIDTH * safeScale);
          const radiusRounded = roundToTwoDecimals(radius);
          const strokeWidthRounded = roundToTwoDecimals(strokeWidth);
          const rectY = roundToTwoDecimals(frameInset);
          const rectHeightRounded = roundToTwoDecimals(rectHeight);
          const textX = roundToTwoDecimals(svgWidth / 2);
          const baselineShift = fontSize * LABEL_TEXT_VERTICAL_ADJUSTMENT_RATIO;
          const textY = roundToTwoDecimals(rectY + rectHeight / 2 + baselineShift);
          const anchorX = textX;
          const leaderOffset = roundToTwoDecimals(computeLabelLeaderOffset(safeScale, headingDeg, 'above'));
          const anchorY = svgHeight + leaderOffset;
          const textColor = computeBusMarkerGlyphColor(fillColor);
          const fontSizeRounded = roundToTwoDecimals(fontSize);
          const svg = `
              <svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg" style="pointer-events: none;">
                  <g>
                      <rect x="0" y="${rectY}" width="${svgWidth}" height="${rectHeightRounded}" rx="${radiusRounded}" ry="${radiusRounded}" fill="${fillColor}" stroke="white" stroke-width="${strokeWidthRounded}" />
                      <text x="${textX}" y="${textY}" dominant-baseline="middle" alignment-baseline="middle" text-anchor="middle" font-size="${fontSizeRounded}" font-weight="bold" fill="${textColor}" font-family="FGDC">${escapeHtml(name)}</text>
                  </g>
              </svg>`;
          return L.divIcon({
              html: svg,
              className: 'leaflet-div-icon bus-label-icon',
              iconSize: [svgWidth, svgHeight],
              iconAnchor: [anchorX, anchorY]
          });
      }

      function createBlockBubbleDivIcon(blockName, routeColor, scale, headingDeg) {
          if (typeof blockName !== 'string' || blockName.trim() === '') {
              return null;
          }
          const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
          const name = blockName.trim();
          const fillColor = typeof routeColor === 'string' && routeColor.trim().length > 0
              ? routeColor
              : BUS_MARKER_DEFAULT_ROUTE_COLOR;
          const fontSize = Math.max(BUS_MARKER_LABEL_MIN_FONT_PX, BLOCK_BUBBLE_BASE_FONT_PX * safeScale);
          const horizontalPadding = BLOCK_BUBBLE_HORIZONTAL_PADDING * safeScale;
          const verticalPadding = BLOCK_BUBBLE_VERTICAL_PADDING * safeScale;
          const frameInset = BLOCK_BUBBLE_FRAME_INSET * safeScale;
          const textWidth = measureLabelTextWidth(name, fontSize);
          const rectWidth = Math.max(BLOCK_BUBBLE_MIN_WIDTH * safeScale, textWidth + horizontalPadding * 2);
          const rectHeight = Math.max(BLOCK_BUBBLE_MIN_HEIGHT * safeScale, fontSize + verticalPadding * 2);
          const svgWidth = roundToTwoDecimals(rectWidth);
          const svgHeight = roundToTwoDecimals(rectHeight + frameInset * 2);
          const radius = BLOCK_BUBBLE_CORNER_RADIUS * safeScale;
          const strokeWidth = Math.max(1, LABEL_BASE_STROKE_WIDTH * safeScale);
          const radiusRounded = roundToTwoDecimals(radius);
          const strokeWidthRounded = roundToTwoDecimals(strokeWidth);
          const rectY = roundToTwoDecimals(frameInset);
          const rectHeightRounded = roundToTwoDecimals(rectHeight);
          const textX = roundToTwoDecimals(svgWidth / 2);
          const baselineShift = fontSize * LABEL_TEXT_VERTICAL_ADJUSTMENT_RATIO;
          const textY = roundToTwoDecimals(rectY + rectHeight / 2 + baselineShift);
          const anchorX = textX;
          const leaderOffset = roundToTwoDecimals(computeLabelLeaderOffset(safeScale, headingDeg, 'below'));
          const anchorY = -leaderOffset;
          const textColor = computeBusMarkerGlyphColor(fillColor);
          const fontSizeRounded = roundToTwoDecimals(fontSize);
          const svg = `
              <svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg" style="pointer-events: none;">
                  <g>
                      <rect x="0" y="${rectY}" width="${svgWidth}" height="${rectHeightRounded}" rx="${radiusRounded}" ry="${radiusRounded}" fill="${fillColor}" stroke="white" stroke-width="${strokeWidthRounded}" />
                      <text x="${textX}" y="${textY}" dominant-baseline="middle" alignment-baseline="middle" text-anchor="middle" font-size="${fontSizeRounded}" font-weight="bold" fill="${textColor}" font-family="FGDC">${escapeHtml(name)}</text>
                  </g>
              </svg>`;
          return L.divIcon({
              html: svg,
              className: 'leaflet-div-icon bus-label-icon',
              iconSize: [svgWidth, svgHeight],
              iconAnchor: [anchorX, anchorY]
          });
      }

      function updateBusMarkerHeading(state, newPosition, fallbackHeading, groundSpeedMph) {
          if (!state) {
              return BUS_MARKER_DEFAULT_HEADING;
          }
          const lat = Array.isArray(newPosition) ? Number(newPosition[0]) : Number(newPosition?.lat ?? newPosition?.Latitude);
          const lng = Array.isArray(newPosition) ? Number(newPosition[1]) : Number(newPosition?.lng ?? newPosition?.Longitude);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
              return state.headingDeg ?? BUS_MARKER_DEFAULT_HEADING;
          }
          const current = L.latLng(lat, lng);
          const history = Array.isArray(state.positionHistory) ? state.positionHistory : [];
          const previous = history.length > 0 ? history[history.length - 1] : null;
          let heading = Number.isFinite(state.headingDeg) ? state.headingDeg : BUS_MARKER_DEFAULT_HEADING;
          const sanitizedSpeedMph = Number.isFinite(groundSpeedMph) ? Math.max(0, groundSpeedMph) : null;
          const speedMetersPerSecond = sanitizedSpeedMph === null ? null : sanitizedSpeedMph * METERS_PER_SECOND_PER_MPH;
          const hasSufficientSpeed = speedMetersPerSecond === null || speedMetersPerSecond >= MIN_HEADING_SPEED_METERS_PER_SECOND;
          if (previous) {
              const distance = previous.distanceTo(current);
              const shouldUpdateHeading = distance >= MIN_HEADING_DISTANCE_METERS && hasSufficientSpeed;
              if (shouldUpdateHeading) {
                  const computed = computeBearingDegrees(previous, current);
                  if (Number.isFinite(computed)) {
                      heading = computed;
                  }
              } else if (!Number.isFinite(heading)) {
                  const fallback = Number.isFinite(fallbackHeading) ? fallbackHeading : BUS_MARKER_DEFAULT_HEADING;
                  heading = fallback;
              }
              if (distance >= MIN_POSITION_UPDATE_METERS) {
                  history.push(current);
                  if (history.length > 2) {
                      history.shift();
                  }
              } else {
                  history[history.length - 1] = current;
              }
          } else {
              const fallback = Number.isFinite(fallbackHeading) ? fallbackHeading : heading;
              heading = Number.isFinite(fallback) ? fallback : BUS_MARKER_DEFAULT_HEADING;
              history.push(current);
          }
          state.positionHistory = history;
          state.headingDeg = normalizeHeadingDegrees(heading);
          return state.headingDeg;
      }

      function computeBearingDegrees(fromLatLng, toLatLng) {
          if (!fromLatLng || !toLatLng) {
              return BUS_MARKER_DEFAULT_HEADING;
          }
          const lat1 = fromLatLng.lat * Math.PI / 180;
          const lat2 = toLatLng.lat * Math.PI / 180;
          const dLon = (toLatLng.lng - fromLatLng.lng) * Math.PI / 180;
          const y = Math.sin(dLon) * Math.cos(lat2);
          const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
          const theta = Math.atan2(y, x);
          const bearing = theta * 180 / Math.PI;
          return normalizeHeadingDegrees(bearing);
      }

      function normalizeHeadingDegrees(degrees) {
          const normalized = Number.isFinite(degrees) ? degrees : BUS_MARKER_DEFAULT_HEADING;
          return ((normalized % 360) + 360) % 360;
      }

      function setMarkerSvgRotation(svgElement, rotationDeg) {
          if (!svgElement) {
              return;
          }
          const normalizedRotation = normalizeHeadingDegrees(
              Number.isFinite(rotationDeg) ? rotationDeg : BUS_MARKER_DEFAULT_HEADING
          );
          svgElement.style.transformOrigin = BUS_MARKER_TRANSFORM_ORIGIN;
          svgElement.style.transformBox = 'fill-box';
          svgElement.style.transform = `rotate(${normalizedRotation.toFixed(2)}deg)`;
      }

      function buildBusMarkerAccessibleLabel(busName, headingDeg, groundSpeed) {
          const name = busName && `${busName}`.trim().length > 0 ? `${busName}`.trim() : 'Vehicle';
          const direction = bearingToDirection(headingDeg);
          const speedText = formatBusSpeed(groundSpeed);
          return `${name}  ${direction}  ${speedText}`;
      }

      function isBusConsideredStopped(groundSpeed) {
          if (!Number.isFinite(groundSpeed)) {
              return false;
          }
          const speed = Math.max(0, Math.round(groundSpeed));
          return speed <= 1;
      }

      function bearingToDirection(headingDeg) {
          if (!Number.isFinite(headingDeg)) {
              return 'Unknown direction';
          }
          const compass = [
              'Northbound',
              'Northeastbound',
              'Eastbound',
              'Southeastbound',
              'Southbound',
              'Southwestbound',
              'Westbound',
              'Northwestbound'
          ];
          const normalized = normalizeHeadingDegrees(headingDeg);
          const index = Math.round(normalized / 45) % compass.length;
          return compass[index];
      }

      function formatBusSpeed(groundSpeed) {
          if (!Number.isFinite(groundSpeed)) {
              return 'Speed unavailable';
          }
          const speed = Math.max(0, Math.round(groundSpeed));
          if (speed <= 1) {
              return 'Stopped';
          }
          return `${speed} mph`;
      }

      function escapeHtml(value) {
          if (value === null || value === undefined) {
              return '';
          }
          return `${value}`
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;');
      }

      function contrastBW(hex) {
          if (typeof hex !== 'string' || hex.trim().length === 0) {
              return '#FFFFFF';
          }
          let normalized = hex.trim().replace(/^#/, '');
          if (normalized.length === 3) {
              normalized = normalized.split('').map(ch => ch + ch).join('');
          }
          if (normalized.length !== 6 || /[^0-9a-fA-F]/.test(normalized)) {
              return '#FFFFFF';
          }
          const r = parseInt(normalized.substring(0, 2), 16) / 255;
          const g = parseInt(normalized.substring(2, 4), 16) / 255;
          const b = parseInt(normalized.substring(4, 6), 16) / 255;
          const L = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          return L > 0.55 ? '#000000' : '#FFFFFF';
      }

      async function loadBusSVG() {
          if (BUS_MARKER_SVG_TEXT) {
              return BUS_MARKER_SVG_TEXT;
          }
          if (!BUS_MARKER_SVG_LOAD_PROMISE) {
              BUS_MARKER_SVG_LOAD_PROMISE = fetch(BUS_MARKER_SVG_URL)
                  .then(response => {
                      if (!response.ok) {
                          throw new Error(`Failed to load bus marker SVG: ${response.status} ${response.statusText}`);
                      }
                      return response.text();
                  })
                  .then(text => {
                      const template = document.createElement('template');
                      template.innerHTML = text.trim();
                      const parsedSvg = template.content.firstElementChild;
                      if (!parsedSvg || parsedSvg.tagName.toLowerCase() !== 'svg') {
                          throw new Error('Loaded bus marker asset is not a valid SVG.');
                      }
                      BUS_MARKER_SVG_TEXT = parsedSvg.outerHTML;
                      busMarkerVisibleExtents = null;
                      BUS_MARKER_SVG_LOAD_PROMISE = null;
                      return BUS_MARKER_SVG_TEXT;
                  })
                  .catch(error => {
                      BUS_MARKER_SVG_LOAD_PROMISE = null;
                      throw error;
                  });
          }
          return BUS_MARKER_SVG_LOAD_PROMISE;
      }

      function buildBusMarkerDivIconSync(vehicleID, state) {
          if (!state || !BUS_MARKER_SVG_TEXT) {
              return null;
          }
          const width = state.size?.widthPx ?? BUS_MARKER_BASE_WIDTH_PX;
          const height = state.size?.heightPx ?? width * BUS_MARKER_ASPECT_RATIO;
          const anchorX = width * BUS_MARKER_ICON_ANCHOR_X_RATIO;
          const anchorY = height * BUS_MARKER_ICON_ANCHOR_Y_RATIO;
          const headingDeg = Number.isFinite(state?.headingDeg) ? state.headingDeg : BUS_MARKER_DEFAULT_HEADING;
          const label = state?.accessibleLabel && state.accessibleLabel.trim().length > 0
              ? state.accessibleLabel.trim()
              : `Vehicle ${vehicleID}`;
          const template = document.createElement('template');
          template.innerHTML = BUS_MARKER_SVG_TEXT.trim();
          const svgEl = template.content.firstElementChild;
          if (!svgEl || svgEl.tagName.toLowerCase() !== 'svg') {
              return null;
          }
          svgEl.classList.add('bus-marker__svg');
          svgEl.setAttribute('viewBox', `0 0 ${BUS_MARKER_VIEWBOX_WIDTH} ${BUS_MARKER_VIEWBOX_HEIGHT}`);
          svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');
          svgEl.setAttribute('focusable', 'false');
          svgEl.setAttribute('role', 'img');
          svgEl.setAttribute('aria-label', label);
          svgEl.setAttribute('overflow', 'visible');
          svgEl.style.width = '100%';
          svgEl.style.height = '100%';
          setMarkerSvgRotation(svgEl, headingDeg);

          const routeFillColor = normalizeRouteColor(state.fillColor);
          const glyphFillColor = normalizeGlyphColor(state.glyphColor, routeFillColor);
          state.fillColor = routeFillColor;
          state.glyphColor = glyphFillColor;
          ensureCenterSquareElement(svgEl);
          applyColorsToBusMarkerSvg(svgEl, routeFillColor, glyphFillColor);
          applyStoppedVisualStateToSvg(svgEl, state.isStopped);

          const existingTitle = svgEl.querySelector('title');
          let title = existingTitle;
          if (!title) {
              title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
              svgEl.insertBefore(title, svgEl.firstChild);
          }
          title.textContent = label;

          const rootClasses = ['bus-marker__root'];
          if (state?.isStale) rootClasses.push('is-stale');
          if (state?.isSelected) rootClasses.push('is-selected');
          if (state?.isHovered) rootClasses.push('is-hover');
          const root = document.createElement('div');
          root.className = rootClasses.join(' ');
          root.dataset.vehicleId = `${vehicleID}`;
          root.setAttribute('role', 'img');
          root.setAttribute('aria-label', label);
          root.style.pointerEvents = 'none';
          root.style.touchAction = 'none';
          root.style.cursor = 'default';
          root.appendChild(svgEl);

          const wrapper = document.createElement('div');
          wrapper.appendChild(root);

          return L.divIcon({
              html: wrapper.innerHTML,
              className: 'leaflet-div-icon bus-marker',
              iconSize: [width, height],
              iconAnchor: [anchorX, anchorY]
          });
      }

      async function createBusMarkerDivIcon(vehicleID, state) {
          if (!state) {
              return null;
          }
          try {
              await loadBusSVG();
          } catch (error) {
              console.error('Failed to load bus marker SVG:', error);
              return null;
          }
          if (!BUS_MARKER_SVG_TEXT) {
              return null;
          }
          if (!state.size) {
              const zoom = map && typeof map?.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM;
              setBusMarkerSize(state, computeBusMarkerMetrics(zoom));
          }
          return buildBusMarkerDivIconSync(vehicleID, state);
      }

      function registerBusMarkerElements(vehicleID) {
          const state = busMarkerStates[vehicleID];
          const marker = markers[vehicleID];
          if (!state || !marker) {
              return null;
          }
          const iconElement = marker.getElement();
          if (!iconElement) {
              return null;
          }
          iconElement.style.pointerEvents = 'none';
          const root = iconElement.querySelector('.bus-marker__root');
          const svg = root ? root.querySelector('.bus-marker__svg') : null;
          const title = svg ? svg.querySelector('title') : null;
          const routeShape = svg ? svg.querySelector('#route_color') : null;
          const centerSquare = svg ? ensureCenterSquareElement(svg) : null;
          const centerRing = svg ? svg.querySelector(`#${BUS_MARKER_CENTER_RING_ID}`) : null;
          const heading = svg ? svg.querySelector('#heading') : null;
          state.elements = {
              icon: iconElement,
              root,
              svg,
              title,
              routeColor: routeShape,
              centerRing,
              centerSquare,
              heading
          };
          if (root) {
              root.dataset.vehicleId = `${vehicleID}`;
              root.style.pointerEvents = 'none';
              root.style.touchAction = 'none';
              root.style.cursor = 'default';
              if (root.hasAttribute('tabindex')) {
                  root.removeAttribute('tabindex');
              }
              if (root.dataset && root.dataset.busMarkerFocusBound) {
                  delete root.dataset.busMarkerFocusBound;
              }
          }
          if (svg) {
              svg.style.pointerEvents = 'none';
              svg.style.transformOrigin = BUS_MARKER_TRANSFORM_ORIGIN;
              svg.style.transformBox = 'fill-box';
              setMarkerSvgRotation(svg, state.headingDeg);
          }
          updateBusMarkerColorElements(state);
          applyBusMarkerStoppedVisualState(state);
          return state.elements;
      }

      function queueBusMarkerVisualUpdate(vehicleID, update = {}) {
          if (!vehicleID) {
              return;
          }
          const existing = pendingBusVisualUpdates.get(vehicleID) || {};
          Object.assign(existing, update);
          pendingBusVisualUpdates.set(vehicleID, existing);
          if (busMarkerVisualUpdateFrame === null) {
              busMarkerVisualUpdateFrame = requestAnimationFrame(flushBusMarkerVisualUpdates);
          }
      }

      function flushBusMarkerVisualUpdates() {
          busMarkerVisualUpdateFrame = null;
          pendingBusVisualUpdates.forEach((update, vehicleID) => {
              applyBusMarkerVisualUpdate(vehicleID, update);
          });
          pendingBusVisualUpdates.clear();
      }

      function applyBusMarkerVisualUpdate(vehicleID, update) {
          const state = busMarkerStates[vehicleID];
          if (!state) {
              return;
          }
          const elements = state.elements || registerBusMarkerElements(vehicleID);
          if (!elements || !elements.root) {
              return;
          }
          if (update && Object.prototype.hasOwnProperty.call(update, 'fillColor')) {
              state.fillColor = update.fillColor;
          }
          if (update && Object.prototype.hasOwnProperty.call(update, 'glyphColor')) {
              state.glyphColor = update.glyphColor;
          }
          updateBusMarkerColorElements(state);
          if (update && typeof update.stale === 'boolean') {
              state.isStale = update.stale;
          }
          if (update && typeof update.accessibleLabel === 'string') {
              state.accessibleLabel = update.accessibleLabel;
          }
          if (update && Number.isFinite(update.headingDeg)) {
              state.headingDeg = normalizeHeadingDegrees(update.headingDeg);
          }
          if (update && Object.prototype.hasOwnProperty.call(update, 'stopped')) {
              state.isStopped = Boolean(update.stopped);
          }
          applyBusMarkerStoppedVisualState(state);
          const rotationDeg = normalizeHeadingDegrees(Number.isFinite(state.headingDeg) ? state.headingDeg : BUS_MARKER_DEFAULT_HEADING);
          if (elements.svg) {
              setMarkerSvgRotation(elements.svg, rotationDeg);
              if (state.accessibleLabel) {
                  elements.svg.setAttribute('aria-label', state.accessibleLabel);
              }
          }
          if (elements.root && state.accessibleLabel) {
              elements.root.setAttribute('aria-label', state.accessibleLabel);
          }
          if (elements.title && state.accessibleLabel) {
              elements.title.textContent = state.accessibleLabel;
          }
          updateBusMarkerRootClasses(state);
          updateBusMarkerZIndex(state);
          applyBusMarkerOutlineWidth(state);
      }

      function applyBusMarkerOutlineWidth(state) {
          if (!state?.elements?.svg) {
              return;
          }
          state.elements.svg.style.opacity = state.isStale ? '0.6' : '1';
      }

      function updateBusMarkerRootClasses(state) {
          if (!state?.elements?.root) {
              return;
          }
          const root = state.elements.root;
          root.classList.toggle('is-stale', Boolean(state.isStale));
          root.classList.toggle('is-selected', Boolean(state.isSelected));
          root.classList.toggle('is-hover', Boolean(state.isHovered));
      }

      function updateBusMarkerZIndex(state) {
          if (!state?.marker) {
              return;
          }
          let offset = 0;
          if (state.isSelected) {
              offset = 800;
          }
          if (state.isHovered) {
              offset = Math.max(offset, 1000);
          }
          state.marker.setZIndexOffset(offset);
      }

      function setBusMarkerHovered(vehicleID, isHovered) {
          const state = busMarkerStates[vehicleID];
          if (!state) {
              return;
          }
          const next = Boolean(isHovered);
          if (state.isHovered === next) {
              return;
          }
          state.isHovered = next;
          updateBusMarkerRootClasses(state);
          updateBusMarkerZIndex(state);
          applyBusMarkerOutlineWidth(state);
      }

      function setBusMarkerSelected(vehicleID, isSelected) {
          const state = busMarkerStates[vehicleID];
          if (!state) {
              return;
          }
          const next = Boolean(isSelected);
          if (state.isSelected === next) {
              return;
          }
          state.isSelected = next;
          updateBusMarkerRootClasses(state);
          updateBusMarkerZIndex(state);
          applyBusMarkerOutlineWidth(state);
      }

      function attachBusMarkerInteractions(vehicleID) {
          const state = busMarkerStates[vehicleID];
          const marker = markers[vehicleID];
          if (!state || !marker) {
              return;
          }
          if (typeof marker.off === 'function') {
              marker.off();
          }
          if (marker.options) {
              marker.options.interactive = false;
              marker.options.keyboard = false;
          }
          if (selectedVehicleId === vehicleID) {
              selectedVehicleId = null;
          }
          if (state.isHovered || state.isSelected) {
              state.isHovered = false;
              state.isSelected = false;
              updateBusMarkerRootClasses(state);
              updateBusMarkerZIndex(state);
              applyBusMarkerOutlineWidth(state);
          }
          const elements = state.elements || registerBusMarkerElements(vehicleID);
          const icon = elements?.icon;
          const root = elements?.root;
          const svg = elements?.svg;
          if (icon) {
              icon.style.pointerEvents = 'none';
          }
          if (root) {
              root.style.pointerEvents = 'none';
              root.style.touchAction = 'none';
              root.style.cursor = 'default';
              if (root.hasAttribute('tabindex')) {
                  root.removeAttribute('tabindex');
              }
              if (root.dataset && root.dataset.busMarkerFocusBound) {
                  delete root.dataset.busMarkerFocusBound;
              }
          }
          if (svg) {
              svg.style.pointerEvents = 'none';
          }
          state.markerEventsBound = false;
      }

      async function updateBusMarkerSizes(metricsOverride = null) {
          if (!map) {
              return;
          }
          const zoom = typeof map.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM;
          const metrics = metricsOverride || computeBusMarkerMetrics(zoom);
          try {
              await loadBusSVG();
          } catch (error) {
              console.error('Failed to load bus marker SVG while updating sizes:', error);
          }
          for (const vehicleID of Object.keys(markers)) {
              const marker = markers[vehicleID];
              const state = busMarkerStates[vehicleID];
              if (!marker || !state) {
                  continue;
              }
              const currentWidth = state.size?.widthPx;
              if (currentWidth && Math.abs(currentWidth - metrics.widthPx) < 0.1) {
                  continue;
              }
              setBusMarkerSize(state, metrics);
              try {
                  const icon = await createBusMarkerDivIcon(vehicleID, state);
                  if (!icon) {
                      continue;
                  }
                  marker.setIcon(icon);
                  registerBusMarkerElements(vehicleID);
                  attachBusMarkerInteractions(vehicleID);
                  updateBusMarkerRootClasses(state);
                  updateBusMarkerZIndex(state);
                  applyBusMarkerOutlineWidth(state);
              } catch (error) {
                  console.error(`Failed to resize bus marker for vehicle ${vehicleID}:`, error);
              }
          }
          updateLabelIconsForMetrics(metrics);
      }

      function updateLabelIconsForMetrics(metrics) {
          if (!metrics || !Number.isFinite(metrics.scale) || !map) {
              return;
          }
          const scale = metrics.scale;
          Object.keys(nameBubbles).forEach(vehicleID => {
              const bubble = nameBubbles[vehicleID];
              const state = busMarkerStates[vehicleID];
              const marker = markers[vehicleID];
              if (!bubble || !state || !marker) {
                  return;
              }
              const routeColor = state.fillColor || getRouteColor(state.routeID) || outOfServiceRouteColor;
              const speedMarker = bubble.speedMarker;
              const nameMarker = bubble.nameMarker;
              const blockMarker = bubble.blockMarker;

              if (speedMarker) {
                  if (adminMode && displayMode === DISPLAY_MODES.SPEED && !kioskMode && Number.isFinite(state.groundSpeed)) {
                      const speedIcon = createSpeedBubbleDivIcon(routeColor, state.groundSpeed, scale, state.headingDeg);
                      if (speedIcon) {
                          speedMarker.setIcon(speedIcon);
                      } else {
                          map.removeLayer(speedMarker);
                          delete bubble.speedMarker;
                      }
                  } else {
                      map.removeLayer(speedMarker);
                      delete bubble.speedMarker;
                  }
              }

              if (nameMarker) {
                  if (adminMode && !kioskMode) {
                      const nameIcon = createNameBubbleDivIcon(state.busName, routeColor, scale, state.headingDeg);
                      if (nameIcon) {
                          nameMarker.setIcon(nameIcon);
                      } else {
                          map.removeLayer(nameMarker);
                          delete bubble.nameMarker;
                      }
                  } else {
                      map.removeLayer(nameMarker);
                      delete bubble.nameMarker;
                  }
              }

              if (blockMarker) {
                  const blockName = busBlocks[vehicleID];
                  if (adminMode && !kioskMode && displayMode === DISPLAY_MODES.BLOCK && blockName && blockName.includes('[')) {
                      const blockIcon = createBlockBubbleDivIcon(blockName, routeColor, scale, state.headingDeg);
                      if (blockIcon) {
                          blockMarker.setIcon(blockIcon);
                      } else {
                          map.removeLayer(blockMarker);
                          delete bubble.blockMarker;
                      }
                  } else {
                      map.removeLayer(blockMarker);
                      delete bubble.blockMarker;
                  }
              }

              const hasMarkers = Boolean(bubble.speedMarker || bubble.nameMarker || bubble.blockMarker);
              if (hasMarkers) {
                  bubble.lastScale = scale;
              } else {
                  delete nameBubbles[vehicleID];
              }
          });
      }

      function scheduleMarkerScaleUpdate() {
          if (!map) {
              return;
          }
          const zoom = typeof map.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM;
          const metrics = computeBusMarkerMetrics(zoom);
          pendingMarkerScaleMetrics = Object.assign({}, metrics);
          if (markerScaleUpdateFrame !== null) {
              return;
          }
          markerScaleUpdateFrame = requestAnimationFrame(async () => {
              markerScaleUpdateFrame = null;
              const metricsToApply = pendingMarkerScaleMetrics;
              pendingMarkerScaleMetrics = null;
              if (!metricsToApply) {
                  return;
              }
              try {
                  await updateBusMarkerSizes(metricsToApply);
              } catch (error) {
                  console.error('Failed to update bus marker sizes:', error);
              }
          });
      }

      function clearBusMarkerState(vehicleID) {
          pendingBusVisualUpdates.delete(vehicleID);
          if (selectedVehicleId === vehicleID) {
              selectedVehicleId = null;
          }
          if (busMarkerStates[vehicleID]) {
              delete busMarkerStates[vehicleID];
          }
      }

      function isVehicleGpsStale(vehicle) {
          if (!vehicle) {
              return false;
          }
          if (vehicle.IsStale === true || vehicle.Stale === true || vehicle.StaleGPS === true) {
              return true;
          }
          if (vehicle.HasValidGps === false || vehicle.IsRealtime === false) {
              return true;
          }
          const ageFields = [
              vehicle.SecondsSinceReport,
              vehicle.SecondsSinceLastReport,
              vehicle.SecondsSinceLastUpdate,
              vehicle.SecondsSinceUpdate,
              vehicle.SecondsSinceLastGps,
              vehicle.LastGpsAgeSeconds,
              vehicle.LocationAge,
              vehicle.GPSSignalAge,
              vehicle.Age,
              vehicle.AgeInSeconds
          ];
          for (let i = 0; i < ageFields.length; i += 1) {
              const value = Number(ageFields[i]);
              if (Number.isFinite(value) && value > GPS_STALE_THRESHOLD_SECONDS) {
                  return true;
              }
          }
          return false;
      }

      function getTrainIdentifier(train) {
          if (!train) {
              return null;
          }
          const candidateFields = ['trainID', 'trainId', 'trainNumRaw', 'trainNum'];
          for (let i = 0; i < candidateFields.length; i += 1) {
              const value = train?.[candidateFields[i]];
              if (value !== undefined && value !== null) {
                  const text = `${value}`.trim();
                  if (text.length > 0) {
                      return text;
                  }
              }
          }
          if (typeof train?.routeName === 'string' && train.routeName.trim().length > 0) {
              return train.routeName.trim();
          }
          return null;
      }

      function trainIncludesStation(train, stationCode) {
          if (!train || !Array.isArray(train?.stations)) {
              return false;
          }
          if (typeof stationCode !== 'string' || stationCode.trim().length === 0) {
              return false;
          }
          const target = stationCode.trim().toUpperCase();
          return train.stations.some(stop => {
              const code = typeof stop?.code === 'string' ? stop.code.trim().toUpperCase() : '';
              return code === target;
          });
      }

      function buildTrainAccessibleLabel(train) {
          if (!train) {
              return 'Amtrak train';
          }
          const parts = [];
          const numberFields = ['trainNumRaw', 'trainNum'];
          for (let i = 0; i < numberFields.length; i += 1) {
              const value = train?.[numberFields[i]];
              if (value !== undefined && value !== null) {
                  const text = `${value}`.trim();
                  if (text.length > 0) {
                      parts.push(`Train ${text}`);
                      break;
                  }
              }
          }
          const routeName = typeof train?.routeName === 'string' ? train.routeName.trim() : '';
          if (routeName.length > 0) {
              parts.push(routeName);
          }
          const status = typeof train?.trainTimely === 'string' ? train.trainTimely.trim() : '';
          if (status.length > 0) {
              parts.push(status);
          }
          return parts.length > 0 ? parts.join('  ') : 'Amtrak train';
      }

      function getTrainHeadingValue(train) {
          if (!train || typeof train !== 'object') {
              return null;
          }
          const candidateFields = ['heading', 'Heading', 'direction', 'Direction', 'dir', 'Dir'];
          for (let i = 0; i < candidateFields.length; i += 1) {
              const field = candidateFields[i];
              if (train[field] !== undefined && train[field] !== null) {
                  return train[field];
              }
          }
          return null;
      }

      function getTrainHeadingDegrees(headingValue, fallbackHeading) {
          const fallback = Number.isFinite(fallbackHeading)
              ? fallbackHeading
              : BUS_MARKER_DEFAULT_HEADING;
          if (Number.isFinite(headingValue)) {
              return normalizeHeadingDegrees(headingValue);
          }
          if (typeof headingValue === 'string') {
              const trimmed = headingValue.trim();
              if (trimmed.length > 0) {
                  const numericCandidate = Number(trimmed);
                  if (Number.isFinite(numericCandidate)) {
                      return normalizeHeadingDegrees(numericCandidate);
                  }
                  const normalized = trimmed.toUpperCase();
                  const sanitized = normalized.replace(/[^A-Z]/g, '');
                  const candidates = [];
                  if (sanitized.length > 0) {
                      candidates.push(sanitized);
                      const withoutBound = sanitized.replace(/BOUND$/, '');
                      if (withoutBound !== sanitized && withoutBound.length > 0) {
                          candidates.push(withoutBound);
                      }
                      const withoutWard = sanitized.replace(/WARD$/, '');
                      if (withoutWard !== sanitized && withoutWard.length > 0) {
                          candidates.push(withoutWard);
                      }
                  }
                  if (normalized !== sanitized && normalized.length > 0) {
                      candidates.push(normalized);
                  }
                  for (let i = 0; i < candidates.length; i += 1) {
                      const key = candidates[i];
                      const degrees = TRAIN_CARDINAL_HEADING_DEGREES[key];
                      if (Number.isFinite(degrees)) {
                          return normalizeHeadingDegrees(degrees);
                      }
                  }
              }
          }
          return normalizeHeadingDegrees(fallback);
      }

      function updateTrainMarkerHeading(state, newPosition, headingValue) {
          if (!state) {
              return BUS_MARKER_DEFAULT_HEADING;
          }
          const fallbackHeading = Number.isFinite(state.headingDeg)
              ? state.headingDeg
              : BUS_MARKER_DEFAULT_HEADING;
          let lat = Number.NaN;
          let lng = Number.NaN;
          if (Array.isArray(newPosition)) {
              if (newPosition.length >= 2) {
                  lat = Number(newPosition[0]);
                  lng = Number(newPosition[1]);
              }
          } else if (newPosition && typeof newPosition === 'object') {
              lat = Number(newPosition.lat ?? newPosition.Latitude);
              lng = Number(newPosition.lng ?? newPosition.Longitude);
          }
          if (Number.isFinite(lat) && Number.isFinite(lng)) {
              const current = L.latLng(lat, lng);
              const history = Array.isArray(state.positionHistory) ? state.positionHistory : [];
              if (history.length === 0) {
                  history.push(current);
              } else {
                  const previous = history[history.length - 1];
                  if (previous && typeof previous.distanceTo === 'function') {
                      const distance = previous.distanceTo(current);
                      if (distance >= MIN_POSITION_UPDATE_METERS) {
                          history.push(current);
                          if (history.length > 2) {
                              history.shift();
                          }
                      } else {
                          history[history.length - 1] = current;
                      }
                  } else {
                      history[history.length - 1] = current;
                  }
              }
              state.positionHistory = history;
          }
          const headingDeg = getTrainHeadingDegrees(headingValue, fallbackHeading);
          state.headingDeg = normalizeHeadingDegrees(headingDeg);
          return state.headingDeg;
      }

      function ensureTrainMarkerState(trainID) {
          if (trainID === null || trainID === undefined) {
              return null;
          }
          const key = `${trainID}`;
          const state = trainMarkerStates[key];
          if (state) {
              if (!state.markerId) {
                  state.markerId = `train-${key.replace(/\s+/g, '-')}`;
              }
              return state;
          }
          const defaultFill = BUS_MARKER_DEFAULT_ROUTE_COLOR;
          const newState = {
              trainID: key,
              markerId: `train-${key.replace(/\s+/g, '-')}`,
              positionHistory: [],
              headingDeg: BUS_MARKER_DEFAULT_HEADING,
              fillColor: defaultFill,
              glyphColor: computeBusMarkerGlyphColor(defaultFill),
              accessibleLabel: 'Amtrak train',
              isStale: false,
              isStopped: false,
              lastLatLng: null,
              marker: null,
              size: null,
              lastUpdateTimestamp: 0
          };
          trainMarkerStates[key] = newState;
          return newState;
      }

      function clearTrainMarker(trainID) {
          if (trainID === null || trainID === undefined) {
              return;
          }
          const key = `${trainID}`;
          const marker = trainMarkers[key];
          if (marker) {
              if (map && typeof map.hasLayer === 'function' && map.hasLayer(marker)) {
                  map.removeLayer(marker);
              } else if (typeof marker.remove === 'function') {
                  marker.remove();
              }
          }
          delete trainMarkers[key];
          delete trainMarkerStates[key];
      }

      function clearAllTrainMarkers() {
          Object.keys(trainMarkers).forEach(trainID => {
              const marker = trainMarkers[trainID];
              if (!marker) {
                  return;
              }
              if (map && typeof map.hasLayer === 'function' && map.hasLayer(marker)) {
                  map.removeLayer(marker);
              } else if (typeof marker.remove === 'function') {
                  marker.remove();
              }
          });
          trainMarkers = {};
          trainMarkerStates = {};
      }

      function setPlanesVisibility(visible) {
          const allowPlanes = adminFeaturesAllowed();
          const desiredVisibility = allowPlanes && !!visible;
          const planeLayer = window.PlaneLayer;
          if (!desiredVisibility) {
              if (planeLayer && planeLayer.isStarted) {
                  try {
                      if (typeof planeLayer.dispose === 'function') {
                          planeLayer.dispose();
                      } else if (typeof planeLayer.stop === 'function') {
                          planeLayer.stop();
                      }
                  } catch (error) {
                      console.error('Error stopping aircraft layer:', error);
                  }
              }
              planesVisible = false;
              updateAircraftToggleButton();
              return;
          }
          if (!map) {
              planesVisible = false;
              updateAircraftToggleButton();
              return;
          }
          if (!planeLayer) {
              console.warn('Plane layer is unavailable; unable to show aircraft.');
              planesVisible = false;
              updateAircraftToggleButton();
              return;
          }
          try {
              if (!planeLayer.isStarted) {
                  if (typeof planeLayer.init === 'function') {
                      planeLayer.init(map);
                  } else if (typeof planeLayer.start === 'function') {
                      planeLayer.start();
                  }
              }
          } catch (error) {
              console.error('Error initializing aircraft layer:', error);
          }
          planesVisible = !!(planeLayer && planeLayer.isStarted);
          updateAircraftToggleButton();
      }

      function toggleAircraftVisibility() {
          setPlanesVisibility(!planesVisible);
      }

      function setTrainsVisibility(visible) {
          const allowTrains = adminFeaturesAllowed();
          const desiredVisibility = allowTrains && !!visible;
          const previousVisibility = !!trainsVisible;
          trainsVisible = desiredVisibility;
          updateTrainToggleButton();
          try {
              const visibilityPromise = updateTrainMarkersVisibility();
              if (visibilityPromise && typeof visibilityPromise.catch === 'function') {
                  visibilityPromise.catch(error => console.error('Error updating train markers visibility:', error));
              }
          } catch (error) {
              console.error('Error updating train markers visibility:', error);
          }
          if (trainsVisible && !previousVisibility) {
              fetchTrains().catch(error => console.error('Failed to fetch trains:', error));
          }
      }

      function toggleTrainsVisibility() {
          setTrainsVisibility(!trainsVisible);
      }

      async function updateTrainMarkersVisibility() {
          if (!adminFeaturesAllowed()) {
              clearAllTrainMarkers();
              return;
          }
          if (!trainsVisible) {
              Object.keys(trainMarkers).forEach(trainID => {
                  const marker = trainMarkers[trainID];
                  if (!marker) {
                      return;
                  }
                  if (map && typeof map.hasLayer === 'function' && map.hasLayer(marker)) {
                      map.removeLayer(marker);
                  } else if (typeof marker.remove === 'function') {
                      marker.remove();
                  }
                  const state = trainMarkerStates[trainID];
                  if (state) {
                      state.marker = marker || null;
                  }
              });
              return;
          }
          if (!map || typeof map.getBounds !== 'function') {
              return;
          }
          const bounds = map.getBounds();
          if (!bounds || typeof bounds.contains !== 'function') {
              return;
          }
          const zoom = typeof map.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM;
          const metrics = computeBusMarkerMetrics(zoom);
          for (const trainID of Object.keys(trainMarkerStates)) {
              const state = trainMarkerStates[trainID];
              if (!state) {
                  continue;
              }
              const latLng = state.lastLatLng;
              const marker = trainMarkers[trainID];
              if (!latLng || !Number.isFinite(latLng.lat) || !Number.isFinite(latLng.lng)) {
                  if (marker && map && typeof map.hasLayer === 'function' && map.hasLayer(marker)) {
                      map.removeLayer(marker);
                  }
                  state.marker = marker || null;
                  continue;
              }
              if (!bounds.contains(latLng)) {
                  if (marker && map && typeof map.hasLayer === 'function' && map.hasLayer(marker)) {
                      map.removeLayer(marker);
                  }
                  state.marker = marker || null;
                  continue;
              }
              setBusMarkerSize(state, metrics);
              let icon = null;
              try {
                  icon = await createBusMarkerDivIcon(state.markerId || `train-${trainID}`, state);
              } catch (error) {
                  console.error('Failed to create train marker icon:', error);
                  continue;
              }
              if (!icon) {
                  continue;
              }
              let trainMarker = marker;
              if (!trainMarker) {
                  trainMarker = L.marker(latLng, {
                      icon,
                      pane: 'busesPane',
                      interactive: false,
                      keyboard: false
                  });
                  trainMarkers[trainID] = trainMarker;
              } else {
                  trainMarker.setIcon(icon);
              }
              state.marker = trainMarker;
              if (!map.hasLayer(trainMarker)) {
                  trainMarker.addTo(map);
              }
              animateMarkerTo(trainMarker, latLng);
          }
      }

      async function fetchTrains() {
          if (trainFetchPromise) {
              return trainFetchPromise;
          }
          if (!adminFeaturesAllowed()) {
              return Promise.resolve();
          }
          if (!trainsVisible) {
              return Promise.resolve();
          }
          const fetchTask = (async () => {
              if (!trainsVisible) {
                  return;
              }
              const stationCode = typeof TRAIN_TARGET_STATION_CODE === 'string'
                  ? TRAIN_TARGET_STATION_CODE.trim().toUpperCase()
                  : '';
              let response;
              try {
                  response = await fetch(TRAIN_API_URL, { cache: 'no-store' });
              } catch (error) {
                  console.error('Failed to fetch trains:', error);
                  return;
              }
              if (!response || !response.ok) {
                  const statusText = response ? `${response.status} ${response.statusText}` : 'No response';
                  console.error('Failed to fetch trains:', statusText);
                  return;
              }
              let payload;
              try {
                  payload = await response.json();
              } catch (error) {
                  console.error('Failed to parse train response:', error);
                  return;
              }
              if (!trainsVisible) {
                  return;
              }
              const seenTrainIds = new Set();
              const timestamp = Date.now();
              if (payload && typeof payload === 'object') {
                  Object.values(payload).forEach(group => {
                      if (!Array.isArray(group)) {
                          return;
                      }
                      group.forEach(train => {
                          if (stationCode && !trainIncludesStation(train, stationCode)) {
                              return;
                          }
                          const identifier = getTrainIdentifier(train);
                          if (!identifier) {
                              return;
                          }
                          seenTrainIds.add(identifier);
                          const state = ensureTrainMarkerState(identifier);
                          if (!state) {
                              return;
                          }
                          const lat = Number(train?.lat);
                          const lon = Number(train?.lon);
                          const fillColor = normalizeRouteColor(train?.iconColor);
                          const rawTextColor = typeof train?.textColor === 'string' ? train.textColor.trim() : '';
                          const glyphColor = rawTextColor.length > 0
                              ? normalizeGlyphColor(rawTextColor, fillColor)
                              : computeBusMarkerGlyphColor(fillColor);
                          state.fillColor = fillColor;
                          state.glyphColor = glyphColor;
                          state.accessibleLabel = buildTrainAccessibleLabel(train);
                          state.isStale = false;
                          state.isStopped = false;
                          state.lastUpdateTimestamp = timestamp;
                          const headingValue = getTrainHeadingValue(train);
                          if (Number.isFinite(lat) && Number.isFinite(lon)) {
                              const latLng = L.latLng(lat, lon);
                              state.lastLatLng = latLng;
                              state.headingDeg = updateTrainMarkerHeading(state, latLng, headingValue);
                          } else {
                              state.lastLatLng = null;
                              state.headingDeg = updateTrainMarkerHeading(state, null, headingValue);
                          }
                      });
                  });
              }
              Object.keys(trainMarkerStates).forEach(trainID => {
                  if (!seenTrainIds.has(trainID)) {
                      clearTrainMarker(trainID);
                  }
              });
              try {
                  await updateTrainMarkersVisibility();
              } catch (error) {
                  console.error('Error updating train markers visibility:', error);
              }
          })();
          trainFetchPromise = fetchTask.finally(() => {
              trainFetchPromise = null;
          });
          return trainFetchPromise;
      }

      function animateMarkerTo(marker, newPosition) {
        if (!marker || !newPosition) return;
        const hasArrayPosition = Array.isArray(newPosition) && newPosition.length >= 2;
        const endPos = hasArrayPosition ? L.latLng(newPosition) : L.latLng(newPosition?.lat, newPosition?.lng);
        if (!endPos || Number.isNaN(endPos.lat) || Number.isNaN(endPos.lng)) return;

        const startPos = marker.getLatLng();
        if (!startPos) {
          marker.setLatLng(endPos);
          return;
        }

        const positionsMatch = typeof startPos.equals === 'function'
          ? startPos.equals(endPos, 1e-7)
          : (Math.abs(startPos.lat - endPos.lat) < 1e-7 && Math.abs(startPos.lng - endPos.lng) < 1e-7);

        if (positionsMatch) {
          marker.setLatLng(endPos);
          return;
        }

        const duration = 1000;
        const startTime = performance.now();
        function animate(time) {
          const elapsed = time - startTime;
          const t = Math.min(elapsed / duration, 1);
          const currentPos = L.latLng(
            startPos.lat + t * (endPos.lat - startPos.lat),
            startPos.lng + t * (endPos.lng - startPos.lng)
          );
          marker.setLatLng(currentPos);
          if (t < 1) requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
      }

      document.addEventListener("DOMContentLoaded", () => {
        initializePanelStateForViewport();
        beginAgencyLoad();
        loadAgencies()
          .then(() => {
            initMap();
            showCookieBanner();
            enforceIncidentVisibilityForCurrentAgency();
            return loadAgencyData()
              .then(() => {
                startRefreshIntervals();
              });
          })
          .catch(error => {
            console.error('Error during initial load:', error);
          })
          .finally(() => {
            completeAgencyLoad();
          });
      });
    </script>
    <script>
      window.ADSB_PROXY_ENDPOINT = '/adsb';
    </script>
    <script src="plane_globals.js"></script>
    <script>
      if (typeof window.setPlaneStyleOptions === 'function') {
        window.setPlaneStyleOptions({ atcStyle: false });
      } else {
        window.atcStyle = false;
      }
    </script>
    <script src="markers.js"></script>
    <script src="planeObject.js"></script>
    <script src="planes_integration.js"></script>
  </head>
  <body>
    <div id="map"></div>
    <div id="routeLegend" aria-live="polite"></div>
    <div id="controlPanel" class="selector-panel"></div>
    <div id="routeSelector" class="selector-panel"></div>
    <div id="controlPanelTab" class="panel-toggle panel-toggle--left" onclick="toggleControlPanel()" title="Toggle system controls">
      <span class="panel-toggle__arrow" aria-hidden="true">&#9654;</span>
    </div>
    <div id="routeSelectorTab" class="panel-toggle panel-toggle--right" onclick="toggleRoutePanel()" title="Toggle route selector">
      <span class="panel-toggle__arrow" aria-hidden="true">&#9664;</span>
    </div>
    <div class="credit">proof of concept created by pat cox  phc6j@virginia.edu  Radar tiles  NOAA/NWS via Iowa Environmental Mesonet.</div>
    <div id="cookieBanner" class="cookie-banner" style="display:none;">
      This site stores your selected transit agency on your device to remember your preference.
      <button id="cookieAccept">OK</button>
    </div>
    <div id="loadingOverlay" class="loading-overlay" aria-live="polite" aria-busy="false">
      <div class="loading-overlay__inner">
        <div class="loading-overlay__spinner" aria-hidden="true"></div>
        <div class="loading-overlay__text">Loading agency data</div>
      </div>
    </div>
  </body>
</html>
