<!DOCTYPE html>
<html>
  <head>
    <title>Live Map - Headway Guard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
    <script src="https://unpkg.com/rbush@3.0.1/rbush.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.2.0/crypto-js.min.js"></script>
    <style>
      .custom-popup {
        position: absolute;
        background: linear-gradient(135deg, var(--navy), var(--navy-dark));
        border: 3px solid rgba(255, 255, 255, 0.92);
        border-radius: 16px;
        padding: 12px 14px;
        pointer-events: auto;
        transform: translate(-50%, -100%);
        white-space: nowrap;
        z-index: 1000;
        color: #f8fafc;
        text-transform: uppercase;
        font-family: 'FGDC', sans-serif;
        font-size: 14px;
        letter-spacing: 0.35px;
        box-shadow: 0 18px 36px rgba(15, 23, 42, 0.38);
      }
      .custom-popup-arrow {
        position: absolute;
        left: 50%;
        bottom: -10px;
        width: 0;
        height: 0;
        border-left: 10px solid transparent;
        border-right: 10px solid transparent;
        border-top: 10px solid rgba(255, 255, 255, 0.92);
        transform: translateX(-50%);
      }
      .custom-popup-close {
        position: absolute;
        bottom: 5px;
        right: 5px;
        cursor: pointer;
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        color: #1f1300;
        border: none;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 20px;
        text-align: center;
        font-size: 13px;
        box-shadow: 0 10px 20px rgba(229, 114, 0, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .custom-popup-close:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 24px rgba(229, 114, 0, 0.4);
      }
      .incident-popup {
        min-width: 280px;
        max-width: 340px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        color: #f8fafc;
        text-transform: none;
        font-family: 'FGDC', sans-serif;
        letter-spacing: 0.3px;
        white-space: normal;
      }
      .incident-popup__header {
        display: flex;
        align-items: flex-start;
        gap: 14px;
      }
      .incident-popup__details {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .incident-popup__icon {
        width: 60px;
        height: 60px;
        border-radius: 16px;
        background: #ffffff;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        box-shadow: inset 0 0 0 1px rgba(15, 23, 42, 0.08), 0 12px 24px rgba(15, 23, 42, 0.35);
        flex-shrink: 0;
      }
      .incident-popup__icon img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        display: block;
      }
      .incident-popup__icon-fallback {
        font-size: 24px;
        font-weight: 800;
        letter-spacing: 2px;
        color: rgba(15, 23, 42, 0.75);
      }
      .incident-popup__title {
        font-size: 18px;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 1.4px;
        margin-bottom: 4px;
      }
      .incident-popup__meta {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 13px;
        opacity: 0.92;
      }
      .incident-popup__meta-line {
        display: flex;
        align-items: center;
        gap: 6px;
        line-height: 1.3;
      }
      .incident-popup__section {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .incident-popup__section-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1.1px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.78);
      }
      .incident-popup__routes-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 13px;
        font-weight: 600;
        color: rgba(255, 255, 255, 0.92);
        overflow-wrap: anywhere;
      }
      .incident-popup__route {
        display: inline-flex;
        align-items: center;
        padding: 2px 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.35);
        color: rgba(248, 250, 252, 0.92);
        font-weight: 600;
        letter-spacing: 0.4px;
      }
      .incident-popup__units {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .incident-popup__unit-status-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .incident-popup__unit-status-group + .incident-popup__unit-status-group {
        padding-top: 6px;
        border-top: 1px solid rgba(255, 255, 255, 0.14);
      }
      .incident-popup__unit-status-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: 700;
        color: rgba(255, 255, 255, 0.82);
      }
      .incident-popup__unit-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .incident-popup .incident-unit {
        display: inline-flex;
        align-items: center;
        font-size: 12px;
        font-weight: 700;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(15, 23, 42, 0.55);
        color: rgba(248, 250, 252, 0.92);
        letter-spacing: 0.35px;
      }
      .route-pill {
        display: inline-block;
        padding: 5px 12px;
        border-radius: 999px;
        color: #1f1300;
        font-weight: bold;
        margin-top: 10px;
        text-align: center;
        border: none;
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        box-shadow: 0 12px 24px var(--route-pill-shadow-color, rgba(229, 114, 0, 0.35));
      }
      .stop-marker-container {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        line-height: 0;
        cursor: pointer;
        transition: transform 0.2s ease;
      }
      .stop-marker-outer {
        position: relative;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        width: var(--stop-marker-size, 24px);
        height: var(--stop-marker-size, 24px);
        border-radius: 50%;
        border: 2px solid var(--stop-marker-border-color, rgba(15,23,42,0.55));
        background: var(--stop-marker-gradient, #ffffff);
        box-shadow: 0 0 0 var(--stop-marker-outline-size, 0px) var(--stop-marker-outline-color, transparent),
                    0 12px 24px rgba(15,23,42,0.28);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .stop-marker-container:hover .stop-marker-outer,
      .stop-marker-container:focus-visible .stop-marker-outer {
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 0 0 var(--stop-marker-outline-size, 0px) var(--stop-marker-outline-color, transparent),
                    0 18px 32px rgba(15,23,42,0.32);
      }
      .stop-entry + .stop-entry {
        margin-top: 12px;
        padding-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.2);
      }
      .stop-entry-title {
        display: block;
        font-weight: bold;
        margin-bottom: 4px;
      }
      .stop-entry-id {
        display: block;
        font-size: 12px;
        opacity: 0.9;
        margin-bottom: 6px;
      }
      .bus-marker {
        background: transparent;
        border: 0;
        padding: 0;
        line-height: 0;
        pointer-events: none;
      }
      .bus-marker__root {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        pointer-events: none;
        cursor: default;
        touch-action: none;
        user-select: none;
        overflow: visible;
      }
      .bus-label-icon {
        pointer-events: none !important;
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        padding: 0 !important;
      }
      .bus-marker__svg {
        display: block;
        width: 100%;
        height: 100%;
        overflow: visible;
        transition: transform 0.2s ease, filter 0.2s ease;
        transform-box: view-box;
        transform-origin: 50% 50%;
        will-change: transform;
        pointer-events: none;
        position: relative;
        z-index: 1;
      }
      .bus-marker__svg .st1 {
        paint-order: stroke fill;
        transition: fill 0.2s ease, fill-opacity 0.2s ease;
        pointer-events: auto;
      }
      .bus-marker__svg .st0 {
        transition: fill 0.2s ease;
        pointer-events: auto;
      }
      .bus-marker__svg #halo {
        pointer-events: none;
      }
      .bus-marker__root.is-stale .bus-marker__svg {
        opacity: 0.6;
      }
      .bus-marker__root.is-hover .bus-marker__svg {
        filter: drop-shadow(0 3px 8px rgba(15, 23, 42, 0.35));
      }
      .bus-marker__root.is-selected .bus-marker__svg {
        filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.68));
      }
      .bus-marker__root.is-selected.is-hover .bus-marker__svg {
        filter: drop-shadow(0 3px 12px rgba(15, 23, 42, 0.35)) drop-shadow(0 0 7px rgba(255, 255, 255, 0.72));
      }
      .incident-halo-icon {
        pointer-events: none !important;
      }
      .incident-halo-icon .incident-halo {
        position: absolute;
        left: 50%;
        top: 50%;
        width: var(--incident-halo-diameter, 128px);
        height: var(--incident-halo-diameter, 128px);
        margin-left: calc(-0.5 * var(--incident-halo-diameter, 128px));
        margin-top: calc(-0.5 * var(--incident-halo-diameter, 128px));
        border-radius: 50%;
        background: radial-gradient(circle, rgba(var(--incident-halo-color-rgb, 255, 90, 60), var(--incident-halo-base-opacity, 0.5)) 0%, rgba(var(--incident-halo-color-rgb, 255, 90, 60), 0) 72%);
        opacity: var(--incident-halo-base-opacity, 0.5);
        transform: scale(var(--incident-halo-start-scale, 0.25));
        transform-origin: 50% 50%;
        pointer-events: none;
        will-change: transform, opacity;
        filter: blur(0.2px);
      }
      .incident-halo--animated {
        animation: incident-halo-pulse var(--incident-halo-duration, 1600ms) cubic-bezier(0.25, 1, 0.5, 1) infinite;
      }
      .incident-halo--static {
        transform: scale(1);
        opacity: var(--incident-halo-base-opacity, 0.5);
      }
      @keyframes incident-halo-pulse {
        0% {
          transform: scale(var(--incident-halo-start-scale, 0.25));
          opacity: var(--incident-halo-base-opacity, 0.5);
        }
        70% {
          opacity: var(--incident-halo-base-opacity, 0.5);
        }
        100% {
          transform: scale(1);
          opacity: 0;
        }
      }
      @media (prefers-reduced-motion: reduce) {
        .incident-halo--animated {
          animation: none;
          transform: scale(1);
          opacity: var(--incident-halo-base-opacity, 0.5);
        }
      }
      @font-face {
        font-family: 'FGDC';
        src: url('FGDC.ttf') format('truetype');
      }
      :root {
        --navy: #232D4B;
        --navy-dark: #1b274a;
        --navy-darker: #1a2441;
        --panel-surface: linear-gradient(180deg, rgba(255, 255, 255, 0.96), rgba(245, 248, 255, 0.96));
        --panel-border-color: rgba(35, 45, 75, 0.12);
        --panel-shadow: 0 20px 45px rgba(15, 23, 42, 0.25);
        --panel-highlight: rgba(35, 45, 75, 0.06);
        --panel-text-color: #1f2937;
        --panel-heading-color: #232D4B;
        --panel-muted-text: #4b5563;
        --accent: #E57200;
        --accent-bright: #ff9c3e;
        --accent-soft: rgba(229, 114, 0, 0.28);
      }
      body {
        font-family: 'FGDC', sans-serif;
        font-size: 14px;
        color: var(--panel-text-color);
      }
      #map {
        height: 100%;
        width: 100%;
      }
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      .loading-overlay {
        position: fixed;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: rgba(71, 85, 105, 0.55);
        color: #f1f5f9;
        font-family: 'FGDC', sans-serif;
        font-size: 18px;
        letter-spacing: 0.3rem;
        text-transform: uppercase;
        z-index: 3000;
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: opacity 0.25s ease, visibility 0.25s ease;
        backdrop-filter: blur(2px);
      }
      .loading-overlay.is-visible {
        opacity: 1;
        visibility: visible;
        pointer-events: all;
      }
      .loading-overlay__inner {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
      }
      .loading-overlay__spinner {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: 4px solid rgba(241, 245, 249, 0.35);
        border-top-color: #f8fafc;
        animation: loading-overlay-spin 1s linear infinite;
      }
      .loading-overlay__text {
        font-size: 16px;
        letter-spacing: 0.35rem;
      }
      @keyframes loading-overlay-spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }
      /* Route Selector styling */
      .selector-panel {
        width: 340px;
        position: fixed;
        top: 10px;
        z-index: 1100;
        background: var(--panel-surface);
        border-radius: 18px;
        border: 1px solid var(--panel-border-color);
        box-shadow: var(--panel-shadow);
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        backdrop-filter: blur(12px);
        transition: transform 0.35s ease, box-shadow 0.3s ease, opacity 0.3s ease;
        font-size: 16px;
        color: var(--panel-text-color);
      }
      #routeSelector {
        right: 10px;
      }
      #controlPanel {
        left: 10px;
      }
      #routeSelector.hidden {
        transform: translateX(calc(100% + 24px));
        opacity: 0;
        pointer-events: none;
      }
      #controlPanel.hidden {
        transform: translateX(calc(-100% - 24px));
        opacity: 0;
        pointer-events: none;
      }
      .selector-panel .selector-header {
        background: linear-gradient(135deg, var(--navy), var(--navy-dark));
        color: #f8fafc;
        padding: 16px 20px 18px;
        box-shadow: inset 0 -1px 0 rgba(255, 255, 255, 0.08);
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .selector-panel .selector-header-text {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .selector-panel .selector-logo {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 10px;
        border-radius: 12px;
        background: #ffffff;
        border: 1px solid rgba(35, 45, 75, 0.15);
        box-shadow: 0 8px 18px rgba(15, 23, 42, 0.18);
      }
      .selector-panel .selector-logo img {
        display: block;
        max-width: 100%;
        max-height: 120px;
        height: auto;
      }
      .selector-panel .selector-title {
        margin: 0;
        font-size: 22px;
        letter-spacing: 0.4px;
      }
      .selector-panel .selector-subtitle {
        margin-top: 6px;
        font-size: 13px;
        opacity: 0.75;
        letter-spacing: 0.3px;
      }
      .selector-panel .selector-content {
        flex: 1;
        min-height: 0;
        overflow-y: auto;
        padding: 18px 20px 22px;
        display: flex;
        flex-direction: column;
        gap: 18px;
      }
      .selector-panel .selector-section.service-alerts {
        border-radius: 16px;
        border: 1px solid rgba(35, 45, 75, 0.14);
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.96), rgba(241, 245, 249, 0.9));
        box-shadow: 0 18px 38px rgba(15, 23, 42, 0.12);
        display: flex;
        flex-direction: column;
        gap: 0;
        transition: box-shadow 0.2s ease, border-color 0.2s ease;
        backdrop-filter: blur(6px);
      }
      .selector-panel .selector-section.service-alerts.is-expanded {
        box-shadow: 0 22px 44px rgba(15, 23, 42, 0.16);
      }
      .service-alerts.is-collapsed.has-active-alerts {
        border-color: rgba(220, 38, 38, 0.45);
        box-shadow: 0 16px 32px rgba(220, 38, 38, 0.18);
      }
      .service-alerts__header {
        appearance: none;
        border: none;
        background: linear-gradient(135deg, rgba(35, 45, 75, 0.08), rgba(35, 45, 75, 0.02));
        border-radius: 16px;
        border-bottom: 1px solid transparent;
        padding: 18px 20px;
        display: flex;
        align-items: center;
        gap: 16px;
        width: 100%;
        text-align: left;
        cursor: pointer;
        font: inherit;
        color: inherit;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.55);
        position: relative;
        transition: color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      }
      .service-alerts__header:hover,
      .service-alerts__header:focus-visible {
        text-decoration: none;
        background: linear-gradient(135deg, rgba(35, 45, 75, 0.16), rgba(35, 45, 75, 0.05));
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.65), 0 12px 24px rgba(15, 23, 42, 0.12);
      }
      .service-alerts__header:focus-visible {
        outline: none;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.65), 0 0 0 3px var(--accent-soft), 0 18px 32px rgba(15, 23, 42, 0.16);
      }
      .service-alerts.is-expanded .service-alerts__header {
        border-bottom-color: rgba(148, 163, 184, 0.26);
        border-bottom-left-radius: 0;
        border-bottom-right-radius: 0;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.45);
      }
      .service-alerts.is-collapsed .service-alerts__header {
        border-bottom-color: transparent;
      }
      .service-alerts.is-collapsed.has-active-alerts .service-alerts__header {
        color: rgba(127, 29, 29, 0.95);
        background: linear-gradient(135deg, rgba(220, 38, 38, 0.12), rgba(220, 38, 38, 0.04));
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.7), 0 14px 30px rgba(220, 38, 38, 0.18);
      }
      .service-alerts__header-main {
        display: flex;
        flex-direction: column;
        gap: 4px;
        flex: 1;
        min-width: 0;
      }
      .service-alerts__title {
        font-size: 16px;
        font-weight: 700;
        letter-spacing: 0.4px;
      }
      .service-alerts__status {
        font-size: 13px;
        letter-spacing: 0.3px;
        color: rgba(35, 45, 75, 0.65);
        text-transform: uppercase;
      }
      .service-alerts.is-collapsed.has-active-alerts .service-alerts__status {
        color: rgba(127, 29, 29, 0.78);
      }
      .service-alerts__badge,
      .panel-toggle__badge {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        min-width: 26px;
        height: 26px;
        padding: 0 6px;
        border-radius: 999px;
        background: linear-gradient(135deg, #dc2626, #ef4444);
        color: #fef2f2;
        font-weight: 700;
        font-size: 13px;
        letter-spacing: 0.4px;
        box-shadow: 0 8px 18px rgba(220, 38, 38, 0.25);
      }
      .service-alerts__badge[hidden],
      .panel-toggle__badge[hidden] {
        display: none !important;
      }
      .service-alerts__badge {
        box-shadow: none;
      }
      .service-alerts__chevron {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 34px;
        height: 34px;
        border-radius: 50%;
        background: linear-gradient(135deg, rgba(35, 45, 75, 0.95), rgba(35, 45, 75, 0.7));
        color: #f8fafc;
        font-size: 18px;
        font-weight: 700;
        line-height: 1;
        box-shadow: 0 12px 24px rgba(35, 45, 75, 0.25);
        transition: transform 0.25s ease, background 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
        flex-shrink: 0;
      }
      .service-alerts__header:hover .service-alerts__chevron,
      .service-alerts__header:focus-visible .service-alerts__chevron {
        background: linear-gradient(135deg, rgba(35, 45, 75, 0.85), rgba(35, 45, 75, 0.65));
        box-shadow: 0 14px 28px rgba(35, 45, 75, 0.28);
      }
      .service-alerts.is-collapsed.has-active-alerts .service-alerts__chevron {
        background: linear-gradient(135deg, #dc2626, #ef4444);
        box-shadow: 0 16px 30px rgba(220, 38, 38, 0.32);
        color: #fef2f2;
      }
      .service-alerts.is-expanded .service-alerts__chevron {
        transform: rotate(90deg);
        background: linear-gradient(135deg, rgba(35, 45, 75, 0.88), rgba(35, 45, 75, 0.68));
      }
      .service-alerts__content {
        padding: 20px 20px 22px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.98), rgba(241, 245, 249, 0.94));
        border-top: 1px solid rgba(148, 163, 184, 0.24);
        border-bottom-left-radius: 16px;
        border-bottom-right-radius: 16px;
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.6);
      }
      .service-alerts.is-expanded .service-alerts__content {
        animation: service-alerts-fade-in 180ms ease;
      }
      .service-alerts.is-collapsed .service-alerts__content {
        display: none;
      }
      .service-alerts__list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .service-alerts__item {
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(241, 245, 249, 0.92));
        border: 1px solid rgba(148, 163, 184, 0.32);
        border-radius: 14px;
        padding: 16px 18px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        box-shadow: 0 16px 30px rgba(15, 23, 42, 0.12);
      }
      .service-alerts__item-title {
        font-size: 15px;
        font-weight: 700;
        letter-spacing: 0.3px;
        color: rgba(35, 45, 75, 0.92);
      }
      .service-alerts__item-message {
        font-size: 14px;
        line-height: 1.45;
        color: rgba(15, 23, 42, 0.85);
        white-space: pre-wrap;
      }
      .service-alerts__meta {
        display: grid;
        gap: 6px;
        font-size: 13px;
        color: rgba(55, 65, 81, 0.88);
      }
      .service-alerts__meta-row {
        display: grid;
        grid-template-columns: auto 1fr;
        gap: 8px;
        align-items: baseline;
      }
      .service-alerts__meta-row dt {
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: rgba(30, 41, 59, 0.72);
      }
      .service-alerts__meta-row dd {
        margin: 0;
        overflow-wrap: anywhere;
      }
      .service-alerts__state {
        display: flex;
        align-items: center;
        gap: 12px;
        font-size: 14px;
        color: rgba(30, 41, 59, 0.8);
        padding: 16px 18px;
        border-radius: 14px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.96), rgba(237, 242, 247, 0.92));
        border: 1px solid rgba(148, 163, 184, 0.28);
        box-shadow: 0 12px 22px rgba(15, 23, 42, 0.1);
      }
      .service-alerts__spinner {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(30, 64, 175, 0.2);
        border-top-color: rgba(30, 64, 175, 0.7);
        animation: loading-overlay-spin 1s linear infinite;
      }
      .service-alerts__state--error {
        color: rgba(153, 27, 27, 0.9);
        font-weight: 600;
        border-color: rgba(220, 38, 38, 0.3);
        box-shadow: 0 16px 32px rgba(220, 38, 38, 0.18);
      }
      .service-alerts__state--empty {
        color: rgba(30, 41, 59, 0.6);
        font-style: italic;
        border-style: dashed;
      }
      @keyframes service-alerts-fade-in {
        from {
          opacity: 0;
          transform: translateY(-6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @media (prefers-reduced-motion: reduce) {
        .service-alerts.is-expanded .service-alerts__content {
          animation: none;
        }
      }
      .selector-panel .incident-alert-block {
        background: linear-gradient(135deg, rgba(254, 226, 226, 0.92), rgba(254, 202, 202, 0.78));
        border: 1px solid rgba(220, 38, 38, 0.35);
        border-radius: 18px;
        padding: 18px 20px;
        box-shadow: 0 18px 32px rgba(220, 38, 38, 0.18);
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .selector-panel .incident-alert__header {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .selector-panel .incident-alert__title {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
        letter-spacing: 0.4px;
        color: rgba(136, 19, 19, 0.95);
      }
      .selector-panel .incident-alert__subtitle {
        margin: 0;
        font-size: 13px;
        line-height: 1.4;
        color: rgba(127, 29, 29, 0.85);
      }
      .selector-panel .incident-alert__list {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      /* ===== Demo incident preview styles (remove when demo is retired) ===== */
      .selector-panel .demo-incident-section {
        border: 3px dashed rgba(236, 72, 153, 0.65);
        border-radius: 18px;
        padding: 18px 20px;
        background: repeating-linear-gradient(135deg, rgba(250, 204, 21, 0.38), rgba(250, 204, 21, 0.38) 16px, rgba(244, 63, 94, 0.45) 16px, rgba(244, 63, 94, 0.45) 32px);
        box-shadow: 0 18px 32px rgba(190, 24, 93, 0.25);
        text-align: center;
      }
      .demo-incident-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        padding: 12px 16px;
        font-size: 15px;
        font-weight: 800;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #0f172a;
        background: linear-gradient(135deg, #f97316, #ec4899);
        border: 4px solid #0f172a;
        border-radius: 14px;
        cursor: pointer;
        box-shadow: 0 10px 18px rgba(15, 23, 42, 0.35);
        transition: transform 0.12s ease, box-shadow 0.12s ease;
      }
      .demo-incident-button:hover {
        transform: translateY(-2px) rotate(-1.5deg);
        box-shadow: 0 16px 26px rgba(15, 23, 42, 0.45);
      }
      .demo-incident-button:active {
        transform: translateY(1px) scale(0.97) rotate(1.5deg);
      }
      .demo-incident-button.is-active {
        background: linear-gradient(135deg, #22d3ee, #a855f7);
      }
      .selector-panel .demo-incident-note {
        margin-top: 10px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: rgba(15, 23, 42, 0.82);
      }
      .selector-panel .incident-alert__item {
        display: flex;
        align-items: flex-start;
        gap: 14px;
      }
      .selector-panel .incident-alert__item-button {
        appearance: none;
        background: transparent;
        border: 1px solid transparent;
        border-radius: 16px;
        padding: 8px 12px;
        width: 100%;
        text-align: left;
        display: flex;
        align-items: flex-start;
        gap: 14px;
        cursor: pointer;
        font: inherit;
        color: inherit;
        transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
      }
      .selector-panel .incident-alert__item-button:hover,
      .selector-panel .incident-alert__item-button:focus-visible {
        background: rgba(255, 255, 255, 0.6);
        border-color: rgba(136, 19, 19, 0.25);
        box-shadow: 0 10px 24px rgba(136, 19, 19, 0.15);
        outline: none;
      }
      .selector-panel .incident-alert__item-button:focus-visible .incident-alert__type {
        text-decoration: underline;
      }
      .selector-panel .incident-alert__media {
        flex: 0 0 auto;
        width: 60px;
        height: 60px;
        border-radius: 16px;
        background: rgba(255, 255, 255, 0.82);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: inset 0 0 0 1px rgba(220, 38, 38, 0.25);
      }
      .selector-panel .incident-alert__media img {
        display: block;
        max-width: 48px;
        max-height: 48px;
      }
      .selector-panel .incident-alert__content {
        flex: 1 1 auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .selector-panel .incident-alert__type {
        font-size: 17px;
        font-weight: 700;
        letter-spacing: 0.4px;
        color: rgba(136, 19, 19, 0.95);
      }
      .selector-panel .incident-alert__meta {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        font-size: 13px;
        color: rgba(120, 53, 15, 0.95);
      }
      .selector-panel .incident-alert__location {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 13px;
        color: rgba(124, 45, 18, 0.95);
        overflow-wrap: anywhere;
      }
      .selector-panel .incident-alert__location-label {
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 12px;
        color: rgba(136, 19, 19, 0.9);
      }
      .selector-panel .incident-alert__location-text {
        font-weight: 600;
      }
      .selector-panel .incident-alert__received {
        font-weight: 600;
      }
      .selector-panel .incident-alert__routes-line {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        font-size: 13px;
        color: rgba(124, 45, 18, 0.95);
      }
      .selector-panel .incident-alert__routes-list {
        font-weight: 600;
        overflow-wrap: anywhere;
      }
      .selector-panel .incident-alert__routes-label,
      .selector-panel .incident-alert__units-label {
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 12px;
        color: rgba(136, 19, 19, 0.9);
      }
      .selector-panel .incident-alert__units {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: flex-start;
      }
      .selector-panel .incident-alert__units-label {
        display: block;
      }
      .selector-panel .incident-alert__unit-status-group {
        display: flex;
        flex-direction: column;
        gap: 6px;
        width: 100%;
      }
      .selector-panel .incident-alert__unit-status-group + .incident-alert__unit-status-group {
        padding-top: 6px;
        border-top: 1px solid rgba(136, 19, 19, 0.2);
      }
      .selector-panel .incident-alert__unit-status-title {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: 700;
        color: rgba(136, 19, 19, 0.9);
      }
      .selector-panel .incident-alert__unit-list {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .selector-panel .incident-unit {
        display: inline-flex;
        align-items: center;
        font-size: 12px;
        font-weight: 700;
        padding: 4px 10px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        background: rgba(255, 255, 255, 0.82);
        color: rgba(30, 41, 59, 0.85);
        letter-spacing: 0.3px;
      }
      .selector-panel .selector-content::-webkit-scrollbar {
        width: 8px;
      }
      .selector-panel .selector-content::-webkit-scrollbar-track {
        background: rgba(35, 45, 75, 0.08);
        border-radius: 12px;
      }
      .selector-panel .selector-content::-webkit-scrollbar-thumb {
        background: rgba(35, 45, 75, 0.35);
        border-radius: 12px;
      }
      .selector-panel .selector-content::-webkit-scrollbar-thumb:hover {
        background: rgba(229, 114, 0, 0.6);
      }
      .selector-panel .selector-group {
        background: var(--panel-highlight);
        border-radius: 14px;
        padding: 14px 16px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .selector-panel .selector-label {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1.6px;
        color: rgba(35, 45, 75, 0.75);
      }
      .selector-panel .selector-control {
        position: relative;
      }
      .selector-panel .selector-control::after {
        content: '\25BC';
        position: absolute;
        right: 16px;
        top: 50%;
        transform: translateY(-50%);
        pointer-events: none;
        font-size: 12px;
        color: rgba(35, 45, 75, 0.65);
        opacity: 0.6;
      }
      .selector-panel select {
        width: 100%;
        padding: 10px 42px 10px 14px;
        border-radius: 12px;
        border: 1px solid rgba(35, 45, 75, 0.25);
        background: rgba(255, 255, 255, 0.92);
        box-shadow: 0 6px 18px rgba(17, 24, 39, 0.1);
        font-size: 16px;
        font-family: 'FGDC', sans-serif;
        color: var(--panel-text-color);
        transition: border-color 0.2s ease, box-shadow 0.2s ease;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
      }
      .selector-panel select:focus {
        outline: none;
        border-color: rgba(229, 114, 0, 0.8);
        box-shadow: 0 0 0 3px rgba(229, 114, 0, 0.2);
      }
      .selector-panel .selector-section {
        display: flex;
        flex-direction: column;
        gap: 14px;
      }
      .selector-panel .selector-section-heading {
        display: flex;
        align-items: flex-start;
        flex-wrap: wrap;
        gap: 12px;
        width: 100%;
      }
      .selector-panel .selector-section-heading h3 {
        margin: 0;
        font-size: 18px;
        color: #232D4B;
        flex: 1 1 100%;
      }
      .selector-panel .selector-actions {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 10px;
        width: 100%;
        flex: 1 1 100%;
        margin-top: 4px;
      }
      .selector-panel .selector-actions .pill-button {
        width: 100%;
      }
      .selector-panel .route-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .selector-panel label.route-option {
        display: flex;
        align-items: flex-start;
        gap: 12px;
        padding: 12px 14px;
        background: var(--panel-highlight);
        border-radius: 14px;
        border: 1px solid transparent;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease, background-color 0.2s ease;
        cursor: pointer;
      }
      .selector-panel label.route-option:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 26px rgba(15, 23, 42, 0.12);
        border-color: rgba(35, 45, 75, 0.25);
      }
      .selector-panel label.route-option.is-active {
        background: rgba(229, 114, 0, 0.14);
        border-color: rgba(229, 114, 0, 0.55);
        box-shadow: 0 16px 32px rgba(229, 114, 0, 0.24);
      }
      .selector-panel label.route-option--out {
        background: rgba(35, 45, 75, 0.08);
      }
      .selector-panel label.route-option input[type="checkbox"] {
        margin-top: 2px;
        width: 18px;
        height: 18px;
        accent-color: var(--accent);
        flex-shrink: 0;
        cursor: pointer;
      }
      .selector-panel label.route-option input[type="checkbox"]:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px rgba(229, 114, 0, 0.3);
        border-radius: 4px;
      }
      .selector-panel .route-option-swatch {
        display: inline-flex;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        margin-top: 2px;
        border: 2px solid rgba(255, 255, 255, 0.9);
        box-shadow: 0 0 0 1px rgba(35, 45, 75, 0.2);
        flex-shrink: 0;
      }
      .selector-panel label.route-option input[type="checkbox"]:checked + .route-option-swatch {
        transform: scale(1.1);
        box-shadow: 0 0 0 2px rgba(229, 114, 0, 0.4);
      }
      .selector-panel .route-option-text {
        display: flex;
        flex-direction: column;
        gap: 4px;
        font-size: 15px;
        line-height: 1.3;
      }
      .selector-panel .route-option-name {
        font-weight: 600;
        color: #111827;
        letter-spacing: 0.2px;
      }
      .selector-panel .route-option-detail {
        font-size: 12px;
        color: var(--panel-muted-text);
      }
      .selector-panel button {
        border: none;
        border-radius: 999px;
        padding: 10px 16px;
        font-size: 15px;
        font-family: 'FGDC', sans-serif;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, color 0.2s ease;
        background: rgba(35, 45, 75, 0.1);
        color: #1b2540;
        border: 1px solid rgba(35, 45, 75, 0.18);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
      }
      .selector-panel button:hover {
        transform: translateY(-1px);
        box-shadow: 0 10px 20px rgba(35, 45, 75, 0.18);
        background: rgba(35, 45, 75, 0.18);
      }
      .selector-panel button:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px rgba(229, 114, 0, 0.35);
      }
      .selector-panel button:active {
        transform: translateY(0);
      }
      .selector-panel .toggle-indicator {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        margin-left: 8px;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 12px;
        letter-spacing: 0.8px;
        text-transform: uppercase;
        background: rgba(35, 45, 75, 0.12);
        color: rgba(35, 45, 75, 0.78);
      }
      .selector-panel button.is-active .toggle-indicator {
        background: rgba(229, 114, 0, 0.2);
        color: #1f2937;
      }
      .selector-panel button.accent {
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        color: #1f1300;
        border-color: rgba(229, 114, 0, 0.35);
        box-shadow: 0 12px 24px rgba(229, 114, 0, 0.28);
      }
      .selector-panel button.accent:hover {
        box-shadow: 0 16px 30px rgba(229, 114, 0, 0.36);
        background: linear-gradient(135deg, #f4841a, #ffad55);
      }
      .selector-panel .pill-button {
        font-size: 16px;
        padding: 12px 20px;
        letter-spacing: 0.3px;
      }
      .selector-panel .display-mode-group {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 10px;
      }
      .selector-panel .display-mode-button {
        width: 100%;
      }
      .selector-panel .display-mode-button.is-active {
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        color: #1f1300;
        border-color: rgba(229, 114, 0, 0.35);
        box-shadow: 0 12px 24px rgba(229, 114, 0, 0.28);
      }
      .selector-panel .display-mode-button.is-active:hover {
        box-shadow: 0 16px 30px rgba(229, 114, 0, 0.36);
        background: linear-gradient(135deg, #f4841a, #ffad55);
      }
      .selector-panel .full-width {
        width: 100%;
      }
      .panel-toggle {
        position: fixed;
        top: 50%;
        width: 34px;
        height: 70px;
        background: linear-gradient(180deg, var(--navy), var(--navy-darker));
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transform: translateY(-50%);
        z-index: 1150;
        text-align: center;
        font-size: 22px;
        user-select: none;
        transition: left 0.3s ease, right 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
        color: #f8fafc;
        box-shadow: 0 12px 28px rgba(15, 23, 42, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 0 4px;
      }
      .panel-toggle.is-hidden-mobile {
        display: none;
      }
      .panel-toggle--right {
        right: 0;
        border-top-left-radius: 14px;
        border-bottom-left-radius: 14px;
      }
      .panel-toggle--left {
        left: 0;
        border-top-right-radius: 14px;
        border-bottom-right-radius: 14px;
      }
      .panel-toggle:hover {
        background: linear-gradient(180deg, #2d3a5e, #253355);
        box-shadow: 0 16px 32px rgba(15, 23, 42, 0.3);
      }
      .panel-toggle:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--accent-soft), 0 16px 32px rgba(15, 23, 42, 0.3);
      }
      .panel-toggle__arrow {
        pointer-events: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 100%;
      }
      .panel-toggle__badge {
        position: absolute;
        top: 8px;
        right: 6px;
      }
      .panel-toggle--right .panel-toggle__badge {
        left: 6px;
        right: auto;
      }
      #routeLegend {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 1100;
        background: var(--panel-surface);
        padding: 12px 14px 16px;
        border-radius: 16px;
        border: 1px solid var(--panel-border-color);
        box-shadow: var(--panel-shadow);
        max-width: 240px;
        display: none;
        max-height: 70vh;
        overflow-y: auto;
        font-size: 16px;
        color: var(--panel-text-color);
        backdrop-filter: blur(12px);
        transition: transform 0.3s ease, opacity 0.3s ease, box-shadow 0.3s ease;
        scrollbar-width: thin;
        scrollbar-color: rgba(35, 45, 75, 0.35) rgba(35, 45, 75, 0.08);
      }
      #routeLegend::-webkit-scrollbar {
        width: 8px;
      }
      #routeLegend::-webkit-scrollbar-track {
        background: rgba(35, 45, 75, 0.08);
        border-radius: 12px;
      }
      #routeLegend::-webkit-scrollbar-thumb {
        background: rgba(35, 45, 75, 0.35);
        border-radius: 12px;
      }
      #routeLegend .legend-title {
        font-weight: 600;
        margin: 0 0 12px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        color: var(--panel-heading-color);
        font-size: 18px;
      }
      #routeLegend .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 8px 10px;
        background: var(--panel-highlight);
        border-radius: 12px;
        border: 1px solid transparent;
        transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
      }
      #routeLegend .legend-item + .legend-item {
        margin-top: 10px;
      }
      #routeLegend .legend-item:hover {
        transform: translateY(-1px);
        box-shadow: 0 12px 26px rgba(15, 23, 42, 0.14);
        border-color: rgba(35, 45, 75, 0.2);
      }
      #routeLegend .legend-color {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.9);
        box-shadow: 0 0 0 1px rgba(35, 45, 75, 0.2);
        flex-shrink: 0;
      }
      #routeLegend .legend-text {
        display: flex;
        flex-direction: column;
        gap: 3px;
        min-width: 0;
        flex: 1;
      }
      #routeLegend .legend-name {
        font-weight: 600;
        letter-spacing: 0.2px;
        color: var(--panel-heading-color);
        overflow-wrap: anywhere;
      }
      #routeLegend .legend-description {
        font-size: 13px;
        color: var(--panel-muted-text);
        overflow-wrap: anywhere;
      }
      @media (max-width: 600px) {
        .selector-panel {
          width: calc(100% - 32px);
          top: 16px;
        }
        #routeSelector {
          right: 16px;
        }
        #controlPanel {
          left: 16px;
        }
        #routeSelector.hidden {
          transform: translateX(calc(100% + 20px));
        }
        #controlPanel.hidden {
          transform: translateX(calc(-100% - 20px));
        }
        .selector-panel .selector-content {
          padding: 16px;
        }
        .selector-panel .selector-title {
          font-size: 20px;
        }
        .selector-panel .selector-subtitle {
          font-size: 12px;
        }
        .selector-panel .selector-section-heading h3 {
          font-size: 16px;
        }
        .selector-panel .incident-alert__item {
          flex-direction: column;
        }
        .selector-panel .incident-alert__media {
          width: 56px;
          height: 56px;
        }
        .selector-panel .incident-alert__meta {
          gap: 6px;
        }
        .selector-panel .incident-alert__routes-line {
          gap: 4px;
        }
        .selector-panel button {
          font-size: 14px;
        }
        .selector-panel .pill-button {
          font-size: 16px;
        }
        .panel-toggle {
          width: 40px;
          height: 80px;
          font-size: 28px;
        }
        #routeLegend {
          left: 16px;
          right: 16px;
          top: auto;
          bottom: 88px;
          max-width: none;
          max-height: 45vh;
        }
        .credit {
          bottom: 16px;
          right: 16px;
          left: auto;
          font-size: 12px;
          padding: 8px 14px;
          letter-spacing: 0.2px;
        }
        .cookie-banner {
          padding: 14px 16px;
        }
      }
      .credit {
        position: fixed;
        bottom: 16px;
        right: 16px;
        font-size: 13px;
        color: rgba(35, 45, 75, 0.8);
        background: var(--panel-surface);
        border-radius: 999px;
        padding: 10px 16px;
        border: 1px solid var(--panel-border-color);
        box-shadow: 0 16px 30px rgba(15, 23, 42, 0.2);
        letter-spacing: 0.25px;
        text-transform: uppercase;
        backdrop-filter: blur(10px);
        pointer-events: none;
      }
      .cookie-banner {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, rgba(35, 45, 75, 0.95), rgba(27, 39, 74, 0.95));
        color: #f8fafc;
        padding: 16px 20px;
        font-size: 14px;
        z-index: 1200;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 14px;
        flex-wrap: wrap;
        box-shadow: 0 -16px 36px rgba(15, 23, 42, 0.4);
        backdrop-filter: blur(14px);
        letter-spacing: 0.25px;
        text-align: center;
        border-top: 1px solid rgba(255, 255, 255, 0.12);
      }
      .cookie-banner button {
        margin-left: 0;
        border: none;
        border-radius: 999px;
        background: linear-gradient(135deg, var(--accent), var(--accent-bright));
        color: #1f1300;
        padding: 10px 20px;
        font-family: 'FGDC', sans-serif;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 12px 24px rgba(229, 114, 0, 0.35);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }
      .cookie-banner button:hover {
        transform: translateY(-1px);
        box-shadow: 0 16px 30px rgba(229, 114, 0, 0.42);
      }
      .cookie-banner button:focus-visible {
        outline: none;
        box-shadow: 0 0 0 3px var(--accent-soft), 0 16px 30px rgba(229, 114, 0, 0.42);
      }
    </style>
    <script>
      // Manually set these variables.
      // adminMode: true for admin view (with speed/block bubbles and unit numbers).
      //            Can be disabled via URL param `adminMode=false`.
      //            In public mode (adminMode=false) the route selector is still shown
      //            but only for routes that are public-facing.
      // kioskMode: true to hide the route selector/tab and suppress vehicle overlays for a public display.
      // adminKioskMode: true to hide the route selector/tab while retaining admin overlays (previous kiosk behavior).
      // displayMode selects whether admin overlays show speed, block numbers, or neither.
      const DISPLAY_MODES = Object.freeze({
        SPEED: 'speed',
        BLOCK: 'block',
        NONE: 'none'
      });
      let adminMode = true; // shows unit numbers and speed/block bubbles
      let kioskMode = false;
      let adminKioskMode = false;
      let displayMode = DISPLAY_MODES.BLOCK;

      const PANEL_COLLAPSE_BREAKPOINT = 600;

      const enableOverlapDashRendering = true;

      const ROUTE_LAYER_BASE_OPTIONS = Object.freeze({
        updateWhenZooming: true,
        updateWhenIdle: true,
        interactive: false
      });
      let sharedRouteRenderer = null;
      let routePaneName = 'overlayPane';
      let lastRenderedLegendRoutes = [];

      function createSpatialIndex(options = {}) {
        if (typeof rbush === 'function') {
          try {
            return rbush(options.maxEntries);
          } catch (error) {
            console.error('Failed to create rbush index via rbush()', error);
          }
        }
        if (typeof RBush === 'function') {
          try {
            return new RBush(options.maxEntries);
          } catch (error) {
            console.error('Failed to create rbush index via new RBush()', error);
          }
        }
        console.error('RBush spatial index library is not available. Route overlap rendering will be disabled.');
        return null;
      }

      function mergeRouteLayerOptions(overrides = {}, rendererOverride = null, paneOverride = null) {
        const base = Object.assign({}, ROUTE_LAYER_BASE_OPTIONS);
        const renderer = rendererOverride || sharedRouteRenderer;
        if (renderer) {
          base.renderer = renderer;
        }
        const pane = paneOverride || routePaneName;
        if (typeof pane === 'string' && pane) {
          base.pane = pane;
        }
        return Object.assign(base, overrides || {});
      }

      const params = new URLSearchParams(window.location.search);
      const kioskParam = params.get('kioskMode');
      if (kioskParam !== null) {
        kioskMode = kioskParam.toLowerCase() === 'true';
      }
      const adminKioskParam = params.get('adminKioskMode');
      if (adminKioskParam !== null) {
        adminKioskMode = adminKioskParam.toLowerCase() === 'true';
      }
      const adminParam = params.get('adminMode');
      if (adminParam !== null) {
        adminMode = adminParam.toLowerCase() === 'true';
      }
      
      const outOfServiceRouteColor = '#000000';

      const PULSEPOINT_ENDPOINT = "https://api.pulsepoint.org/v1/webapp?resource=incidents&agencyid=54000,00300";
      const PULSEPOINT_PASSPHRASE = "tombrady5rings";
      const INCIDENT_REFRESH_INTERVAL_MS = 45000;
      const FALLBACK_INCIDENT_ICON_SIZE = 36;
      const INCIDENT_ICON_SCALE = 0.25;
      const DEFAULT_ICON_SCALE = Number.isFinite(INCIDENT_ICON_SCALE) && INCIDENT_ICON_SCALE > 0
        ? INCIDENT_ICON_SCALE
        : 1;
      const DEFAULT_SCALED_INCIDENT_ICON_HEIGHT = Math.max(1, Math.round(FALLBACK_INCIDENT_ICON_SIZE * DEFAULT_ICON_SCALE));
      const HALO_MIN_RADIUS_PX = 16;
      const HALO_MAX_RADIUS_PX = 64;
      const HALO_BASE_OPACITY = 0.5;
      const HALO_DURATION_MS = 1600;
      const HALO_COLOR_DEFAULT = '#FF5A3C';
      const HALO_COLOR_RGB = (() => {
        if (typeof HALO_COLOR_DEFAULT !== 'string') return '255, 90, 60';
        const hex = HALO_COLOR_DEFAULT.replace(/[^0-9a-f]/gi, '').trim();
        if (hex.length === 3) {
          const r = parseInt(hex[0] + hex[0], 16);
          const g = parseInt(hex[1] + hex[1], 16);
          const b = parseInt(hex[2] + hex[2], 16);
          if ([r, g, b].every(value => Number.isFinite(value))) {
            return `${r}, ${g}, ${b}`;
          }
        } else if (hex.length === 6) {
          const r = parseInt(hex.slice(0, 2), 16);
          const g = parseInt(hex.slice(2, 4), 16);
          const b = parseInt(hex.slice(4, 6), 16);
          if ([r, g, b].every(value => Number.isFinite(value))) {
            return `${r}, ${g}, ${b}`;
          }
        }
        return '255, 90, 60';
      })();
      const INCIDENT_HALO_ANIMATED_LIMIT = 60;
      // To tweak the centroid offset without editing this file, set
      // window.HeadwayGuardIncidentMarkerOffset = { xFactor: <number>, yFactor: <number> }
      // before this script runs. Factors are multiplied by the scaled marker height.
      const markerCentroidOverride = (typeof window !== 'undefined' && window.HeadwayGuardIncidentMarkerOffset)
        ? window.HeadwayGuardIncidentMarkerOffset
        : null;
      const MARKER_CENTROID_OFFSET_Y_FACTOR = typeof markerCentroidOverride?.yFactor === 'number'
        ? markerCentroidOverride.yFactor
        : -0.18;
      const MARKER_CENTROID_OFFSET_X_FACTOR = typeof markerCentroidOverride?.xFactor === 'number'
        ? markerCentroidOverride.xFactor
        : 0;
      const INCIDENTS_ALLOWED_AGENCY_NAMES = ['University of Virginia', 'University of Virginia Health'];
      const AGENCY_TYPE_RIDESYSTEMS = 'ridesystems';
      const AGENCY_TYPE_ETASPOT = 'etaspot';
      const ETASPOT_DEFAULT_TOKEN = 'TESTING';
      const EARTH_RADIUS_METERS = 6371000;

      let map;
      let markers = {};
      let busMarkerStates = {};
      const vehicleHeadingCache = new Map();
      let vehicleHeadingCachePromise = null;
      const VEHICLE_HEADING_CACHE_ENDPOINT = '/v1/vehicle_headings';

      function rememberCachedVehicleHeading(vehicleID, headingDeg, timestamp) {
        if (!Number.isFinite(headingDeg)) {
          return;
        }
        if (vehicleID === undefined || vehicleID === null) {
          return;
        }
        const key = `${vehicleID}`;
        if (!key || key === 'undefined' || key === 'null') {
          return;
        }
        const normalizedHeading = normalizeHeadingDegrees(headingDeg);
        const updatedAt = Number.isFinite(timestamp) ? Number(timestamp) : Date.now();
        vehicleHeadingCache.set(key, { heading: normalizedHeading, updatedAt });
      }

      function getCachedVehicleHeading(vehicleID) {
        if (vehicleID === undefined || vehicleID === null) {
          return null;
        }
        const key = `${vehicleID}`;
        const entry = vehicleHeadingCache.get(key);
        if (!entry) {
          return null;
        }
        const heading = Number(entry.heading ?? entry.Heading);
        if (!Number.isFinite(heading)) {
          return null;
        }
        return normalizeHeadingDegrees(heading);
      }

      function getVehicleHeadingFallback(vehicleID, headingFromFeed) {
        const cached = getCachedVehicleHeading(vehicleID);
        if (cached !== null) {
          return cached;
        }
        const fromFeed = Number(headingFromFeed);
        if (Number.isFinite(fromFeed)) {
          return normalizeHeadingDegrees(fromFeed);
        }
        return BUS_MARKER_DEFAULT_HEADING;
      }

      function loadVehicleHeadingCache() {
        if (vehicleHeadingCachePromise) {
          return vehicleHeadingCachePromise;
        }
        if (typeof fetch !== 'function') {
          vehicleHeadingCachePromise = Promise.resolve(vehicleHeadingCache);
          return vehicleHeadingCachePromise;
        }
        vehicleHeadingCachePromise = (async () => {
          try {
            const response = await fetch(VEHICLE_HEADING_CACHE_ENDPOINT, { cache: 'no-store' });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();
            if (data && typeof data === 'object' && data.headings && typeof data.headings === 'object') {
              Object.entries(data.headings).forEach(([vehicleID, entry]) => {
                if (!vehicleID) {
                  return;
                }
                let headingValue = entry;
                let updatedAt = undefined;
                if (entry && typeof entry === 'object') {
                  headingValue = entry.heading ?? entry.Heading;
                  const tsCandidate = entry.updated_at ?? entry.updatedAt ?? entry.timestamp ?? entry.ts_ms ?? entry.ts;
                  if (Number.isFinite(Number(tsCandidate))) {
                    updatedAt = Number(tsCandidate);
                  }
                }
                const headingNumber = Number(headingValue);
                if (!Number.isFinite(headingNumber)) {
                  return;
                }
                rememberCachedVehicleHeading(vehicleID, headingNumber, updatedAt);
              });
            }
          } catch (error) {
            console.info('Vehicle heading cache unavailable; continuing without it.', error);
          }
          return vehicleHeadingCache;
        })();
        return vehicleHeadingCachePromise;
      }

      let pendingBusVisualUpdates = new Map();
      let busMarkerVisualUpdateFrame = null;
      let selectedVehicleId = null;
      let markerScaleUpdateFrame = null;
      let pendingMarkerScaleMetrics = null;
      let textMeasurementCanvas = null;

      let agencies = [];
      let baseURL = '';
      let currentAgencyType = AGENCY_TYPE_RIDESYSTEMS;
      let currentAgencyConfig = null;

      function setCurrentAgencyByUrl(url) {
        if (!Array.isArray(agencies) || agencies.length === 0) {
          currentAgencyConfig = null;
          currentAgencyType = AGENCY_TYPE_RIDESYSTEMS;
          return;
        }
        const matchedAgency = agencies.find(agency => agency && typeof agency.url === 'string' && agency.url === url) || null;
        currentAgencyConfig = matchedAgency;
        currentAgencyType = matchedAgency?.type || AGENCY_TYPE_RIDESYSTEMS;
      }

      function isEtaSpotAgencyConfig(config) {
        return !!config && config.type === AGENCY_TYPE_ETASPOT;
      }

      function isEtaSpotAgency() {
        return isEtaSpotAgencyConfig(currentAgencyConfig);
      }

      function getEtaSpotServiceUrl() {
        if (!isEtaSpotAgency()) {
          return '';
        }
        const configUrl = typeof currentAgencyConfig?.serviceUrl === 'string'
          ? currentAgencyConfig.serviceUrl
          : '';
        const sanitizedConfigUrl = sanitizeBaseUrl(configUrl);
        if (sanitizedConfigUrl) {
          return sanitizedConfigUrl;
        }
        const sanitizedBase = sanitizeBaseUrl(baseURL);
        if (!sanitizedBase) {
          return '';
        }
        return `${sanitizedBase}/service.php`;
      }

      function getEtaSpotToken() {
        if (!isEtaSpotAgency()) {
          return '';
        }
        const token = typeof currentAgencyConfig?.token === 'string' ? currentAgencyConfig.token.trim() : '';
        return token || ETASPOT_DEFAULT_TOKEN;
      }

      const SERVICE_ALERT_REFRESH_INTERVAL_MS = 60000;
      const SERVICE_ALERT_START_FIELDS = Object.freeze([
        'StartDateText',
        'StartDateDisplay',
        'StartDateLocalText',
        'StartDateLocal',
        'StartDate',
        'StartDateUtc',
        'StartDateTime',
        'StartDateISO',
        'StartTimestamp',
        'StartTime',
        'Start',
        'BeginDateText',
        'BeginDate',
        'BeginDateUtc',
        'BeginTime',
        'EffectiveStart',
        'EffectiveStartDate',
        'EffectiveStartUtc'
      ]);
      const SERVICE_ALERT_END_FIELDS = Object.freeze([
        'EndDateText',
        'EndDateDisplay',
        'EndDateLocalText',
        'EndDateLocal',
        'EndDate',
        'EndDateUtc',
        'EndDateTime',
        'EndDateISO',
        'EndTimestamp',
        'EndTime',
        'End',
        'StopDateText',
        'StopDate',
        'StopDateUtc',
        'StopTime',
        'ExpirationDate',
        'ExpirationDateUtc',
        'ExpireDate',
        'ExpireDateUtc',
        'EffectiveEnd',
        'EffectiveEndDate',
        'EffectiveEndUtc'
      ]);
      const SERVICE_ALERT_EMPTY_MESSAGE = 'No active service alerts.';
      const SERVICE_ALERT_UNAVAILABLE_MESSAGE = 'Service alerts unavailable.';
      const SERVICE_ALERT_STATUS_NO_ALERTS = 'No active alerts';
      const SERVICE_ALERT_STATUS_LOADING = 'Loading';
      const SERVICE_ALERT_STATUS_ERROR = 'Unavailable';
      const SERVICE_ALERT_BADGE_MAX = 99;
      const SERVICE_ALERT_DATE_FORMATTER = (() => {
        if (typeof Intl === 'undefined' || typeof Intl.DateTimeFormat !== 'function') {
          return null;
        }
        try {
          return new Intl.DateTimeFormat('en-US', {
            dateStyle: 'medium',
            timeStyle: 'short',
            timeZoneName: 'short'
          });
        } catch (error) {
          // Some browsers (notably older Safari versions) do not support dateStyle/timeStyle.
          // Fall back to an options object that is more widely supported so the formatter
          // continues to work instead of throwing on initialization.
          try {
            return new Intl.DateTimeFormat('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
              hour: 'numeric',
              minute: '2-digit',
              timeZoneName: 'short'
            });
          } catch (fallbackError) {
            return null;
          }
        }
      })();
      let serviceAlerts = [];
      let serviceAlertsLoading = false;
      let serviceAlertsError = null;
      let serviceAlertsExpanded = false;

      let incidentsVisible = false;
      let incidentsVisibilityPreference = false;
      let incidentLayerGroup = null;
      const incidentMarkers = new Map();
      const incidentIconCache = new Map();
      const incidentHaloIconCache = new Map();
      let incidentHaloLayerGroup = null;
      let incidentsNearRoutesLookup = new Map();
      const reduceMotionMediaQuery = (typeof window !== 'undefined' && typeof window.matchMedia === 'function')
        ? window.matchMedia('(prefers-reduced-motion: reduce)')
        : null;
      let isFetchingIncidents = false;

      function hasIncidentsRequiringVisibility() {
        return incidentsNearRoutesLookup instanceof Map && incidentsNearRoutesLookup.size > 0;
      }

      function shouldShowIncidentLayer() {
        if (!incidentsAreAvailable()) {
          return false;
        }
        return incidentsVisible || hasIncidentsRequiringVisibility();
      }

      function maintainIncidentLayers() {
        if (!map) return;
        const shouldShow = shouldShowIncidentLayer();
        if (!incidentLayerGroup) {
          incidentLayerGroup = L.layerGroup();
        }
        if (shouldShow) {
          if (!map.hasLayer(incidentLayerGroup)) {
            incidentLayerGroup.addTo(map);
          }
        } else if (map.hasLayer(incidentLayerGroup)) {
          map.removeLayer(incidentLayerGroup);
        }
        const shouldShowHalos = shouldShow && hasIncidentsRequiringVisibility();
        if (!incidentHaloLayerGroup) {
          incidentHaloLayerGroup = L.layerGroup();
        }
        if (shouldShowHalos) {
          if (!map.hasLayer(incidentHaloLayerGroup)) {
            incidentHaloLayerGroup.addTo(map);
          }
        } else if (map.hasLayer(incidentHaloLayerGroup)) {
          map.removeLayer(incidentHaloLayerGroup);
        }
      }

      const INCIDENT_ROUTE_PROXIMITY_THRESHOLD_METERS = 150;
      const INCIDENT_TIME_ZONE = 'America/New_York';
      const INCIDENT_LIST_ICON_BASE_URL = 'https://web.pulsepoint.org/images/respond_icons/';
      const INCIDENT_TYPE_LABELS = Object.freeze({
        AED: 'AED Alarm',
        AC: 'Aircraft Crash',
        AE: 'Aircraft Emergency',
        AES: 'Aircraft Emergency Standby',
        OA: 'Alarm',
        AR: 'Animal Rescue',
        AF: 'Appliance Fire',
        AI: 'Arson Investigation',
        AA: 'Auto Aid',
        BT: 'Bomb Threat',
        BP: 'Burn Permit',
        CMA: 'Carbon Monoxide',
        CHIM: 'Chimney Fire',
        CR: 'Cliff Rescue',
        TCP: 'Collision Involving Pedestrian',
        TCS: 'Collision Involving Structure',
        TCT: 'Collision Involving Train',
        CF: 'Commercial Fire',
        CL: 'Commercial Lockout',
        CA: 'Community Activity',
        CP: 'Community Paramedicine',
        CSR: 'Confined Space Rescue',
        WF: 'Confirmed Fire',
        WSF: 'Confirmed Structure Fire',
        WVEG: 'Confirmed Vegetation Fire',
        CB: 'Controlled Burn/Prescribed Fire',
        EQ: 'Earthquake',
        EE: 'Electrical Emergency',
        ELF: 'Electrical Fire',
        ELR: 'Elevator Rescue',
        EER: 'Elevator/Escalator Rescue',
        EM: 'Emergency',
        ER: 'Emergency Response',
        TCE: 'Expanded Traffic Collision',
        EX: 'Explosion',
        EF: 'Extinguished Fire',
        FIRE: 'Fire',
        FA: 'Fire Alarm',
        FW: 'Fire Watch',
        FWI: 'Fireworks Investigation',
        FLW: 'Flood Warning',
        FL: 'Flooding',
        FULL: 'Full Assignment',
        GAS: 'Gas Leak',
        HC: 'Hazardous Condition',
        HMR: 'Hazardous Response',
        HMI: 'Hazmat Investigation',
        IR: 'Ice Rescue',
        IF: 'Illegal Fire',
        IA: 'Industrial Accident',
        IFT: 'Interfacility Transfer',
        INV: 'Investigation',
        LR: 'Ladder Request',
        LZ: 'Landing Zone',
        LA: 'Lift Assist',
        LO: 'Lockout',
        MA: 'Manual Alarm',
        MF: 'Marine Fire',
        ME: 'Medical Emergency',
        MC: 'Move-up/Cover',
        MCI: 'Multi Casualty',
        MU: 'Mutual Aid',
        NO: 'Notification',
        OI: 'Odor Investigation',
        OF: 'Outside Fire',
        PE: 'Pipeline Emergency',
        PF: 'Pole Fire',
        PA: 'Police Assist',
        PLE: 'Powerline Emergency',
        PS: 'Public Service',
        RTE: 'Railroad/Train Emergency',
        GF: 'Refuse/Garbage Fire',
        RES: 'Rescue',
        RF: 'Residential Fire',
        RL: 'Residential Lockout',
        RR: 'Rope Rescue',
        SH: 'Sheared Hydrant',
        SD: 'Smoke Detector',
        SI: 'Smoke Investigation',
        STBY: 'Standby',
        ST: 'Strike Team/Task Force',
        SC: 'Structural Collapse',
        SF: 'Structure Fire',
        TF: 'Tank Fire',
        TR: 'Technical Rescue',
        TEST: 'Test',
        TOW: 'Tornado Warning',
        TC: 'Traffic Collision',
        TRNG: 'Training',
        TE: 'Transformer Explosion',
        TD: 'Tree Down',
        TNR: 'Trench Rescue',
        TRBL: 'Trouble Alarm',
        TSW: 'Tsunami Warning',
        USAR: 'Urban Search and Rescue',
        VEG: 'Vegetation Fire',
        VF: 'Vehicle Fire',
        VL: 'Vehicle Lockout',
        VS: 'Vessel Sinking',
        WE: 'Water Emergency',
        WR: 'Water Rescue',
        WFA: 'Waterflow Alarm',
        WX: 'Weather Incident',
        WA: 'Wires Arching',
        WD: 'Wires Down',
        WDA: 'Wires Down/Arcing',
        WCF: 'Working Commercial Fire',
        WRF: 'Working Residential Fire'
      });
      const INCIDENT_RECEIVED_FIELDS = Object.freeze([
        'CallReceivedDateTime',
        'ReceivedDateTime',
        'Received',
        'CallReceived',
        'FirstReceived',
        'CreateDate',
        'CreatedDateTime',
        'DispatchDateTime'
      ]);
      const INCIDENT_UNIT_STATUS_INFO = Object.freeze({
        DP: { label: 'Dispatched', color: '#f57c00', background: 'rgba(245, 124, 0, 0.16)', border: 'rgba(245, 124, 0, 0.38)' },
        AK: { label: 'Acknowledged', color: '#f57c00', background: 'rgba(245, 124, 0, 0.16)', border: 'rgba(245, 124, 0, 0.38)' },
        ER: { label: 'En Route', color: '#00cc00', background: 'rgba(0, 204, 0, 0.16)', border: 'rgba(0, 204, 0, 0.38)' },
        SG: { label: 'Staged', color: '#cc0000', background: 'rgba(204, 0, 0, 0.16)', border: 'rgba(204, 0, 0, 0.38)' },
        OS: { label: 'On Scene', color: '#cc0000', background: 'rgba(204, 0, 0, 0.16)', border: 'rgba(204, 0, 0, 0.38)' },
        AE: { label: 'Available On Scene', color: '#cc0000', background: 'rgba(204, 0, 0, 0.16)', border: 'rgba(204, 0, 0, 0.38)' },
        TR: { label: 'Transport', color: '#ffc107', background: 'rgba(255, 193, 7, 0.16)', border: 'rgba(255, 193, 7, 0.38)' },
        TA: { label: 'Transport Arrived', color: '#1976d2', background: 'rgba(25, 118, 210, 0.16)', border: 'rgba(25, 118, 210, 0.38)' },
        AR: { label: 'Cleared From Incident', color: '#494949', background: 'rgba(73, 73, 73, 0.16)', border: 'rgba(73, 73, 73, 0.38)' }
      });
      const INCIDENT_UNIT_STATUS_ALIASES = Object.freeze({
        DP: 'DP',
        DISPATCHED: 'DP',
        DISPATCH: 'DP',
        AK: 'AK',
        ACK: 'AK',
        ACKNOWLEDGED: 'AK',
        ER: 'ER',
        'EN ROUTE': 'ER',
        ENROUTE: 'ER',
        SG: 'SG',
        STAGED: 'SG',
        OS: 'OS',
        'ON SCENE': 'OS',
        'ON-SCENE': 'OS',
        ONSCENE: 'OS',
        AE: 'AE',
        'AVAILABLE ON SCENE': 'AE',
        'AVAILABLE ONSCENE': 'AE',
        'AVAILABLE ON-SCENE': 'AE',
        'AVAIL ON SCENE': 'AE',
        TR: 'TR',
        TRANSPORT: 'TR',
        TRANSPORTING: 'TR',
        TA: 'TA',
        'TRANSPORT ARRIVED': 'TA',
        'TRANSPORT-ARRIVED': 'TA',
        'TRANSPORT ARRVD': 'TA',
        AR: 'AR',
        CLEARED: 'AR',
        'CLEARED FROM INCIDENT': 'AR'
      });
      const INCIDENT_UNIT_STATUS_SECTION_ORDER = Object.freeze([
        'OS',
        'AE',
        'SG',
        'ER',
        'TR',
        'TA',
        'DP',
        'AK',
        'AR'
      ]);
      const INCIDENT_UNIT_STATUS_FALLBACK_LABEL = 'Status Unknown';

      let latestActiveIncidents = [];
      let incidentsNearRoutes = [];
      let incidentRouteAlertSignature = '';
      // Demo incident preview state (delete when demo button is removed).
      let demoIncidentActive = false;
      let demoIncidentEntry = null;
      let demoIncidentPreviousVisibility = null;
      const DEMO_INCIDENT_STATIC_ROW = Object.freeze({
        Marker: 'https://web.pulsepoint.org/images/respond_icons/me_map_active.png',
        Category: 'active',
        ID: '2296541797',
        Type: 'ME',
        Address: 'HILLSDALE DR, CHARLOTTESVILLE, VA',
        Received: '2025-09-22T02:25:48Z',
        Agency: '00300',
        Latitude: '38.0739216008',
        Longitude: '-78.4735028808',
        Units: 'E83 (OS), RS18 (OS)'
      });

      let demoIncidentCsvRow = null;

      function incidentsAreAvailable() {
        const adminAccessAllowed = (adminMode && !kioskMode) || adminKioskMode;
        if (!adminAccessAllowed) {
          return false;
        }
        if (!Array.isArray(agencies) || agencies.length === 0) {
          return true;
        }
        const sanitizedBaseURL = typeof baseURL === 'string' ? baseURL.trim().replace(/\/+$/, '') : '';
        const selectedAgency = agencies.find(agency => {
          if (!agency || typeof agency.url !== 'string') return false;
          const candidateUrl = agency.url.trim().replace(/\/+$/, '');
          return candidateUrl === sanitizedBaseURL;
        });
        if (!selectedAgency || typeof selectedAgency.name !== 'string') {
          return false;
        }
        const normalizedName = selectedAgency.name.trim().toLowerCase();
        return INCIDENTS_ALLOWED_AGENCY_NAMES.some(name => {
          return typeof name === 'string' && name.trim().toLowerCase() === normalizedName;
        });
      }

      if (!incidentsAreAvailable()) {
        incidentsVisible = false;
      }
      incidentsVisibilityPreference = incidentsVisible;

      function fetchPulsePointEncrypted() {
        return fetch(PULSEPOINT_ENDPOINT, {
          method: 'GET',
          mode: 'cors',
          cache: 'no-store'
        }).then(response => {
          if (!response || !response.ok) {
            throw new Error(response ? `PulsePoint HTTP ${response.status}` : 'PulsePoint request failed');
          }
          return response.json();
        });
      }

      function decryptPulsePointPayload(encryptedObj) {
        if (!encryptedObj) {
          throw new Error('Missing PulsePoint payload.');
        }
        const obj = typeof encryptedObj === 'string' ? JSON.parse(encryptedObj) : encryptedObj;
        if (!obj || typeof obj !== 'object' || !obj.ct) {
          throw new Error('PulsePoint payload is malformed.');
        }
        const cipherParams = CryptoJS.lib.CipherParams.create({
          ciphertext: CryptoJS.enc.Base64.parse(obj.ct)
        });
        if (obj.iv) cipherParams.iv = CryptoJS.enc.Hex.parse(obj.iv);
        if (obj.s) cipherParams.salt = CryptoJS.enc.Hex.parse(obj.s);
        const rawText = CryptoJS.AES.decrypt(cipherParams, PULSEPOINT_PASSPHRASE, {
          mode: CryptoJS.mode.CBC,
          padding: CryptoJS.pad.Pkcs7
        }).toString(CryptoJS.enc.Utf8);
        if (!rawText) {
          throw new Error('PulsePoint decryption returned empty payload.');
        }
        let parsed = rawText;
        for (let i = 0; i < 3; i += 1) {
          if (typeof parsed === 'string') {
            try {
              parsed = JSON.parse(parsed);
              continue;
            } catch (error) {
              break;
            }
          }
          break;
        }
        if (typeof parsed === 'string') {
          throw new Error('PulsePoint decrypted payload is not valid JSON.');
        }
        return { parsed, rawText };
      }

      function looksLikePulsePointIncident(obj) {
        if (!obj || typeof obj !== 'object') return false;
        const keys = ['ID', 'FullDisplayAddress', 'PulsePointIncidentCallType', 'CallReceivedDateTime', 'Latitude', 'Longitude'];
        return keys.filter(key => key in obj).length >= 2;
      }

      function inferPulsePointMarkerType(rec) {
        const candidates = [
          rec.PulsePointIncidentCallTypePrimaryCode,
          rec.PulsePointIncidentCallTypeCode,
          rec.PulsePointIncidentCallTypeID,
          rec.PulsePointIncidentTypeCode,
          rec.PulsePointIncidentType,
          rec.CallTypeCode,
          rec.TypeCode,
          rec.CallType,
          rec.Type,
          rec.IncidentType,
          rec.PulsePointIncidentCallType
        ];
        for (const value of candidates) {
          if (value == null) continue;
          const raw = typeof value === 'number' ? value.toString() : String(value);
          const trimmed = raw.trim();
          if (!trimmed) continue;
          if (/^[A-Za-z0-9]{1,6}$/.test(trimmed)) return trimmed.toUpperCase();
          const firstToken = trimmed.split(/[\s/-]+/)[0];
          if (firstToken && /^[A-Za-z0-9]{1,4}$/.test(firstToken)) return firstToken.toUpperCase();
          const words = trimmed.match(/[A-Za-z0-9]+/g);
          if (words && words.length >= 2) {
            const acronym = words.map(word => word[0]).join('');
            if (acronym && /^[A-Za-z0-9]{1,4}$/.test(acronym)) return acronym.toUpperCase();
          }
        }
        return '';
      }

      function buildPulsePointMarkerUrl(type, category) {
        const categoryLower = (category || '').toLowerCase();
        if (!type || (categoryLower !== 'active' && categoryLower !== 'recent')) return '';
        return `https://web.pulsepoint.org/images/respond_icons/${type.toLowerCase()}_map_${categoryLower}.png`;
      }

      function pulsePointMarkerAltText(type, category, fallback) {
        const parts = [];
        if (type) parts.push(type);
        if (category) parts.push(category);
        if (!parts.length && fallback) parts.push(fallback);
        if (!parts.length) return 'Marker icon';
        parts.push('marker icon');
        return parts.join(' ');
      }

      function decoratePulsePointIncident(rec, category) {
        const copy = { ...(rec || {}), _category: category };
        if (Array.isArray(copy.Unit)) {
          copy._units = copy.Unit.map(u => {
            const id = u.UnitID || u.Unit || '';
            const status = u.PulsePointDispatchStatus || u.Status || '';
            return status ? `${id} (${status})` : id;
          }).join(', ');
        } else {
          copy._units = '';
        }
        const markerType = inferPulsePointMarkerType(copy);
        const markerCategory = (category || '').toLowerCase();
        const markerUrl = buildPulsePointMarkerUrl(markerType, markerCategory);
        copy._markerType = markerType;
        copy._markerCategory = markerUrl ? markerCategory : '';
        copy._markerUrl = markerUrl;
        copy._markerAlt = markerUrl ? pulsePointMarkerAltText(markerType, markerCategory, copy.PulsePointIncidentCallType) : '';
        return copy;
      }

      function normalizePulsePointIncidents(root) {
        const out = [];
        const incidentsRoot = root && root.incidents;
        const categories = [['active', 'active'], ['recent', 'recent'], ['alerts', 'alerts']];
        let pulled = 0;
        if (incidentsRoot && typeof incidentsRoot === 'object') {
          for (const [key, label] of categories) {
            const arr = Array.isArray(incidentsRoot[key]) ? incidentsRoot[key] : [];
            arr.forEach(rec => out.push(decoratePulsePointIncident(rec, label)));
            pulled += arr.length;
          }
          if (pulled) return out;
        }
        const rootKeys = root && typeof root === 'object' ? Object.keys(root) : [];
        for (const key of rootKeys) {
          const value = root[key];
          if (Array.isArray(value) && value.every(looksLikePulsePointIncident)) {
            value.forEach(rec => out.push(decoratePulsePointIncident(rec, key)));
          } else if (value && typeof value === 'object') {
            Object.keys(value).forEach(innerKey => {
              const innerValue = value[innerKey];
              if (Array.isArray(innerValue) && innerValue.every(looksLikePulsePointIncident)) {
                innerValue.forEach(rec => out.push(decoratePulsePointIncident(rec, innerKey)));
              }
            });
          }
        }
        if (out.length) return out;
        (function dig(x, label = 'misc') {
          if (!x) return;
          if (Array.isArray(x) && x.length && looksLikePulsePointIncident(x[0])) {
            x.forEach(rec => out.push(decoratePulsePointIncident(rec, label)));
            return;
          }
          if (typeof x === 'object') {
            Object.keys(x).forEach(childKey => dig(x[childKey], childKey));
          }
        })(root);
        return out;
      }

      function resetIncidentAlertState() {
        latestActiveIncidents = [];
        updateIncidentsNearRoutes([], '');
      }

      function parseIncidentDate(value) {
        if (value === undefined || value === null || value === '') return null;
        if (value instanceof Date && !Number.isNaN(value.getTime())) return value;
        if (typeof value === 'number' && Number.isFinite(value)) {
          const fromNumber = new Date(value);
          return Number.isNaN(fromNumber.getTime()) ? null : fromNumber;
        }
        const str = String(value).trim();
        if (!str) return null;
        let parsed = new Date(str);
        if (!Number.isNaN(parsed.getTime())) return parsed;
        if (!/[zZ]|[+-]\d{2}:?\d{2}$/.test(str)) {
          parsed = new Date(`${str}Z`);
          if (!Number.isNaN(parsed.getTime())) return parsed;
        }
        return null;
      }

      function getIncidentReceivedTimeInfo(incident) {
        if (!incident) return null;
        for (const field of INCIDENT_RECEIVED_FIELDS) {
          if (!Object.prototype.hasOwnProperty.call(incident, field)) continue;
          const date = parseIncidentDate(incident[field]);
          if (!date) continue;
          try {
            const display = new Intl.DateTimeFormat('en-US', {
              hour: 'numeric',
              minute: '2-digit',
              hour12: true,
              timeZone: INCIDENT_TIME_ZONE
            }).format(date);
            const full = new Intl.DateTimeFormat('en-US', {
              dateStyle: 'medium',
              timeStyle: 'short',
              timeZone: INCIDENT_TIME_ZONE
            }).format(date);
            return { display, full };
          } catch (error) {
            const fallback = date.toLocaleString();
            return { display: fallback, full: fallback };
          }
        }
        return null;
      }

      function getIncidentTimestamp(incident) {
        if (!incident) return null;
        for (const field of INCIDENT_RECEIVED_FIELDS) {
          if (!Object.prototype.hasOwnProperty.call(incident, field)) continue;
          const date = parseIncidentDate(incident[field]);
          if (date) {
            return date.getTime();
          }
        }
        return null;
      }

      // === Demo incident CSV helpers (remove alongside the demo button) ===
      function parseCsvRows(text) {
        if (typeof text !== 'string') return [];
        const rows = [];
        let current = [];
        let field = '';
        let inQuotes = false;
        for (let i = 0; i < text.length; i += 1) {
          const char = text[i];
          if (inQuotes) {
            if (char === '"') {
              if (text[i + 1] === '"') {
                field += '"';
                i += 1;
              } else {
                inQuotes = false;
              }
            } else {
              field += char;
            }
            continue;
          }
          if (char === '"') {
            inQuotes = true;
            continue;
          }
          if (char === ',') {
            current.push(field);
            field = '';
            continue;
          }
          if (char === '\r') {
            continue;
          }
          if (char === '\n') {
            current.push(field);
            rows.push(current);
            current = [];
            field = '';
            continue;
          }
          field += char;
        }
        if (field !== '' || current.length > 0) {
          current.push(field);
        }
        if (current.length > 0) {
          rows.push(current);
        }
        return rows.filter(row => Array.isArray(row) && row.some(value => String(value ?? '').trim() !== ''));
      }

      function extractFirstIncidentFromCsv(text) {
        const rows = parseCsvRows(text);
        if (!rows.length) return null;
        const header = rows[0].map(cell => String(cell ?? '').trim());
        for (let i = 1; i < rows.length; i += 1) {
          const row = rows[i];
          if (!row || !row.some(value => String(value ?? '').trim() !== '')) continue;
          const obj = {};
          header.forEach((key, index) => {
            if (!key) return;
            obj[key] = row[index] !== undefined ? row[index] : '';
          });
          const hasValue = Object.keys(obj).some(key => String(obj[key] ?? '').trim() !== '');
          if (hasValue) {
            return obj;
          }
        }
        return null;
      }

      function buildDemoIncidentEntryFromRow(row) {
        if (!row || typeof row !== 'object') return null;
        const sanitize = value => (typeof value === 'string' ? value.trim() : value);
        const typeValue = sanitize(row.Type) || 'INC';
        const typeCode = String(typeValue || '').trim().toUpperCase();
        const idRaw = sanitize(row.ID) || 'DEMO_INCIDENT';
        const id = String(idRaw).trim() || 'DEMO_INCIDENT';
        const normalizedId = getNormalizedIncidentId(id) || 'DEMO_INCIDENT';
        const markerUrl = sanitize(row.Marker) || '';
        const category = sanitize(row.Category) || 'active';
        const address = sanitize(row.Address) || 'Demo Address';
        const received = sanitize(row.Received) || new Date().toISOString();
        const agency = sanitize(row.Agency) || '';
        const units = sanitize(row.Units) || '';
        const lat = parseIncidentCoordinate(sanitize(row.Latitude));
        const lon = parseIncidentCoordinate(sanitize(row.Longitude));
        const label = (typeCode && Object.prototype.hasOwnProperty.call(INCIDENT_TYPE_LABELS, typeCode))
          ? INCIDENT_TYPE_LABELS[typeCode]
          : (typeValue ? String(typeValue) : 'Incident');
        const incident = {
          _markerUrl: markerUrl,
          _markerType: typeCode || 'INC',
          _category: category,
          _demo: true,
          ID: normalizedId,
          IncidentID: normalizedId,
          Type: typeCode || typeValue,
          TypeCode: typeCode || typeValue,
          PulsePointIncidentCallType: label,
          PulsePointIncidentCallTypeCode: typeCode || typeValue,
          CallType: label,
          CallTypeCode: typeCode || typeValue,
          Received: received,
          DisplayAddress: address,
          FullDisplayAddress: address,
          Address: address,
          Latitude: lat,
          Longitude: lon,
          Units: units,
          Agency: agency
        };
        const timestamp = getIncidentTimestamp(incident) ?? Date.now();
        const demoRouteColor = sanitizeCssColor(routeColors?.[404] || '#F97316');
        return {
          id: normalizedId,
          incident,
          routes: [
            { routeId: 404, name: 'Demo Route 404', distance: 42, color: demoRouteColor }
          ],
          closestDistance: 42,
          timestamp,
          _demo: true,
          _demoSignature: `demo-${normalizedId}`
        };
      }

      async function ensureDemoIncidentRow() {
        if (demoIncidentCsvRow) return demoIncidentCsvRow;
        if (!DEMO_INCIDENT_STATIC_ROW) return null;
        demoIncidentCsvRow = { ...DEMO_INCIDENT_STATIC_ROW };
        return demoIncidentCsvRow;
      }

      function createDemoIncidentEntry() {
        if (!demoIncidentCsvRow) return null;
        const entry = buildDemoIncidentEntryFromRow(demoIncidentCsvRow);
        if (!entry) return null;
        entry.incident = entry.incident ? { ...entry.incident } : null;
        entry.routes = Array.isArray(entry.routes)
          ? entry.routes.map(route => ({ ...route }))
          : [];
        return entry;
      }

      function normalizeUnitStatus(value) {
        if (value === undefined || value === null || value === '') {
          return { key: '', raw: '' };
        }
        const raw = String(value).trim();
        if (!raw) {
          return { key: '', raw: '' };
        }
        const upper = raw.toUpperCase();
        const canonical = INCIDENT_UNIT_STATUS_ALIASES[upper] || '';
        const info = canonical ? INCIDENT_UNIT_STATUS_INFO[canonical] || null : null;
        const label = info?.label || raw;
        return { key: canonical, raw, info, label };
      }

      function parseUnitString(text) {
        if (typeof text !== 'string') {
          return { name: '', status: '', raw: '' };
        }
        const trimmed = text.trim();
        if (!trimmed) {
          return { name: '', status: '', raw: '' };
        }
        const match = trimmed.match(/^(.*?)\s*\(([^)]*)\)\s*$/);
        if (match) {
          return {
            name: match[1].trim(),
            status: match[2].trim(),
            raw: trimmed
          };
        }
        return { name: trimmed, status: '', raw: trimmed };
      }

      function extractIncidentUnits(incident) {
        const units = [];
        if (incident && Array.isArray(incident.Unit)) {
          incident.Unit.forEach(entry => {
            if (!entry) return;
            const nameCandidates = [
              entry.UnitID,
              entry.Unit,
              entry.Name,
              entry.ApparatusID,
              entry.VehicleID
            ];
            let name = nameCandidates.find(value => typeof value === 'string' && value.trim());
            const statusCandidates = [
              entry.PulsePointDispatchStatus,
              entry.DispatchStatus,
              entry.Status,
              entry.UnitStatus
            ];
            let status = statusCandidates.find(value => typeof value === 'string' && value.trim());
            let parsed = null;
            if (typeof entry === 'string') {
              parsed = parseUnitString(entry);
              if (!status && parsed.status) {
                status = parsed.status;
              }
              if (!name && parsed.name) {
                name = parsed.name;
              }
            }
            const normalized = normalizeUnitStatus(status);
            const statusKey = normalized.key || '';
            const normalizedLabel = typeof normalized.label === 'string' ? normalized.label.trim() : '';
            const statusLabel = normalizedLabel || (typeof normalized.raw === 'string' ? normalized.raw.trim() : '');
            const unitName = typeof name === 'string' ? name.trim() : '';
            const rawText = parsed?.raw && parsed.raw.trim()
              ? parsed.raw.trim()
              : (typeof entry === 'string' ? entry.trim() : '');
            const displayText = unitName || statusLabel || rawText;
            if (!displayText) return;
            let tooltip = '';
            if (statusLabel) {
              tooltip = statusLabel;
            }
            if (normalized.raw && normalized.raw !== statusLabel && (!tooltip || tooltip.toLowerCase() !== normalized.raw.toLowerCase())) {
              tooltip = tooltip ? `${tooltip}  ${normalized.raw}` : normalized.raw;
            }
            units.push({
              displayText,
              statusKey,
              statusLabel,
              colorInfo: normalized.info || null,
              tooltip,
              rawStatus: normalized.raw,
              name: unitName
            });
          });
        }
        if (units.length === 0) {
          const stringCandidates = [
            incident?._units,
            incident?.Units,
            incident?.Apparatus,
            incident?.UnitString
          ];
          const source = stringCandidates.find(value => typeof value === 'string' && value.trim());
          if (source) {
            source.split(',').map(part => part.trim()).filter(Boolean).forEach(part => {
              const parsed = parseUnitString(part);
              const normalized = normalizeUnitStatus(parsed.status);
              const statusKey = normalized.key || '';
              const normalizedLabel = typeof normalized.label === 'string' ? normalized.label.trim() : '';
              const statusLabel = normalizedLabel || (typeof normalized.raw === 'string' ? normalized.raw.trim() : '');
              const baseName = parsed.name ? parsed.name.trim() : '';
              const displayText = baseName
                ? baseName
                : (statusLabel || (parsed.raw ? parsed.raw.trim() : ''));
              if (!displayText) return;
              let tooltip = '';
              if (statusLabel) {
                tooltip = statusLabel;
              }
              if (normalized.raw && normalized.raw !== statusLabel && (!tooltip || tooltip.toLowerCase() !== normalized.raw.toLowerCase())) {
                tooltip = tooltip ? `${tooltip}  ${normalized.raw}` : normalized.raw;
              }
              units.push({
                displayText,
                statusKey,
                statusLabel,
                colorInfo: normalized.info || null,
                tooltip,
                rawStatus: normalized.raw,
                name: baseName
              });
            });
          }
        }
        return units;
      }

      function getIncidentTypeCode(incident) {
        if (!incident) return '';
        const candidates = [
          incident._markerType,
          incident.PulsePointIncidentCallTypePrimaryCode,
          incident.PulsePointIncidentCallTypeCode,
          incident.PulsePointIncidentTypeCode,
          incident.CallTypeCode,
          incident.TypeCode,
          incident.CallType,
          incident.Type,
          incident.IncidentType
        ];
        for (const value of candidates) {
          if (value === undefined || value === null) continue;
          const raw = String(value).trim();
          if (!raw) continue;
          const normalized = raw.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
          if (normalized) return normalized;
        }
        return '';
      }

      function buildPulsePointListIconUrl(typeCode) {
        if (!typeCode) return '';
        const normalized = String(typeCode).trim().toLowerCase();
        if (!normalized) return '';
        return `${INCIDENT_LIST_ICON_BASE_URL}${normalized}_list.png`;
      }

      function getIncidentTypeLabel(incident) {
        const code = getIncidentTypeCode(incident);
        if (code && Object.prototype.hasOwnProperty.call(INCIDENT_TYPE_LABELS, code)) {
          return INCIDENT_TYPE_LABELS[code];
        }
        const fallbackCandidates = [
          incident?.PulsePointIncidentCallType,
          incident?.CallType,
          incident?.Type,
          incident?.IncidentType
        ];
        const fallback = fallbackCandidates.find(value => typeof value === 'string' && value.trim());
        if (fallback) return fallback.trim();
        if (code) return code;
        return 'Incident';
      }

      async function fetchPulsePointIncidents() {
        const encrypted = await fetchPulsePointEncrypted();
        const { parsed } = decryptPulsePointPayload(encrypted);
        return normalizePulsePointIncidents(parsed);
      }

      function parseIncidentCoordinate(value) {
        if (value === undefined || value === null || value === '') return null;
        const numeric = typeof value === 'number' ? value : Number.parseFloat(value);
        return Number.isFinite(numeric) ? numeric : null;
      }

      function getNormalizedIncidentId(value) {
        if (value === undefined || value === null) return '';
        const str = typeof value === 'string' ? value : String(value);
        const trimmed = str.trim();
        return trimmed;
      }

      function getIncidentIdentifier(rec) {
        if (!rec || typeof rec !== 'object') return null;
        const candidateKeys = [
          'ID',
          'IncidentID',
          'IncidentNumber',
          'PulsePointIncidentID',
          'PulsePointIncidentCallNumber',
          'CadIncidentNumber',
          'CADIncidentNumber'
        ];
        for (const key of candidateKeys) {
          const value = rec[key];
          if (value === undefined || value === null) continue;
          const str = String(value).trim();
          if (str) return str;
        }
        const lat = parseIncidentCoordinate(rec.Latitude ?? rec.latitude ?? rec.lat);
        const lon = parseIncidentCoordinate(rec.Longitude ?? rec.longitude ?? rec.lon);
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
        const received = typeof rec.CallReceivedDateTime === 'string'
          ? rec.CallReceivedDateTime
          : (typeof rec.ReceivedDateTime === 'string' ? rec.ReceivedDateTime : '');
        return `${lat.toFixed(6)}_${lon.toFixed(6)}_${received}`;
      }

      function createIncidentLeafletIcon(iconUrl, width, height) {
        const scale = Number.isFinite(INCIDENT_ICON_SCALE) && INCIDENT_ICON_SCALE > 0
          ? INCIDENT_ICON_SCALE
          : 1;
        const baseWidth = Number.isFinite(width) && width > 0 ? width : FALLBACK_INCIDENT_ICON_SIZE;
        const baseHeight = Number.isFinite(height) && height > 0 ? height : FALLBACK_INCIDENT_ICON_SIZE;
        const scaledWidth = Math.max(1, Math.round(baseWidth * scale));
        const scaledHeight = Math.max(1, Math.round(baseHeight * scale));
        const anchorX = Math.round(scaledWidth / 2);
        const anchorY = scaledHeight;
        return L.icon({
          iconUrl,
          iconSize: [scaledWidth, scaledHeight],
          iconAnchor: [anchorX, anchorY],
          className: 'incident-marker-icon'
        });
      }

      function getIncidentIconEntry(iconUrl) {
        if (!iconUrl) return null;
        let entry = incidentIconCache.get(iconUrl);
        if (!entry) {
          const fallback = FALLBACK_INCIDENT_ICON_SIZE;
          entry = {
            icon: createIncidentLeafletIcon(iconUrl, fallback, fallback),
            markers: new Set(),
            loaded: false
          };
          incidentIconCache.set(iconUrl, entry);
          const img = new Image();
          img.decoding = 'async';
          img.addEventListener('load', () => {
            const width = img.naturalWidth || fallback;
            const height = img.naturalHeight || fallback;
            entry.icon = createIncidentLeafletIcon(iconUrl, width, height);
            entry.loaded = true;
            entry.markers.forEach(marker => {
              if (marker && typeof marker.setIcon === 'function') {
                marker.setIcon(entry.icon);
              }
            });
            applyIncidentHaloStates();
          });
          img.addEventListener('error', () => {
            entry.loaded = true;
          });
          img.src = iconUrl;
        }
        return entry;
      }

      function assignIncidentIcon(marker, iconUrl) {
        if (!marker || !iconUrl) return;
        const entry = getIncidentIconEntry(iconUrl);
        if (!entry) return;
        entry.markers.add(marker);
        marker.setIcon(entry.icon);
      }

      function releaseIncidentIcon(marker, iconUrl) {
        if (!marker || !iconUrl) return;
        const entry = incidentIconCache.get(iconUrl);
        if (entry && entry.markers) {
          entry.markers.delete(marker);
        }
      }

      function getIncidentMarkerIconSize(marker) {
        if (!marker) return null;
        const icon = marker.options && marker.options.icon ? marker.options.icon : null;
        if (!icon || !icon.options) return null;
        const size = icon.options.iconSize;
        if (Array.isArray(size) && size.length >= 2) {
          const width = Number(size[0]);
          const height = Number(size[1]);
          if (Number.isFinite(width) && Number.isFinite(height)) {
            return { width, height };
          }
        }
        return null;
      }

      function getIncidentHaloIcon(markerHeight) {
        const diameter = HALO_MAX_RADIUS_PX * 2;
        const safeHeight = Number.isFinite(markerHeight) && markerHeight > 0
          ? markerHeight
          : DEFAULT_SCALED_INCIDENT_ICON_HEIGHT;
        const key = safeHeight.toFixed(2);
        let icon = incidentHaloIconCache.get(key);
        if (!icon) {
          const offsetX = Number.isFinite(MARKER_CENTROID_OFFSET_X_FACTOR)
            ? MARKER_CENTROID_OFFSET_X_FACTOR * safeHeight
            : 0;
          const offsetY = Number.isFinite(MARKER_CENTROID_OFFSET_Y_FACTOR)
            ? MARKER_CENTROID_OFFSET_Y_FACTOR * safeHeight
            : 0;
          const anchorX = diameter / 2 - offsetX;
          const anchorY = diameter / 2 - offsetY;
          const minScale = HALO_MAX_RADIUS_PX > 0
            ? Math.max(0, Math.min(1, HALO_MIN_RADIUS_PX / HALO_MAX_RADIUS_PX))
            : 0.25;
          const html = `<div class="incident-halo" style="--incident-halo-diameter:${diameter}px;--incident-halo-base-opacity:${HALO_BASE_OPACITY};--incident-halo-duration:${HALO_DURATION_MS}ms;--incident-halo-start-scale:${minScale};--incident-halo-color-rgb:${HALO_COLOR_RGB};"></div>`;
          icon = L.divIcon({
            className: 'incident-halo-icon',
            iconSize: [diameter, diameter],
            iconAnchor: [anchorX, anchorY],
            html
          });
          incidentHaloIconCache.set(key, icon);
        }
        return icon;
      }

      function createIncidentHaloMarker(latLng, markerHeight) {
        const haloIcon = getIncidentHaloIcon(markerHeight);
        return L.marker(latLng, {
          icon: haloIcon,
          pane: 'incidentHalosPane',
          interactive: false,
          keyboard: false,
          bubblingMouseEvents: false
        });
      }

      function ensureIncidentHaloLayerGroup() {
        if (!map) return null;
        if (!incidentHaloLayerGroup) {
          incidentHaloLayerGroup = L.layerGroup();
        }
        const shouldShowHalos = shouldShowIncidentLayer() && hasIncidentsRequiringVisibility();
        if (shouldShowHalos) {
          if (!map.hasLayer(incidentHaloLayerGroup)) {
            incidentHaloLayerGroup.addTo(map);
          }
        } else if (map.hasLayer(incidentHaloLayerGroup)) {
          map.removeLayer(incidentHaloLayerGroup);
        }
        return incidentHaloLayerGroup;
      }

      function isReducedMotionPreferred() {
        return !!(reduceMotionMediaQuery && typeof reduceMotionMediaQuery.matches === 'boolean' && reduceMotionMediaQuery.matches);
      }

      function applyHaloAnimationState(entry, animated) {
        if (!entry || !entry.haloMarker) return;
        const haloMarker = entry.haloMarker;
        const update = () => {
          const element = haloMarker.getElement();
          if (!element) return;
          const haloElement = element.querySelector('.incident-halo');
          if (!haloElement) return;
          if (animated) {
            haloElement.classList.add('incident-halo--animated');
            haloElement.classList.remove('incident-halo--static');
          } else {
            haloElement.classList.add('incident-halo--static');
            haloElement.classList.remove('incident-halo--animated');
          }
        };
        update();
        setTimeout(update, 0);
      }

      function removeIncidentHalo(entry) {
        if (!entry || !entry.haloMarker) return;
        const haloMarker = entry.haloMarker;
        if (incidentHaloLayerGroup && incidentHaloLayerGroup.hasLayer(haloMarker)) {
          incidentHaloLayerGroup.removeLayer(haloMarker);
        } else if (haloMarker && typeof haloMarker.remove === 'function' && haloMarker._map) {
          haloMarker.remove();
        }
        entry.haloMarker = null;
        entry.haloAnimated = false;
      }

      function syncIncidentHaloForEntry(id, entry) {
        if (!entry || !entry.marker) return;
        if (!incidentsNearRoutesLookup.has(id)) {
          removeIncidentHalo(entry);
          return;
        }
        const haloGroup = ensureIncidentHaloLayerGroup();
        if (!haloGroup) return;
        const latLng = entry.marker.getLatLng();
        if (!latLng) return;
        const size = getIncidentMarkerIconSize(entry.marker);
        const markerHeight = size && Number.isFinite(size.height) ? size.height : DEFAULT_SCALED_INCIDENT_ICON_HEIGHT;
        const desiredIcon = getIncidentHaloIcon(markerHeight);
        if (entry.haloMarker) {
          entry.haloMarker.setLatLng(latLng);
          if (entry.haloMarker.options && entry.haloMarker.options.icon !== desiredIcon) {
            entry.haloMarker.setIcon(desiredIcon);
          }
          if (!haloGroup.hasLayer(entry.haloMarker)) {
            haloGroup.addLayer(entry.haloMarker);
          }
        } else {
          const haloMarker = createIncidentHaloMarker(latLng, markerHeight);
          entry.haloMarker = haloMarker;
          haloGroup.addLayer(haloMarker);
        }
      }

      function applyIncidentHaloStates() {
        if (!map) return;
        const haloGroup = ensureIncidentHaloLayerGroup();
        if (!haloGroup) return;
        const nearRouteList = Array.isArray(incidentsNearRoutes) ? incidentsNearRoutes : [];
        const orderedIds = [];
        nearRouteList.forEach(entry => {
          if (!entry) return;
          const candidateId = typeof entry.id === 'string' ? entry.id : getNormalizedIncidentId(entry.id);
          if (candidateId && !orderedIds.includes(candidateId)) {
            orderedIds.push(candidateId);
          }
        });
        const reduceMotion = isReducedMotionPreferred();
        const animatedIds = reduceMotion
          ? new Set()
          : new Set(orderedIds.slice(0, Math.max(0, INCIDENT_HALO_ANIMATED_LIMIT)));
        incidentMarkers.forEach((entry, id) => {
          if (!incidentsNearRoutesLookup.has(id)) {
            removeIncidentHalo(entry);
            return;
          }
          syncIncidentHaloForEntry(id, entry);
          const animate = animatedIds.has(id) && !reduceMotion;
          entry.haloAnimated = animate;
          applyHaloAnimationState(entry, animate);
        });
      }

      if (reduceMotionMediaQuery) {
        const handleReduceMotionChange = () => {
          applyIncidentHaloStates();
        };
        if (typeof reduceMotionMediaQuery.addEventListener === 'function') {
          reduceMotionMediaQuery.addEventListener('change', handleReduceMotionChange);
        } else if (typeof reduceMotionMediaQuery.addListener === 'function') {
          reduceMotionMediaQuery.addListener(handleReduceMotionChange);
        }
      }

      function updateIncidentMarkerTooltip(marker, incident) {
        if (!marker || !incident) return;
        const lines = [];
        const callType = incident.PulsePointIncidentCallType || incident.CallType || incident.Type || '';
        const address = incident.FullDisplayAddress || incident.DisplayAddress || incident.Address || '';
        if (callType) lines.push(callType);
        if (address) {
          if (!lines.length || address.trim().toLowerCase() !== lines[0].trim().toLowerCase()) {
            lines.push(address);
          }
        }
        if (!lines.length) {
          if (typeof marker.unbindTooltip === 'function') {
            marker.unbindTooltip();
          }
          return;
        }
        const tooltipText = lines.join('\n');
        if (typeof marker.getTooltip === 'function') {
          const tooltip = marker.getTooltip();
          if (tooltip && typeof tooltip.setContent === 'function') {
            tooltip.setContent(tooltipText);
            return;
          }
        }
        if (typeof marker.bindTooltip === 'function') {
          marker.bindTooltip(tooltipText, { direction: 'top', offset: [0, -4], sticky: true });
        }
      }

      function updateIncidentsNearRoutes(matches, signature = '') {
        const list = Array.isArray(matches) ? matches.slice() : [];
        incidentsNearRoutes = list;
        const lookup = new Map();
        list.forEach(entry => {
          if (!entry) return;
          const candidateId = typeof entry.id === 'string' ? entry.id : getNormalizedIncidentId(entry.id);
          if (candidateId) {
            lookup.set(candidateId, entry);
          }
        });
        incidentsNearRoutesLookup = lookup;
        incidentRouteAlertSignature = typeof signature === 'string' ? signature : '';
        applyIncidentHaloStates();
        refreshOpenIncidentPopups();
        maintainIncidentLayers();
      }

      function applyIncidentMarkers(incidents) {
        if (!map) return;
        if (!incidentLayerGroup) {
          incidentLayerGroup = L.layerGroup();
        }
        const layerGroup = incidentLayerGroup;
        const shouldShowLayer = shouldShowIncidentLayer();
        if (shouldShowLayer) {
          if (!map.hasLayer(layerGroup)) {
            layerGroup.addTo(map);
          }
        } else if (map.hasLayer(layerGroup)) {
          map.removeLayer(layerGroup);
        }
        const activeIds = new Set();
        (Array.isArray(incidents) ? incidents : []).forEach(incident => {
          if (!incident) return;
          const lat = parseIncidentCoordinate(incident.Latitude ?? incident.latitude ?? incident.lat);
          const lon = parseIncidentCoordinate(incident.Longitude ?? incident.longitude ?? incident.lon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
          const fallbackId = getNormalizedIncidentId(`${lat.toFixed(6)}_${lon.toFixed(6)}`);
          let id = getNormalizedIncidentId(getIncidentIdentifier(incident));
          if (!id) {
            id = fallbackId;
          }
          if (!id) return;
          const markerUrl = incident._markerUrl;
          if (!markerUrl) return;
          const isPinned = incidentsNearRoutesLookup.has(id);
          if (!incidentsVisible) {
            if (!shouldShowLayer || !isPinned) {
              return;
            }
          }
          activeIds.add(id);
          const existing = incidentMarkers.get(id);
          if (existing && existing.marker) {
            existing.marker.setLatLng([lat, lon]);
            if (existing.iconUrl !== markerUrl) {
              releaseIncidentIcon(existing.marker, existing.iconUrl);
              assignIncidentIcon(existing.marker, markerUrl);
              existing.iconUrl = markerUrl;
            }
            updateIncidentMarkerTooltip(existing.marker, incident);
            existing.data = incident;
            refreshIncidentPopup(id);
          } else {
            const marker = L.marker([lat, lon], {
              pane: 'incidentsPane',
              keyboard: false,
              zIndexOffset: 200
            });
            assignIncidentIcon(marker, markerUrl);
            updateIncidentMarkerTooltip(marker, incident);
            marker.addTo(layerGroup);
            incidentMarkers.set(id, {
              marker,
              data: incident,
              iconUrl: markerUrl,
              haloMarker: null,
              haloAnimated: false
            });
            marker.on('click', () => {
              const config = buildIncidentPopupConfig(id);
              if (config) {
                createCustomPopup(config);
              }
            });
            refreshIncidentPopup(id);
          }
        });
        const idsToRemove = [];
        incidentMarkers.forEach((entry, id) => {
          if (!activeIds.has(id)) {
            idsToRemove.push(id);
          }
        });
        idsToRemove.forEach(id => {
          const entry = incidentMarkers.get(id);
          if (!entry) return;
          releaseIncidentIcon(entry.marker, entry.iconUrl);
          if (incidentLayerGroup && entry.marker) {
            incidentLayerGroup.removeLayer(entry.marker);
          } else if (map && entry.marker && map.hasLayer(entry.marker)) {
            map.removeLayer(entry.marker);
          }
          removeIncidentHalo(entry);
          removeIncidentPopupById(id);
          incidentMarkers.delete(id);
        });
        applyIncidentHaloStates();
        maintainIncidentLayers();
      }

      function ensureRouteProjectedPath(entry) {
        if (!entry) return null;
        const latLngPath = Array.isArray(entry.latLngPath) ? entry.latLngPath : null;
        if (!latLngPath || latLngPath.length < 2) return null;
        const existing = Array.isArray(entry.projectedPath) ? entry.projectedPath : null;
        if (existing && existing.length === latLngPath.length && existing.length >= 2) {
          return existing;
        }
        if (typeof L === 'undefined' || !L.Projection || !L.Projection.SphericalMercator) return null;
        entry.projectedPath = latLngPath.map(point => L.Projection.SphericalMercator.project(point));
        return entry.projectedPath;
      }

      function computeDistanceFromProjectedPointToSegmentMeters(point, a, b) {
        if (!point || !a || !b) return Infinity;
        const ax = a.x;
        const ay = a.y;
        const bx = b.x;
        const by = b.y;
        if (!Number.isFinite(ax) || !Number.isFinite(ay) || !Number.isFinite(bx) || !Number.isFinite(by)) {
          return Infinity;
        }
        const dx = bx - ax;
        const dy = by - ay;
        if (dx === 0 && dy === 0) {
          const diffX = point.x - ax;
          const diffY = point.y - ay;
          return Math.sqrt(diffX * diffX + diffY * diffY);
        }
        const t = ((point.x - ax) * dx + (point.y - ay) * dy) / (dx * dx + dy * dy);
        const clamped = Math.max(0, Math.min(1, t));
        const projX = ax + clamped * dx;
        const projY = ay + clamped * dy;
        const diffX = point.x - projX;
        const diffY = point.y - projY;
        return Math.sqrt(diffX * diffX + diffY * diffY);
      }

      function computeDistanceFromProjectedPointToPathMeters(point, projectedPath) {
        if (!point || !Array.isArray(projectedPath) || projectedPath.length < 2) {
          return Infinity;
        }
        let minDistance = Infinity;
        for (let i = 0; i < projectedPath.length - 1; i += 1) {
          const segmentStart = projectedPath[i];
          const segmentEnd = projectedPath[i + 1];
          const distance = computeDistanceFromProjectedPointToSegmentMeters(point, segmentStart, segmentEnd);
          if (!Number.isFinite(distance)) continue;
          if (distance < minDistance) {
            minDistance = distance;
          }
        }
        return minDistance;
      }

      function getRouteDisplayName(routeId) {
        const numericRouteId = Number(routeId);
        const candidates = [];
        if (Number.isFinite(numericRouteId) && allRoutes && allRoutes[numericRouteId]) {
          candidates.push(allRoutes[numericRouteId]);
        }
        if (allRoutes && Object.prototype.hasOwnProperty.call(allRoutes, routeId)) {
          candidates.push(allRoutes[routeId]);
        }
        const record = candidates.find(Boolean) || null;
        if (record) {
          const nameCandidates = [
            record.Description,
            record.RouteName,
            record.Name,
            record.LongName,
            record.ShortName
          ];
          const name = nameCandidates.find(value => typeof value === 'string' && value.trim());
          if (name) return name.trim();
        }
        if (Number.isFinite(numericRouteId)) {
          return `Route ${numericRouteId}`;
        }
        if (typeof routeId === 'string' && routeId.trim()) {
          return routeId.trim();
        }
        return 'Route';
      }

      function evaluateIncidentRouteAlerts() {
        if (demoIncidentActive && demoIncidentEntry) {
          return;
        }
        const hadAlerts = incidentRouteAlertSignature !== '' || (Array.isArray(incidentsNearRoutes) && incidentsNearRoutes.length > 0);
        if (!incidentsAreAvailable()) {
          if (hadAlerts) {
            resetIncidentAlertState();
            updateControlPanel();
          } else {
            resetIncidentAlertState();
          }
          return;
        }
        if (typeof L === 'undefined' || !L.Projection || !L.Projection.SphericalMercator) {
          return;
        }
        const activeRecords = Array.isArray(latestActiveIncidents) ? latestActiveIncidents : [];
        if (activeRecords.length === 0) {
          if (hadAlerts) {
            resetIncidentAlertState();
            updateControlPanel();
          } else {
            resetIncidentAlertState();
          }
          return;
        }
        const routeEntries = [];
        routePolylineCache.forEach((entry, key) => {
          const numericRouteId = Number(key);
          if (!Number.isFinite(numericRouteId) || numericRouteId === 0) return;
          const projectedPath = ensureRouteProjectedPath(entry);
          if (!projectedPath || projectedPath.length < 2) return;
          routeEntries.push({ routeId: numericRouteId, projectedPath });
        });
        if (routeEntries.length === 0) {
          if (hadAlerts) {
            resetIncidentAlertState();
            updateControlPanel();
          }
          return;
        }
        const projection = L.Projection.SphericalMercator;
        const threshold = Number.isFinite(INCIDENT_ROUTE_PROXIMITY_THRESHOLD_METERS) && INCIDENT_ROUTE_PROXIMITY_THRESHOLD_METERS >= 0
          ? INCIDENT_ROUTE_PROXIMITY_THRESHOLD_METERS
          : 0;
        const matches = [];
        activeRecords.forEach(incident => {
          const lat = parseIncidentCoordinate(incident?.Latitude ?? incident?.latitude ?? incident?.lat);
          const lon = parseIncidentCoordinate(incident?.Longitude ?? incident?.longitude ?? incident?.lon);
          if (!Number.isFinite(lat) || !Number.isFinite(lon)) return;
          const incidentLatLng = L.latLng(lat, lon);
          const projectedPoint = projection.project(incidentLatLng);
          if (!projectedPoint) return;
          const matchedRoutes = [];
          const seenRoutes = new Set();
          let closestDistance = Infinity;
          routeEntries.forEach(({ routeId, projectedPath }) => {
            const distance = computeDistanceFromProjectedPointToPathMeters(projectedPoint, projectedPath);
            if (!Number.isFinite(distance)) return;
            if (distance < closestDistance) {
              closestDistance = distance;
            }
            if (distance <= threshold && !seenRoutes.has(routeId)) {
              seenRoutes.add(routeId);
              const colorCandidates = [];
              if (routeColors && typeof routeColors[routeId] === 'string') {
                colorCandidates.push(routeColors[routeId]);
              }
              const storedRoute = allRoutes ? (allRoutes[routeId] || allRoutes[`${routeId}`] || null) : null;
              if (storedRoute) {
                const storedColorCandidates = [storedRoute.MapLineColor, storedRoute.RouteColor, storedRoute.Color, storedRoute.color];
                storedColorCandidates.forEach(value => {
                  if (typeof value === 'string') {
                    colorCandidates.push(value);
                  }
                });
              }
              let matchedColor = '';
              for (const candidate of colorCandidates) {
                const sanitized = sanitizeCssColor(candidate);
                if (sanitized) {
                  matchedColor = sanitized;
                  break;
                }
              }
              matchedRoutes.push({ routeId, name: getRouteDisplayName(routeId), distance, color: matchedColor });
            }
          });
          if (!matchedRoutes.length) return;
          matchedRoutes.sort((a, b) => (a.distance || 0) - (b.distance || 0));
          let id = getIncidentIdentifier(incident);
          if (!id) {
            id = `${lat.toFixed(6)}_${lon.toFixed(6)}`;
          }
          id = getNormalizedIncidentId(id);
          if (!id) return;
          const timestamp = getIncidentTimestamp(incident) ?? 0;
          matches.push({
            id,
            incident,
            routes: matchedRoutes,
            closestDistance,
            timestamp
          });
        });
        if (!matches.length) {
          if (hadAlerts) {
            resetIncidentAlertState();
            updateControlPanel();
          }
          return;
        }
        matches.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
        const signature = matches.map(match => {
          const routePart = match.routes.map(route => route.routeId).join(',');
          const distancePart = Number.isFinite(match.closestDistance) ? Math.round(match.closestDistance) : 'x';
          return `${match.id || ''}:${routePart}:${distancePart}`;
        }).join('|');
        if (signature !== incidentRouteAlertSignature) {
          updateIncidentsNearRoutes(matches, signature);
          updateControlPanel();
        }
      }

      async function refreshIncidents() {
        if (!incidentsAreAvailable()) {
          setIncidentsVisibility(false);
          return;
        }
        if (demoIncidentActive && demoIncidentEntry) {
          return;
        }
        if (!map || isFetchingIncidents) return;
        isFetchingIncidents = true;
        try {
          const records = await fetchPulsePointIncidents();
          const activeRecords = Array.isArray(records)
            ? records.filter(record => (record._category || '').toLowerCase() === 'active')
            : [];
          latestActiveIncidents = activeRecords;
          evaluateIncidentRouteAlerts();
          applyIncidentMarkers(activeRecords);
        } catch (error) {
          console.error('Failed to refresh PulsePoint incidents', error);
        } finally {
          isFetchingIncidents = false;
        }
      }

      function setIncidentsVisibility(visible) {
        const allowIncidents = incidentsAreAvailable();
        const hadAlerts = incidentRouteAlertSignature !== '' || (Array.isArray(incidentsNearRoutes) && incidentsNearRoutes.length > 0);
        incidentsVisible = allowIncidents && !!visible;

        if (!incidentsVisible && demoIncidentActive) {
          deactivateDemoIncidentPreview({ preserveVisibility: true });
        }

        if (!allowIncidents) {
          if (hadAlerts || (Array.isArray(latestActiveIncidents) && latestActiveIncidents.length > 0)) {
            resetIncidentAlertState();
            updateControlPanel();
          } else {
            resetIncidentAlertState();
          }
          removeAllIncidentPopups();
          maintainIncidentLayers();
          updateIncidentToggleButton();
          return;
        }

        incidentsVisibilityPreference = incidentsVisible;

        applyIncidentMarkers(latestActiveIncidents);
        if (incidentsVisible && incidentMarkers.size === 0 && !isFetchingIncidents) {
          refreshIncidents();
        } else {
          maintainIncidentLayers();
        }
        updateIncidentToggleButton();
        applyIncidentHaloStates();
        if (!incidentsVisible) {
          removeAllIncidentPopups();
        }
      }

      async function activateDemoIncidentPreview() {
        if (demoIncidentActive) return;
        const row = await ensureDemoIncidentRow();
        if (!row) {
          if (typeof window !== 'undefined' && typeof window.alert === 'function') {
            window.alert('Demo incident data is unavailable.');
          }
          return;
        }
        const entry = createDemoIncidentEntry();
        if (!entry || !entry.incident) {
          console.warn('Demo incident data is missing required fields.', entry);
          if (typeof window !== 'undefined' && typeof window.alert === 'function') {
            window.alert('Demo incident data is missing required fields.');
          }
          return;
        }
        demoIncidentEntry = entry;
        demoIncidentPreviousVisibility = incidentsVisible;
        demoIncidentActive = true;
        updateIncidentsNearRoutes([entry], entry._demoSignature || entry.id || 'demo');
        incidentsVisible = true;
        incidentsVisibilityPreference = true;
        if (!incidentLayerGroup && typeof L !== 'undefined' && typeof L.layerGroup === 'function') {
          incidentLayerGroup = L.layerGroup();
        }
        if (map && incidentLayerGroup && typeof incidentLayerGroup.addTo === 'function') {
          incidentLayerGroup.addTo(map);
        }
        if (entry.incident) {
          applyIncidentMarkers([entry.incident]);
        }
        if (entry.incident && Number.isFinite(entry.incident.Latitude) && Number.isFinite(entry.incident.Longitude) && map && typeof map.setView === 'function') {
          try {
            const currentZoom = typeof map.getZoom === 'function' ? map.getZoom() : 0;
            const targetZoom = Number.isFinite(currentZoom) ? Math.max(currentZoom, 15) : 15;
            map.setView([entry.incident.Latitude, entry.incident.Longitude], targetZoom, { animate: true });
          } catch (error) {
            console.warn('Unable to move map to the demo incident location.', error);
          }
        }
        updateControlPanel();
        updateIncidentToggleButton();
      }

      function deactivateDemoIncidentPreview(options = {}) {
        if (!demoIncidentActive) {
          demoIncidentPreviousVisibility = null;
          return;
        }
        const preserveVisibility = options && options.preserveVisibility;
        demoIncidentActive = false;
        demoIncidentEntry = null;
        resetIncidentAlertState();
        applyIncidentMarkers([]);
        if (!preserveVisibility) {
          if (demoIncidentPreviousVisibility !== null) {
            incidentsVisible = !!demoIncidentPreviousVisibility;
            incidentsVisibilityPreference = incidentsVisible;
            if (map && incidentLayerGroup) {
              if (incidentsVisible) {
                incidentLayerGroup.addTo(map);
              } else {
                map.removeLayer(incidentLayerGroup);
              }
            }
          }
        }
        demoIncidentPreviousVisibility = null;
        updateControlPanel();
        updateIncidentToggleButton();
      }

      async function toggleDemoIncident() {
        if (demoIncidentActive) {
          deactivateDemoIncidentPreview();
        } else {
          await activateDemoIncidentPreview();
        }
      }

      function enforceIncidentVisibilityForCurrentAgency() {
        if (incidentsAreAvailable()) {
          setIncidentsVisibility(incidentsVisibilityPreference);
        } else {
          setIncidentsVisibility(false);
        }
      }

      function toggleIncidentsVisibility() {
        if (!incidentsAreAvailable()) return;
        setIncidentsVisibility(!incidentsVisible);
      }

      const BUS_MARKER_SVG_URL = 'busmarker.svg';

      const BUS_MARKER_VIEWBOX_WIDTH = 52.99;
      const BUS_MARKER_VIEWBOX_HEIGHT = 86.99;
      const BUS_MARKER_PIVOT_X = BUS_MARKER_VIEWBOX_WIDTH / 2;
      const BUS_MARKER_PIVOT_Y = BUS_MARKER_VIEWBOX_HEIGHT / 2;
      const BUS_MARKER_ASPECT_RATIO = BUS_MARKER_VIEWBOX_HEIGHT / BUS_MARKER_VIEWBOX_WIDTH;
      const BUS_MARKER_BASE_WIDTH_PX = 26;
      const BUS_MARKER_MIN_WIDTH_PX = 18;
      const BUS_MARKER_MAX_WIDTH_PX = 48;
      const BUS_MARKER_BASE_ZOOM = 15;
      const BUS_MARKER_MIN_SCALE = BUS_MARKER_MIN_WIDTH_PX / BUS_MARKER_BASE_WIDTH_PX;
      const BUS_MARKER_MAX_SCALE = BUS_MARKER_MAX_WIDTH_PX / BUS_MARKER_BASE_WIDTH_PX;
      const BUS_MARKER_SCALE_ZOOM_FACTOR = 5;
      const BUS_MARKER_ICON_ANCHOR_X_RATIO = BUS_MARKER_PIVOT_X / BUS_MARKER_VIEWBOX_WIDTH;
      const BUS_MARKER_ICON_ANCHOR_Y_RATIO = BUS_MARKER_PIVOT_Y / BUS_MARKER_VIEWBOX_HEIGHT;
      const BUS_MARKER_TRANSFORM_ORIGIN = '50% 50%';
      const BUS_MARKER_DEFAULT_HEADING = 0;
      const BUS_MARKER_DEFAULT_ROUTE_COLOR = '#0B7A26';
      const BUS_MARKER_DEFAULT_CONTRAST_COLOR = '#FFFFFF';
      const BUS_MARKER_CENTER_RING_CENTER_X = 26.5;
      const BUS_MARKER_CENTER_RING_CENTER_Y = 43.49;
      const BUS_MARKER_STOPPED_SQUARE_SIZE_PX = 20;
      const BUS_MARKER_STOPPED_SQUARE_ID = 'center_square';
      const BUS_MARKER_CENTER_RING_ID = 'center_ring';
      let BUS_MARKER_SVG_TEXT = null;
      let BUS_MARKER_SVG_LOAD_PROMISE = null;
      let busMarkerVisibleExtents = null;
      const BUS_MARKER_LABEL_FONT_FAMILY = 'FGDC, sans-serif';
      const BUS_MARKER_LABEL_MIN_FONT_PX = 10;
      const SPEED_BUBBLE_BASE_FONT_PX = 12;
      const SPEED_BUBBLE_HORIZONTAL_PADDING = 12;
      const SPEED_BUBBLE_VERTICAL_PADDING = 4;
      const SPEED_BUBBLE_MIN_WIDTH = 60;
      const SPEED_BUBBLE_MIN_HEIGHT = 20;
      const SPEED_BUBBLE_CORNER_RADIUS = 10;
      const LABEL_VERTICAL_CLEARANCE_PX = -7; // pull labels ~7px closer to the vehicle while relying on the half-diagonal for rotation safety
      const LABEL_VERTICAL_ALIGNMENT_BONUS_PX = 6; // push labels a little farther away when the vehicle is nearly north/south
      const LABEL_VERTICAL_ALIGNMENT_EXPONENT = 4; // emphasize the bonus for headings close to due north/south
      const LABEL_HORIZONTAL_ALIGNMENT_BONUS_PX = 1; // give east/west headings extra breathing room
      const LABEL_TEXT_VERTICAL_ADJUSTMENT_RATIO = 0.06;
      const NAME_BUBBLE_BASE_FONT_PX = 14;
      const NAME_BUBBLE_HORIZONTAL_PADDING = 14;
      const NAME_BUBBLE_VERTICAL_PADDING = 3;
      const NAME_BUBBLE_MIN_WIDTH = 40;
      const NAME_BUBBLE_MIN_HEIGHT = 20;
      const NAME_BUBBLE_CORNER_RADIUS = 10;
      const NAME_BUBBLE_FRAME_INSET = 5;
      const BLOCK_BUBBLE_BASE_FONT_PX = 14;
      const BLOCK_BUBBLE_HORIZONTAL_PADDING = 14;
      const BLOCK_BUBBLE_VERTICAL_PADDING = 3;
      const BLOCK_BUBBLE_MIN_WIDTH = 40;
      const BLOCK_BUBBLE_MIN_HEIGHT = 20;
      const BLOCK_BUBBLE_CORNER_RADIUS = 10;
      const BLOCK_BUBBLE_FRAME_INSET = 5;
      const LABEL_BASE_STROKE_WIDTH = 3;
      const MIN_HEADING_DISTANCE_METERS = 2;
      const MIN_POSITION_UPDATE_METERS = 0.5;
      const MIN_HEADING_SPEED_METERS_PER_SECOND = 1;
      const METERS_PER_SECOND_PER_MPH = 0.44704;
      const GPS_STALE_THRESHOLD_SECONDS = 60;
      let busMarkerContrastOverrideColor = null;

      let routeColors = {};
      let routeLayers = [];
      let stopMarkers = [];
      let stopDataCache = [];
      let routeStopAddressMap = {};
      let routeStopRouteMap = {};
      let nameBubbles = {};
      let busBlocks = {};
      let previousBusData = {};
      let cachedEtas = {};
      let customPopups = [];
      let allRouteBounds = null;
      let mapHasFitAllRoutes = false;
      let refreshIntervals = [];

      let overlapRenderer = null;

      let activeAgencyLoadCount = 0;

      function showLoadingOverlay() {
        const overlay = document.getElementById('loadingOverlay');
        if (!overlay) return;
        overlay.classList.add('is-visible');
        overlay.setAttribute('aria-busy', 'true');
      }

      function hideLoadingOverlay() {
        const overlay = document.getElementById('loadingOverlay');
        if (!overlay) return;
        overlay.classList.remove('is-visible');
        overlay.setAttribute('aria-busy', 'false');
      }

      function beginAgencyLoad() {
        activeAgencyLoadCount += 1;
        showLoadingOverlay();
      }

      function completeAgencyLoad() {
        activeAgencyLoadCount = Math.max(0, activeAgencyLoadCount - 1);
        if (activeAgencyLoadCount === 0) {
          hideLoadingOverlay();
        }
      }

      const STOP_GROUPING_PIXEL_DISTANCE = 20;
      const STOP_MARKER_ICON_SIZE = 24;
      const STOP_MARKER_BORDER_COLOR = 'rgba(15,23,42,0.55)';
      const STOP_MARKER_OUTLINE_COLOR = '#FFFFFF';
      const STOP_MARKER_OUTLINE_WIDTH = 2;

      let routePolylineCache = new Map();
      let lastRouteRenderState = {
        selectionKey: '',
        colorSignature: '',
        geometrySignature: '',
        useOverlapRenderer: false
      };
      let lastRouteSelectorSignature = null;

      const DEFAULT_ROUTE_STROKE_WEIGHT = 6;
      const MIN_ROUTE_STROKE_WEIGHT = 3;
      const MAX_ROUTE_STROKE_WEIGHT = 12;
      const ROUTE_WEIGHT_ZOOM_DELTA_LIMIT = 3;
      const ROUTE_WEIGHT_BASE_ZOOM = 15;
      const ROUTE_WEIGHT_STEP_PER_ZOOM = 1;

      function computeRouteStrokeWeight(zoom) {
        const baseWeight = DEFAULT_ROUTE_STROKE_WEIGHT;
        const minWeight = MIN_ROUTE_STROKE_WEIGHT;
        const maxWeight = MAX_ROUTE_STROKE_WEIGHT;
        const targetZoom = Number.isFinite(zoom)
          ? zoom
          : (map && typeof map?.getZoom === 'function' ? map.getZoom() : null);
        if (!Number.isFinite(targetZoom)) {
          return Math.max(minWeight, Math.min(maxWeight, baseWeight));
        }
        const zoomDeltaRaw = targetZoom - ROUTE_WEIGHT_BASE_ZOOM;
        const limitedDelta = Math.max(-ROUTE_WEIGHT_ZOOM_DELTA_LIMIT, Math.min(ROUTE_WEIGHT_ZOOM_DELTA_LIMIT, zoomDeltaRaw));
        const computed = baseWeight + ROUTE_WEIGHT_STEP_PER_ZOOM * limitedDelta;
        if (!Number.isFinite(computed)) {
          return Math.max(minWeight, Math.min(maxWeight, baseWeight));
        }
        return Math.max(minWeight, Math.min(maxWeight, computed));
      }

      async function loadAgencies() {
        try {
          const response = await fetch('https://admin.ridesystems.net/api/Clients/GetClients');
          const contentType = response.headers.get('content-type') || '';
          let clients = [];
          if (contentType.includes('application/json')) {
            clients = await response.json();
          } else {
            const text = await response.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'application/xml');
            clients = Array.from(xml.getElementsByTagName('Client')).map(c => ({
              Name: c.getElementsByTagName('Name')[0]?.textContent.trim(),
              WebAddress: c.getElementsByTagName('WebAddress')[0]?.textContent.trim()
            }));
          }
          agencies = clients.map(c => {
            const name = c.Name?.trim();
            const webAddress = c.WebAddress?.trim();
            if (!name || !webAddress) return null;
            const url = webAddress.startsWith('http')
              ? webAddress.replace(/^http:\/\//i, 'https://')
              : `https://${webAddress}`;
            return { name, url, type: AGENCY_TYPE_RIDESYSTEMS };
          }).filter(Boolean);
          agencies.sort((a, b) => a.name.localeCompare(b.name));
          const uvaIndex = agencies.findIndex(a => a.name === 'University of Virginia');
          let uvaAgency = null;
          if (uvaIndex > -1) {
            uvaAgency = agencies.splice(uvaIndex, 1)[0];
          }
          if (uvaAgency) {
            agencies.unshift(uvaAgency);
          }
          const catAgency = {
            name: 'Charlottesville Area Transit',
            url: 'https://catpublic.etaspot.net',
            serviceUrl: 'https://catpublic.etaspot.net/service.php',
            token: ETASPOT_DEFAULT_TOKEN,
            type: AGENCY_TYPE_ETASPOT
          };
          const hasCatAgency = agencies.some(agency => agency && agency.url === catAgency.url);
          if (!hasCatAgency) {
            if (uvaAgency) {
              agencies.splice(1, 0, catAgency);
            } else {
              agencies.unshift(catAgency);
            }
          }
          const consent = localStorage.getItem('agencyConsent') === 'true';
          const storedAgency = consent ? localStorage.getItem('selectedAgency') : null;
          if (storedAgency && agencies.some(a => a.url === storedAgency)) {
            baseURL = storedAgency;
          } else {
            baseURL = agencies[0]?.url || '';
          }
          setCurrentAgencyByUrl(baseURL);
          resetServiceAlertsState();
          updateControlPanel();
          enforceIncidentVisibilityForCurrentAgency();
          updateRouteSelector(activeRoutes, true);
          fetchServiceAlerts();
        } catch (e) {
          console.error('Failed to load agencies', e);
        }
      }

      function positionPanelTab(panelId, tabId, side = 'right') {
        const panel = document.getElementById(panelId);
        const tab = document.getElementById(tabId);
        if (!panel || !tab) return;

        const panelRect = panel.getBoundingClientRect();
        const tabRect = tab.getBoundingClientRect();
        const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
        const tabHeight = tabRect.height || tab.offsetHeight || parseFloat(window.getComputedStyle(tab).height) || 0;
        if (Number.isFinite(panelRect?.top) && Number.isFinite(panelRect?.height)) {
          const panelCenter = panelRect.top + panelRect.height / 2;
          if (Number.isFinite(panelCenter)) {
            const halfTab = Number.isFinite(tabHeight) ? tabHeight / 2 : 0;
            let targetTop = panelCenter;
            if (Number.isFinite(viewportHeight) && halfTab > 0) {
              const minTop = halfTab + 8;
              const maxTop = viewportHeight - halfTab - 8;
              if (Number.isFinite(minTop) && Number.isFinite(maxTop)) {
                targetTop = Math.min(Math.max(panelCenter, minTop), Math.max(minTop, maxTop));
              }
            }
            if (Number.isFinite(targetTop)) {
              tab.style.top = `${targetTop}px`;
            }
          }
        }

        const panelStyle = window.getComputedStyle(panel);
        const gap = side === 'right'
          ? (parseFloat(panelStyle.right) || 0)
          : (parseFloat(panelStyle.left) || 0);
        const offset = panel.offsetWidth + gap;
        const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
        const tabWidth = tabRect.width || tab.offsetWidth || parseFloat(window.getComputedStyle(tab).width) || 0;

        if (side === 'right') {
          if (panel.classList.contains('hidden')) {
            tab.style.right = '0';
          } else {
            const maxRight = Math.max(0, viewportWidth - tabWidth);
            const clampedOffset = Math.min(offset, maxRight);
            tab.style.right = `${clampedOffset}px`;
          }
          tab.style.left = '';
        } else {
          if (panel.classList.contains('hidden')) {
            tab.style.left = '0';
          } else {
            const maxLeft = Math.max(0, viewportWidth - tabWidth);
            const clampedOffset = Math.min(offset, maxLeft);
            tab.style.left = `${clampedOffset}px`;
          }
          tab.style.right = '';
        }
      }

      function isCompactViewport() {
        const width = window.innerWidth || document.documentElement?.clientWidth || document.body?.clientWidth || 0;
        const height = window.innerHeight || document.documentElement?.clientHeight || document.body?.clientHeight || 0;
        const dimensionCandidates = [width, height].filter(value => Number.isFinite(value) && value > 0);
        const smallestDimension = dimensionCandidates.length > 0 ? Math.min(...dimensionCandidates) : width;
        return Number.isFinite(smallestDimension) && smallestDimension <= PANEL_COLLAPSE_BREAKPOINT;
      }

      function isPanelVisibleForMobileBehavior(panel) {
        if (!panel) return false;
        if (panel.classList && panel.classList.contains('hidden')) return false;
        if (panel.style && panel.style.display === 'none') return false;
        if (typeof window.getComputedStyle === 'function') {
          const computed = window.getComputedStyle(panel);
          if (computed && computed.display === 'none') {
            return false;
          }
        }
        return true;
      }

      function updatePanelTabVisibility() {
        const controlTab = document.getElementById('controlPanelTab');
        const routeTab = document.getElementById('routeSelectorTab');

        if (!controlTab || !routeTab) return;

        if (!isCompactViewport()) {
          controlTab.classList.remove('is-hidden-mobile');
          routeTab.classList.remove('is-hidden-mobile');
          return;
        }

        const controlPanel = document.getElementById('controlPanel');
        const routePanel = document.getElementById('routeSelector');

        const controlVisible = isPanelVisibleForMobileBehavior(controlPanel);
        const routeVisible = isPanelVisibleForMobileBehavior(routePanel);

        if (controlVisible && !routeVisible) {
          routeTab.classList.add('is-hidden-mobile');
          controlTab.classList.remove('is-hidden-mobile');
        } else if (routeVisible && !controlVisible) {
          controlTab.classList.add('is-hidden-mobile');
          routeTab.classList.remove('is-hidden-mobile');
        } else {
          controlTab.classList.remove('is-hidden-mobile');
          routeTab.classList.remove('is-hidden-mobile');
        }
      }

      function positionAllPanelTabs() {
        positionPanelTab('routeSelector', 'routeSelectorTab', 'right');
        positionPanelTab('controlPanel', 'controlPanelTab', 'left');
        updatePanelTabVisibility();
        syncServiceAlertsBadge();
      }

      window.addEventListener("load", positionAllPanelTabs);
      window.addEventListener("resize", positionAllPanelTabs);

      // Global storage for routes from GetRoutes.
      let allRoutes = {};
      // Global object to store user selections (for admin mode).
      let routeSelections = {};
      // Tracks routes that currently have at least one vehicle assigned.
      let activeRoutes = new Set();
      // Tracks which routes the API designates as public-facing.
      let routeVisibility = {};

      // Routes default to visible if they currently have vehicles unless the user
      // overrides the selection via the route selector.
      function isRouteSelected(routeID) {
        if (!canDisplayRoute(routeID)) return false;
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (routeSelections.hasOwnProperty(id)) return routeSelections[id];
        return activeRoutes.has(id);
      }

      function normalizeRouteIdForComparison(routeId) {
        if (routeId === undefined || routeId === null) return null;
        const numericId = Number(routeId);
        if (Number.isFinite(numericId)) {
          return `${numericId}`;
        }
        if (typeof routeId === 'string') {
          const trimmed = routeId.trim().toLowerCase();
          return trimmed !== '' ? trimmed : null;
        }
        const stringValue = String(routeId).trim().toLowerCase();
        return stringValue !== '' ? stringValue : null;
      }

      function routeHasActiveVehicles(routeId) {
        const normalizedRouteId = normalizeRouteIdForComparison(routeId);
        if (!normalizedRouteId) return false;
        let activeValues = [];
        if (activeRoutes instanceof Set) {
          activeValues = Array.from(activeRoutes);
        } else if (Array.isArray(activeRoutes)) {
          activeValues = activeRoutes.slice();
        } else {
          return false;
        }
        return activeValues.some(activeRouteId => {
          const normalizedActive = normalizeRouteIdForComparison(activeRouteId);
          return normalizedActive !== null && normalizedActive === normalizedRouteId;
        });
      }

      function setRouteVisibility(route) {
        if (!route || typeof route.RouteID === 'undefined') return;
        const id = Number(route.RouteID);
        if (Number.isNaN(id)) return;
        routeVisibility[id] = route.IsVisibleOnMap !== false;
      }

      function isRoutePublicById(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id) || id === 0) return false;
        if (Object.prototype.hasOwnProperty.call(routeVisibility, id)) {
          return routeVisibility[id];
        }
        return true;
      }

      function canDisplayRoute(routeID) {
        const id = Number(routeID);
        if (Number.isNaN(id)) return false;
        if (id === 0) {
          return adminKioskMode || (!kioskMode && adminMode);
        }
        if (adminKioskMode) return true;
        if (kioskMode) return isRoutePublicById(id);
        if (adminMode) return true;
        return isRoutePublicById(id);
      }

      function setDisplayMode(mode) {
        const normalizedMode = typeof mode === 'string' ? mode.toLowerCase() : '';
        const validModes = Object.values(DISPLAY_MODES);
        if (!validModes.includes(normalizedMode)) return;
        const modeChanged = displayMode !== normalizedMode;
        displayMode = normalizedMode;
        updateDisplayModeButtons();
        if (modeChanged) {
          updateDisplayModeOverlays();
          refreshMap();
        }
      }

      function updateDisplayModeButtons() {
        const buttonContainer = document.getElementById('displayModeButtons');
        if (!buttonContainer) return;
        const buttons = buttonContainer.querySelectorAll('button[data-mode]');
        buttons.forEach(button => {
          const buttonMode = (button.dataset.mode || '').toLowerCase();
          const isActive = buttonMode === displayMode;
          button.classList.toggle('is-active', isActive);
        });
      }

      function updateIncidentToggleButton() {
        const button = document.getElementById('incidentToggleButton');
        if (!button) return;
        const isActive = !!incidentsVisible;
        button.classList.toggle('is-active', isActive);
        button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        const indicator = button.querySelector('.toggle-indicator');
        if (indicator) {
          indicator.textContent = isActive ? 'On' : 'Off';
        }
      }

      function updateDisplayModeOverlays() {
        if (!map || typeof map.removeLayer !== 'function') return;
        Object.keys(nameBubbles).forEach(vehicleID => {
          const bubble = nameBubbles[vehicleID];
          if (!bubble) return;
          if (bubble.speedMarker && displayMode !== DISPLAY_MODES.SPEED) {
            map.removeLayer(bubble.speedMarker);
            delete bubble.speedMarker;
          }
          if (bubble.blockMarker && displayMode !== DISPLAY_MODES.BLOCK) {
            map.removeLayer(bubble.blockMarker);
            delete bubble.blockMarker;
          }
        });
      }

      function applyRouteOptionState(inputElement) {
        if (!inputElement || typeof inputElement.closest !== 'function') return;
        const parentLabel = inputElement.closest('label.route-option');
        if (!parentLabel) return;
        if (inputElement.checked) {
          parentLabel.classList.add('is-active');
        } else {
          parentLabel.classList.remove('is-active');
        }
      }

      function renderIncidentUnit(unit) {
        if (!unit) return '';
        const text = typeof unit.displayText === 'string' ? unit.displayText.trim() : '';
        if (!text) return '';
        const classes = ['incident-unit'];
        if (unit.statusKey) {
          classes.push(`incident-unit--${unit.statusKey.toLowerCase()}`);
        }
        const classAttr = classes.join(' ');
        const styleParts = [];
        if (unit.colorInfo) {
          if (unit.colorInfo.color) styleParts.push(`color:${unit.colorInfo.color}`);
          if (unit.colorInfo.background) styleParts.push(`background:${unit.colorInfo.background}`);
          if (unit.colorInfo.border) styleParts.push(`border-color:${unit.colorInfo.border}`);
        }
        const styleAttr = styleParts.length ? ` style="${styleParts.join(';')}"` : '';
        const tooltipValue = typeof unit.tooltip === 'string' ? unit.tooltip.trim() : '';
        const titleAttr = tooltipValue ? ` title="${escapeAttribute(tooltipValue)}"` : '';
        return `<span class="${classAttr}"${styleAttr}${titleAttr}>${escapeHtml(text)}</span>`;
      }

      function getIncidentUnitStatusLabel(unit) {
        if (!unit) return INCIDENT_UNIT_STATUS_FALLBACK_LABEL;
        const candidates = [
          typeof unit.statusLabel === 'string' ? unit.statusLabel.trim() : '',
          typeof unit.rawStatus === 'string' ? unit.rawStatus.trim() : '',
          typeof unit.statusKey === 'string' ? unit.statusKey.trim() : ''
        ];
        const label = candidates.find(value => value);
        return label || INCIDENT_UNIT_STATUS_FALLBACK_LABEL;
      }

      function getIncidentUnitStatusSortIndex(statusKey) {
        if (typeof statusKey === 'string' && statusKey) {
          const index = INCIDENT_UNIT_STATUS_SECTION_ORDER.indexOf(statusKey);
          if (index !== -1) return index;
        }
        return INCIDENT_UNIT_STATUS_SECTION_ORDER.length;
      }

      function buildIncidentUnitStatusGroups(units) {
        if (!Array.isArray(units) || units.length === 0) return [];
        const groupsMap = new Map();
        units.forEach((unit, index) => {
          if (!unit) return;
          const text = typeof unit.displayText === 'string' ? unit.displayText.trim() : '';
          if (!text) return;
          const rawLabel = getIncidentUnitStatusLabel(unit);
          const trimmedLabel = rawLabel ? rawLabel.trim() : '';
          const label = trimmedLabel || INCIDENT_UNIT_STATUS_FALLBACK_LABEL;
          const mapKey = unit.statusKey
            ? `key:${unit.statusKey}`
            : `label:${label.toLowerCase()}`;
          let group = groupsMap.get(mapKey);
          if (!group) {
            group = {
              key: unit.statusKey || '',
              label,
              units: [],
              sortIndex: getIncidentUnitStatusSortIndex(unit.statusKey || ''),
              firstUnitIndex: index
            };
            groupsMap.set(mapKey, group);
          }
          group.units.push(unit);
          if (index < group.firstUnitIndex) {
            group.firstUnitIndex = index;
          }
        });
        return Array.from(groupsMap.values()).sort((a, b) => {
          if (a.sortIndex !== b.sortIndex) return a.sortIndex - b.sortIndex;
          if (a.firstUnitIndex !== b.firstUnitIndex) return a.firstUnitIndex - b.firstUnitIndex;
          return a.label.localeCompare(b.label);
        });
      }

      function renderIncidentPopupUnitsSection(units) {
        const validUnits = Array.isArray(units)
          ? units.filter(unit => unit && typeof unit.displayText === 'string' && unit.displayText.trim())
          : [];
        if (!validUnits.length) return '';
        const groups = buildIncidentUnitStatusGroups(validUnits);
        if (!groups.length) return '';
        const groupsHtml = groups.map(group => {
          const unitsHtml = group.units.map(renderIncidentUnit).filter(Boolean).join('');
          if (!unitsHtml) return '';
          const safeLabel = escapeHtml(group.label);
          return `<div class="incident-popup__unit-status-group"><div class="incident-popup__unit-status-title">${safeLabel}</div><div class="incident-popup__unit-list">${unitsHtml}</div></div>`;
        }).filter(Boolean).join('');
        if (!groupsHtml) return '';
        return `<div class="incident-popup__section incident-popup__units"><div class="incident-popup__section-title">Units</div>${groupsHtml}</div>`;
      }

      function renderIncidentAlertUnitsSection(units) {
        const validUnits = Array.isArray(units)
          ? units.filter(unit => unit && typeof unit.displayText === 'string' && unit.displayText.trim())
          : [];
        if (!validUnits.length) return '';
        const groups = buildIncidentUnitStatusGroups(validUnits);
        if (!groups.length) return '';
        const groupsHtml = groups.map(group => {
          const unitsHtml = group.units.map(renderIncidentUnit).filter(Boolean).join('');
          if (!unitsHtml) return '';
          const safeLabel = escapeHtml(group.label);
          return `<div class="incident-alert__unit-status-group"><div class="incident-alert__unit-status-title">${safeLabel}</div><div class="incident-alert__unit-list">${unitsHtml}</div></div>`;
        }).filter(Boolean).join('');
        if (!groupsHtml) return '';
        return `<div class="incident-alert__units"><div class="incident-alert__units-label">Units</div>${groupsHtml}</div>`;
      }

      function renderIncidentAlertItem(entry) {
        if (!entry || !entry.incident) return '';
        const incident = entry.incident;
        const typeLabel = getIncidentTypeLabel(incident) || 'Incident';
        const safeTypeLabel = escapeHtml(typeLabel);
        const typeCode = getIncidentTypeCode(incident);
        const iconUrl = buildPulsePointListIconUrl(typeCode);
        const altText = typeLabel ? `${typeLabel} icon` : 'Incident icon';
        const safeAltText = escapeAttribute(altText);
        const iconHtml = iconUrl
          ? `<div class="incident-alert__media"><img src="${escapeAttribute(iconUrl)}" alt="${safeAltText}" loading="lazy" onerror="this.style.display='none';"></div>`
          : '';
        let incidentIdValue = typeof entry.id === 'string' ? entry.id : '';
        if (!incidentIdValue) {
          incidentIdValue = getIncidentIdentifier(incident) || '';
        }
        const normalizedIncidentId = getNormalizedIncidentId(incidentIdValue);
        if (!normalizedIncidentId) return '';
        const safeIncidentId = escapeAttribute(normalizedIncidentId);
        const locationText = getIncidentLocationText(incident);
        const locationHtml = locationText
          ? `<div class="incident-alert__location"><span class="incident-alert__location-label">Location:</span><span class="incident-alert__location-text">${escapeHtml(locationText)}</span></div>`
          : '';
        const timeInfo = getIncidentReceivedTimeInfo(incident);
        const metaParts = [];
        if (timeInfo) {
          metaParts.push(`<span class="incident-alert__received" title="${escapeAttribute(timeInfo.full)}">Received ${escapeHtml(timeInfo.display)}</span>`);
        }
        const metaHtml = metaParts.length ? `<div class="incident-alert__meta">${metaParts.join('')}</div>` : '';
        const routeNames = Array.isArray(entry.routes)
          ? entry.routes.map(route => (typeof route?.name === 'string' ? route.name.trim() : '')).filter(Boolean)
          : [];
        const routesHtml = routeNames.length
          ? `<div class="incident-alert__routes-line"><span class="incident-alert__routes-label">Routes:</span><span class="incident-alert__routes-list">${routeNames.map(name => escapeHtml(name)).join(', ')}</span></div>`
          : '';
        const units = extractIncidentUnits(incident);
        const unitsHtml = renderIncidentAlertUnitsSection(units);
        const buttonTitleParts = [];
        if (typeLabel) {
          buttonTitleParts.push(`View ${typeLabel}`);
        } else {
          buttonTitleParts.push('View incident');
        }
        if (locationText) {
          buttonTitleParts.push(`at ${locationText}`);
        }
        buttonTitleParts.push('on the map');
        const safeButtonTitle = escapeAttribute(buttonTitleParts.join(' '));
        return `
          <button type="button" class="incident-alert__item incident-alert__item-button" data-incident-id="${safeIncidentId}" onclick="handleIncidentAlertClick(this)" title="${safeButtonTitle}">
            ${iconHtml}
            <div class="incident-alert__content">
              <div class="incident-alert__type">${safeTypeLabel}</div>
              ${metaHtml}
              ${locationHtml}
              ${routesHtml}
              ${unitsHtml}
            </div>
          </button>
        `;
      }

      function renderIncidentAlertsHtml() {
        const hasDemo = demoIncidentActive && demoIncidentEntry && demoIncidentEntry.incident;
        if (!hasDemo && !incidentsAreAvailable()) return '';
        const sourceEntries = hasDemo
          ? [demoIncidentEntry]
          : (Array.isArray(incidentsNearRoutes) ? incidentsNearRoutes : []);
        if (!Array.isArray(sourceEntries) || sourceEntries.length === 0) return '';
        const itemsHtml = sourceEntries.map(renderIncidentAlertItem).filter(Boolean).join('');
        if (!itemsHtml) return '';
        const multiple = sourceEntries.length > 1;
        const heading = hasDemo
          ? 'Demo Incident Near a Route'
          : (multiple ? 'Active Incidents Near Routes' : 'Active Incident Near a Route');
        const subheading = hasDemo
          ? 'Preview of an active incident alert using built-in sample data.'
          : (multiple
            ? 'Emergency responses are active on or near multiple transit corridors.'
            : 'An emergency response is active on or near a transit corridor.');
        return `
          <div class="selector-section incident-alert-block">
            <div class="incident-alert__header">
              <div class="incident-alert__title">${escapeHtml(heading)}</div>
              <div class="incident-alert__subtitle">${escapeHtml(subheading)}</div>
            </div>
            <div class="incident-alert__list">
              ${itemsHtml}
            </div>
          </div>
        `;
      }

      function handleIncidentAlertClick(element) {
        if (!element) return;
        const incidentId = element.getAttribute('data-incident-id');
        if (!incidentId) return;
        focusIncidentOnMap(incidentId);
      }

      function focusIncidentOnMap(incidentId) {
        if (!map) return;
        const normalizedId = getNormalizedIncidentId(incidentId);
        if (!normalizedId) return;
        maintainIncidentLayers();
        const entry = incidentMarkers.get(normalizedId);
        let latLng = null;
        if (entry && entry.marker && typeof entry.marker.getLatLng === 'function') {
          latLng = entry.marker.getLatLng();
        }
        if (!latLng) {
          const match = incidentsNearRoutesLookup.get(normalizedId);
          const incident = match?.incident || entry?.data || null;
          if (incident) {
            const lat = parseIncidentCoordinate(incident.Latitude ?? incident.latitude ?? incident.lat);
            const lon = parseIncidentCoordinate(incident.Longitude ?? incident.longitude ?? incident.lon);
            if (Number.isFinite(lat) && Number.isFinite(lon)) {
              if (typeof L !== 'undefined' && typeof L.latLng === 'function') {
                latLng = L.latLng(lat, lon);
              } else {
                latLng = { lat, lng: lon };
              }
            }
          }
        }
        if (!latLng || !Number.isFinite(latLng.lat) || !Number.isFinite(latLng.lng)) {
          return;
        }
        const targetLat = Number(latLng.lat);
        const targetLng = Number(latLng.lng);
        if (!Number.isFinite(targetLat) || !Number.isFinite(targetLng)) {
          return;
        }
        const currentZoom = typeof map.getZoom === 'function' ? map.getZoom() : null;
        const targetZoom = Number.isFinite(currentZoom) ? Math.max(currentZoom, 16) : 16;
        if (typeof map.flyTo === 'function') {
          map.flyTo([targetLat, targetLng], targetZoom, { animate: true, duration: 0.75, easeLinearity: 0.25 });
        } else if (typeof map.setView === 'function') {
          map.setView([targetLat, targetLng], targetZoom, { animate: true });
        }
        if (entry && entry.marker) {
          if (typeof entry.marker.bringToFront === 'function') {
            entry.marker.bringToFront();
          } else if (typeof entry.marker.setZIndexOffset === 'function') {
            entry.marker.setZIndexOffset(500);
          }
          if (typeof entry.marker.fire === 'function') {
            entry.marker.fire('click');
          }
        } else {
          const match = incidentsNearRoutesLookup.get(normalizedId);
          const incident = match?.incident || null;
          if (incident) {
            const routes = Array.isArray(match?.routes) ? match.routes : [];
            createCustomPopup({
              popupType: 'incident',
              position: [targetLat, targetLng],
              incident,
              id: normalizedId,
              routes
            });
          }
        }
      }

      function escapeAttribute(value) {
        return String(value || '')
          .replace(/&/g, '&amp;')
          .replace(/"/g, '&quot;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }


      function sanitizeBaseUrl(url) {
        if (typeof url !== 'string') return '';
        return url.trim().replace(/\/+$/, '');
      }

      function formatServiceAlertsBadgeText(count) {
        const numeric = Number(count);
        if (!Number.isFinite(numeric) || numeric <= 0) {
          return '';
        }
        if (numeric > SERVICE_ALERT_BADGE_MAX) {
          return `${SERVICE_ALERT_BADGE_MAX}+`;
        }
        return `${Math.round(numeric)}`;
      }

      function getActiveServiceAlertCount() {
        if (!Array.isArray(serviceAlerts) || serviceAlerts.length === 0) {
          return 0;
        }
        return serviceAlerts.reduce((total, alert) => {
          if (!alert) return total;
          return total + (alert.isActive === false ? 0 : 1);
        }, 0);
      }

      function resetServiceAlertsState() {
        serviceAlerts = [];
        serviceAlertsLoading = false;
        serviceAlertsError = null;
        serviceAlertsExpanded = false;
        updateServiceAlertsUI();
      }

      function formatServiceAlertDate(date) {
        if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
          return '';
        }
        if (SERVICE_ALERT_DATE_FORMATTER) {
          try {
            return SERVICE_ALERT_DATE_FORMATTER.format(date);
          } catch (error) {
            // ignore formatting errors and fall back
          }
        }
        try {
          return date.toLocaleString();
        } catch (error) {
          return date.toString();
        }
      }

      function formatServiceAlertTimeValue(value) {
        if (value === null || value === undefined) {
          return { display: '', raw: '' };
        }
        if (value instanceof Date && !Number.isNaN(value.getTime())) {
          return {
            display: formatServiceAlertDate(value),
            raw: value.toISOString()
          };
        }
        if (typeof value === 'number' && Number.isFinite(value)) {
          const date = new Date(value);
          if (!Number.isNaN(date.getTime())) {
            return {
              display: formatServiceAlertDate(date),
              raw: String(value)
            };
          }
          return { display: String(value), raw: String(value) };
        }
        if (typeof value === 'string') {
          const trimmed = value.trim();
          if (!trimmed) {
            return { display: '', raw: '' };
          }
          const unixMatch = trimmed.match(/\/Date\((\d+)\)\/?/i);
          if (unixMatch && unixMatch[1]) {
            const millis = Number(unixMatch[1]);
            if (Number.isFinite(millis)) {
              const date = new Date(millis);
              if (!Number.isNaN(date.getTime())) {
                return {
                  display: formatServiceAlertDate(date),
                  raw: trimmed
                };
              }
            }
          }
          const parsed = new Date(trimmed);
          if (!Number.isNaN(parsed.getTime())) {
            return {
              display: formatServiceAlertDate(parsed),
              raw: trimmed
            };
          }
          return { display: trimmed, raw: trimmed };
        }
        if (typeof value === 'object') {
          const stringValue = String(value);
          if (stringValue && stringValue !== '[object Object]') {
            return formatServiceAlertTimeValue(stringValue);
          }
        }
        return { display: '', raw: '' };
      }

      function extractServiceAlertTime(record, type) {
        if (!record || typeof record !== 'object') {
          return { display: '', raw: '' };
        }
        const fields = type === 'end' ? SERVICE_ALERT_END_FIELDS : SERVICE_ALERT_START_FIELDS;
        for (const field of fields) {
          if (Object.prototype.hasOwnProperty.call(record, field)) {
            const info = formatServiceAlertTimeValue(record[field]);
            if (info.display) {
              return info;
            }
          }
        }
        const lowerKeyMap = Object.keys(record).reduce((acc, key) => {
          acc[key.toLowerCase()] = key;
          return acc;
        }, {});
        for (const field of fields) {
          const originalKey = lowerKeyMap[field.toLowerCase()];
          if (originalKey && Object.prototype.hasOwnProperty.call(record, originalKey)) {
            const info = formatServiceAlertTimeValue(record[originalKey]);
            if (info.display) {
              return info;
            }
          }
        }
        return { display: '', raw: '' };
      }

      function normalizeServiceAlertRoutes(record) {
        const collected = [];
        const candidateKeys = ['Routes', 'routes', 'RoutesAffected', 'routesAffected', 'AffectedRoutes', 'affectedRoutes', 'RouteNames', 'routeNames'];
        for (const key of candidateKeys) {
          if (!Object.prototype.hasOwnProperty.call(record, key)) continue;
          const value = record[key];
          if (Array.isArray(value)) {
            value.forEach(entry => {
              if (!entry) return;
              if (typeof entry === 'string') {
                const trimmed = entry.trim();
                if (trimmed) collected.push(trimmed);
                return;
              }
              if (typeof entry === 'object') {
                const nameCandidates = [
                  typeof entry.Name === 'string' ? entry.Name.trim() : '',
                  typeof entry.RouteName === 'string' ? entry.RouteName.trim() : '',
                  typeof entry.Description === 'string' ? entry.Description.trim() : '',
                  typeof entry.Title === 'string' ? entry.Title.trim() : '',
                  typeof entry.label === 'string' ? entry.label.trim() : ''
                ];
                const label = nameCandidates.find(candidate => candidate);
                if (label) collected.push(label);
              }
            });
          } else if (typeof value === 'string') {
            const trimmed = value.trim();
            if (trimmed) {
              trimmed.split(/[,;]+/).map(part => part.trim()).filter(Boolean).forEach(part => collected.push(part));
            }
          }
          if (collected.length) break;
        }
        if (!collected.length) {
          return [];
        }
        const seen = new Set();
        return collected.filter(route => {
          const key = route.toLowerCase();
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
      }

      function normalizeServiceAlertRow(row) {
        if (!row || typeof row !== 'object') return null;
        const titleCandidates = [
          typeof row.MessageTitle === 'string' ? row.MessageTitle.trim() : '',
          typeof row.Title === 'string' ? row.Title.trim() : '',
          typeof row.Subject === 'string' ? row.Subject.trim() : ''
        ];
        const messageCandidates = [
          typeof row.MessageText === 'string' ? row.MessageText.trim() : '',
          typeof row.MessageBody === 'string' ? row.MessageBody.trim() : '',
          typeof row.Text === 'string' ? row.Text.trim() : '',
          typeof row.Description === 'string' ? row.Description.trim() : '',
          typeof row.Details === 'string' ? row.Details.trim() : '',
          typeof row.Body === 'string' ? row.Body.trim() : ''
        ];
        const title = titleCandidates.find(candidate => candidate) || '';
        const message = messageCandidates.find(candidate => candidate) || '';
        const startInfo = extractServiceAlertTime(row, 'start');
        const endInfo = extractServiceAlertTime(row, 'end');
        const idCandidates = [
          row.MessageID,
          row.MessageId,
          row.MessageGuid,
          row.Guid,
          row.ID,
          row.Id,
          row.AlertId,
          row.AlertID,
          row.RecordId,
          row.RecordID
        ];
        const rawId = idCandidates.find(value => value !== null && value !== undefined);
        const statusValue = typeof row.Status === 'string' ? row.Status.trim().toLowerCase() : '';
        let isActive = true;
        if (Object.prototype.hasOwnProperty.call(row, 'IsActive')) {
          isActive = !!row.IsActive;
        } else if (Object.prototype.hasOwnProperty.call(row, 'Active')) {
          isActive = !!row.Active;
        } else if (Object.prototype.hasOwnProperty.call(row, 'Visible')) {
          isActive = !!row.Visible;
        } else if (statusValue) {
          isActive = !(statusValue === 'inactive' || statusValue === 'expired' || statusValue === 'inactive alert');
        }
        const routes = normalizeServiceAlertRoutes(row);
        return {
          id: rawId !== undefined && rawId !== null ? String(rawId) : (title || message || null),
          title,
          message,
          startDisplay: startInfo.display,
          startRaw: startInfo.raw,
          endDisplay: endInfo.display,
          endRaw: endInfo.raw,
          isActive,
          routes
        };
      }

      function extractServiceAlertRows(data) {
        if (!data) return [];
        if (Array.isArray(data)) return data;
        if (Array.isArray(data.Rows)) return data.Rows;
        if (Array.isArray(data.rows)) return data.rows;
        if (Array.isArray(data.Result?.Rows)) return data.Result.Rows;
        if (Array.isArray(data.Result)) return data.Result;
        if (Array.isArray(data.Data)) return data.Data;
        if (Array.isArray(data.data)) return data.data;
        if (Array.isArray(data.Messages)) return data.Messages;
        if (Array.isArray(data.messages)) return data.messages;
        if (data.d) return extractServiceAlertRows(data.d);
        return [];
      }

      function buildServiceAlertsStatusText() {
        if (serviceAlertsLoading) {
          return SERVICE_ALERT_STATUS_LOADING;
        }
        if (serviceAlertsError) {
          return SERVICE_ALERT_STATUS_ERROR;
        }
        const count = getActiveServiceAlertCount();
        if (count > 0) {
          const badgeText = formatServiceAlertsBadgeText(count);
          const labelCount = badgeText || `${count}`;
          return count === 1 ? '1 active alert' : `${labelCount} active alerts`;
        }
        return SERVICE_ALERT_STATUS_NO_ALERTS;
      }

      function renderServiceAlertItem(alert) {
        if (!alert) return '';
        const idAttr = alert.id ? ` data-alert-id="${escapeAttribute(alert.id)}"` : '';
        const title = typeof alert.title === 'string' ? alert.title : '';
        const message = typeof alert.message === 'string' ? alert.message : '';
        const titleHtml = title ? `<div class="service-alerts__item-title">${escapeHtml(title)}</div>` : '';
        const messageHtml = message ? `<div class="service-alerts__item-message">${escapeHtml(message)}</div>` : '';
        const metaRows = [];
        if (alert.startDisplay) {
          const titleAttr = alert.startRaw ? ` title="${escapeAttribute(alert.startRaw)}"` : '';
          metaRows.push(`<div class="service-alerts__meta-row"><dt>Start</dt><dd${titleAttr}>${escapeHtml(alert.startDisplay)}</dd></div>`);
        }
        if (alert.endDisplay) {
          const titleAttr = alert.endRaw ? ` title="${escapeAttribute(alert.endRaw)}"` : '';
          metaRows.push(`<div class="service-alerts__meta-row"><dt>End</dt><dd${titleAttr}>${escapeHtml(alert.endDisplay)}</dd></div>`);
        }
        if (Array.isArray(alert.routes) && alert.routes.length > 0) {
          const routesHtml = alert.routes.map(route => escapeHtml(route)).join(', ');
          metaRows.push(`<div class="service-alerts__meta-row"><dt>Routes</dt><dd>${routesHtml}</dd></div>`);
        }
        const metaHtml = metaRows.length ? `<dl class="service-alerts__meta">${metaRows.join('')}</dl>` : '';
        if (!titleHtml && !messageHtml && !metaHtml) {
          return '';
        }
        return `<li class="service-alerts__item"${idAttr}>${titleHtml}${messageHtml}${metaHtml}</li>`;
      }

      function renderServiceAlertsContent() {
        const container = document.getElementById('serviceAlertsPanel');
        const statusEl = document.querySelector('#serviceAlerts .service-alerts__status');
        if (statusEl) {
          statusEl.textContent = buildServiceAlertsStatusText();
        }
        if (!container) {
          return;
        }
        if (serviceAlertsLoading) {
          container.innerHTML = `<div class="service-alerts__state service-alerts__state--loading"><span class="service-alerts__spinner" aria-hidden="true"></span><span>Loading service alerts</span></div>`;
          return;
        }
        if (serviceAlertsError) {
          container.innerHTML = `<div class="service-alerts__state service-alerts__state--error">${escapeHtml(serviceAlertsError)}</div>`;
          return;
        }
        if (!Array.isArray(serviceAlerts) || serviceAlerts.length === 0) {
          container.innerHTML = `<div class="service-alerts__state service-alerts__state--empty">${escapeHtml(SERVICE_ALERT_EMPTY_MESSAGE)}</div>`;
          return;
        }
        const itemsHtml = serviceAlerts.map(renderServiceAlertItem).filter(Boolean).join('');
        if (!itemsHtml) {
          container.innerHTML = `<div class="service-alerts__state service-alerts__state--empty">${escapeHtml(SERVICE_ALERT_EMPTY_MESSAGE)}</div>`;
          return;
        }
        container.innerHTML = `<ul class="service-alerts__list">${itemsHtml}</ul>`;
      }

      function updateServiceAlertsSectionState() {
        const section = document.getElementById('serviceAlerts');
        if (!section) return;
        section.classList.toggle('is-expanded', serviceAlertsExpanded);
        section.classList.toggle('is-collapsed', !serviceAlertsExpanded);
        section.classList.toggle('is-loading', !!serviceAlertsLoading);
        section.classList.toggle('has-error', !!serviceAlertsError);
        const hasAlerts = getActiveServiceAlertCount() > 0;
        section.classList.toggle('has-alerts', hasAlerts);
        section.classList.toggle('has-active-alerts', hasAlerts && !serviceAlertsExpanded);
      }

      function syncServiceAlertsBadge() {
        const headerBadge = document.querySelector('#serviceAlerts .service-alerts__badge');
        const toggleBadge = document.getElementById('controlPanelAlertBadge');
        const controlPanelElement = document.getElementById('controlPanel');
        const controlPanelTab = document.getElementById('controlPanelTab');
        const badgeText = formatServiceAlertsBadgeText(getActiveServiceAlertCount());
        const panelHidden = controlPanelElement ? controlPanelElement.classList.contains('hidden') : false;
        const panelDisplayNone = controlPanelElement ? controlPanelElement.style.display === 'none' : false;
        const toggleHidden = controlPanelTab
          ? (controlPanelTab.style.display === 'none' || controlPanelTab.classList.contains('is-hidden-mobile'))
          : false;
        if (headerBadge) {
          const shouldShowHeader = !!badgeText && !panelHidden && !panelDisplayNone;
          headerBadge.hidden = !shouldShowHeader;
          headerBadge.textContent = shouldShowHeader ? badgeText : '';
        }
        if (toggleBadge) {
          const shouldShowToggle = !!badgeText && panelHidden && !panelDisplayNone && !toggleHidden;
          toggleBadge.hidden = !shouldShowToggle;
          toggleBadge.textContent = shouldShowToggle ? badgeText : '';
        }
      }

      function applyServiceAlertsExpandedState() {
        const toggle = document.querySelector('#serviceAlerts .service-alerts__header');
        if (toggle) {
          toggle.setAttribute('aria-expanded', serviceAlertsExpanded ? 'true' : 'false');
        }
        updateServiceAlertsSectionState();
        syncServiceAlertsBadge();
      }

      function updateServiceAlertsUI() {
        renderServiceAlertsContent();
        applyServiceAlertsExpandedState();
      }

      function toggleServiceAlertsSection(event) {
        if (event && typeof event.preventDefault === 'function') {
          event.preventDefault();
        }
        serviceAlertsExpanded = !serviceAlertsExpanded;
        applyServiceAlertsExpandedState();
      }

      function initializeServiceAlertsSection() {
        const toggle = document.querySelector('#serviceAlerts .service-alerts__header');
        if (toggle) {
          toggle.addEventListener('click', toggleServiceAlertsSection);
        }
        updateServiceAlertsUI();
      }

      async function fetchServiceAlerts() {
        if (isEtaSpotAgency()) {
          serviceAlerts = [];
          serviceAlertsLoading = false;
          serviceAlertsError = SERVICE_ALERT_UNAVAILABLE_MESSAGE;
          updateServiceAlertsUI();
          return [];
        }
        const currentBaseUrl = baseURL;
        const sanitizedBase = sanitizeBaseUrl(currentBaseUrl);
        if (!sanitizedBase) {
          serviceAlerts = [];
          serviceAlertsError = null;
          serviceAlertsLoading = false;
          updateServiceAlertsUI();
          return [];
        }
        serviceAlertsLoading = true;
        serviceAlertsError = null;
        updateServiceAlertsUI();
        const query = new URLSearchParams({
          showInactive: 'false',
          includeDeleted: 'false',
          messageTypeId: '1',
          search: 'false',
          rows: '10',
          page: '1',
          sortIndex: 'StartDateUtc',
          sortOrder: 'asc'
        });
        const endpoint = `${sanitizedBase}/Secure/Services/RoutesService.svc/GetMessagesPaged?${query.toString()}`;
        try {
          const response = await fetch(endpoint, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Service alerts request failed: ${response.status}`);
          }
          const text = await response.text();
          let payload = {};
          if (text) {
            try {
              payload = JSON.parse(text);
            } catch (parseError) {
              console.error('Failed to parse service alerts response:', parseError);
              throw parseError;
            }
          }
          let rows = extractServiceAlertRows(payload);
          if (!rows.length && payload && typeof payload === 'object' && payload.d) {
            rows = extractServiceAlertRows(payload.d);
          }
          const normalized = rows.map(normalizeServiceAlertRow).filter(Boolean);
          if (currentBaseUrl !== baseURL) {
            return normalized;
          }
          serviceAlerts = normalized;
          serviceAlertsError = null;
          serviceAlertsLoading = false;
          updateServiceAlertsUI();
          return normalized;
        } catch (error) {
          console.error('Failed to fetch service alerts:', error);
          if (currentBaseUrl !== baseURL) {
            return [];
          }
          serviceAlerts = [];
          serviceAlertsError = SERVICE_ALERT_UNAVAILABLE_MESSAGE;
          serviceAlertsLoading = false;
          updateServiceAlertsUI();
          return [];
        }
      }

      function updateControlPanel() {
        const panel = document.getElementById('controlPanel');
        if (!panel) return;

        const selectedAgency = agencies.find(a => a.url === baseURL);
        const sanitizedBaseURL = sanitizeBaseUrl(baseURL);
        let logoHtml = '';
        if (sanitizedBaseURL) {
          const agencyLogoUrl = `${sanitizedBaseURL}/Images/clientLogo.jpg`;
          const safeLogoSrc = escapeAttribute(agencyLogoUrl);
          const logoAltText = selectedAgency?.name ? `${selectedAgency.name} logo` : 'Agency logo';
          const safeLogoAltText = escapeAttribute(logoAltText);
          logoHtml = `
            <div class="selector-logo">
              <img src="${safeLogoSrc}" alt="${safeLogoAltText}" loading="lazy" onerror="this.closest('.selector-logo').style.display='none';">
            </div>
          `;
        }

        const incidentAlertsHtml = renderIncidentAlertsHtml();
        let demoButtonHtml = '';
        if (adminMode) {
          const demoButtonLabel = demoIncidentActive ? 'Hide Demo Incident' : 'Show Demo Incident';
          const demoButtonPressed = demoIncidentActive ? 'true' : 'false';
          const demoNoteText = demoIncidentActive
            ? 'Showing sample alert using built-in data.'
            : 'Load a sample alert using built-in data.';
          demoButtonHtml = `
            <!-- Demo incident preview controls (remove when the demo is finished) -->
            <div class="selector-section demo-incident-section">
              <button type="button" id="demoIncidentButton" class="demo-incident-button${demoIncidentActive ? ' is-active' : ''}" aria-pressed="${demoButtonPressed}" onclick="toggleDemoIncident()">
                ${escapeHtml(demoButtonLabel)}
              </button>
              <div class="demo-incident-note">${escapeHtml(demoNoteText)}</div>
            </div>
          `;
        }
        const incidentToggleHtml = incidentsAreAvailable() ? `
          <div class="selector-group">
            <div class="selector-label">Incidents</div>
            <button type="button" id="incidentToggleButton" class="pill-button incident-toggle-button${incidentsVisible ? ' is-active' : ''}" aria-pressed="${incidentsVisible ? 'true' : 'false'}" onclick="toggleIncidentsVisibility()">
              Show Incidents<span class="toggle-indicator">${incidentsVisible ? 'On' : 'Off'}</span>
            </button>
          </div>
        ` : '';
        const serviceAlertsExpandedClass = serviceAlertsExpanded ? 'is-expanded' : 'is-collapsed';
        const serviceAlertsStatusText = buildServiceAlertsStatusText();
        const serviceAlertsBadgeText = formatServiceAlertsBadgeText(getActiveServiceAlertCount());
        const serviceAlertsBadgeAttr = serviceAlertsBadgeText ? '' : ' hidden';
        const serviceAlertsSectionHtml = `
          <div class="selector-section service-alerts ${serviceAlertsExpandedClass}" id="serviceAlerts">
            <button class="service-alerts__header" aria-expanded="${serviceAlertsExpanded ? 'true' : 'false'}" aria-controls="serviceAlertsPanel">
              <div class="service-alerts__header-main">
                <div class="service-alerts__title">Service Alerts</div>
                <div class="service-alerts__status">${escapeHtml(serviceAlertsStatusText)}</div>
              </div>
              <span class="service-alerts__badge"${serviceAlertsBadgeAttr}>${escapeHtml(serviceAlertsBadgeText)}</span>
              <span class="service-alerts__chevron">&#8250;</span>
            </button>
            <div class="service-alerts__content" id="serviceAlertsPanel"></div>
          </div>
        `;
        let html = `
          <div class="selector-header">
            <div class="selector-header-text">
              <div class="selector-title">System Controls</div>
              <div class="selector-subtitle">Choose a transit system and label style.</div>
            </div>
            ${logoHtml}
          </div>
          <div class="selector-content">
            <div class="selector-group">
              <label class="selector-label" for="agencySelect">Select System</label>
              <div class="selector-control">
                <select id="agencySelect" onchange="changeAgency(this.value)">
        `;
        agencies.forEach(a => {
          html += `<option value="${a.url}" ${a.url === baseURL ? 'selected' : ''}>${a.name}</option>`;
        });
        html += `
                </select>
              </div>
            </div>
        `;
        html += serviceAlertsSectionHtml;

        if (adminMode) {
          html += `
            <div class="selector-group">
              <div class="selector-label">Vehicle Labels</div>
              <div class="display-mode-group" id="displayModeButtons">
                <button type="button" class="pill-button display-mode-button ${displayMode === DISPLAY_MODES.SPEED ? 'is-active' : ''}" data-mode="${DISPLAY_MODES.SPEED}" onclick="setDisplayMode('${DISPLAY_MODES.SPEED}')">
                  Show Speed
                </button>
                <button type="button" class="pill-button display-mode-button ${displayMode === DISPLAY_MODES.BLOCK ? 'is-active' : ''}" data-mode="${DISPLAY_MODES.BLOCK}" onclick="setDisplayMode('${DISPLAY_MODES.BLOCK}')">
                  Show Blocks
                </button>
                <button type="button" class="pill-button display-mode-button ${displayMode === DISPLAY_MODES.NONE ? 'is-active' : ''}" data-mode="${DISPLAY_MODES.NONE}" onclick="setDisplayMode('${DISPLAY_MODES.NONE}')">
                  Show None
                </button>
              </div>
            </div>
          `;
        }

        html += `
            ${incidentToggleHtml}
            ${incidentAlertsHtml}
            ${demoButtonHtml}
          </div>
        `;

        panel.innerHTML = html;
        initializeServiceAlertsSection();
        updateDisplayModeButtons();
        updateIncidentToggleButton();
        positionAllPanelTabs();
      }

      // updateRouteSelector rebuilds the route selector panel.
      // The list (excluding Out of Service) is alphabetized and defaults to
      // checking only routes that currently have vehicles.
      function updateRouteSelector(activeRoutesParam, forceUpdate = false) {
        const container = document.getElementById("routeSelector");
        if (!container) return;

        const activeRoutesSet = activeRoutesParam instanceof Set
          ? activeRoutesParam
          : new Set(Array.isArray(activeRoutesParam) ? activeRoutesParam : []);

        if (forceUpdate) {
          lastRouteSelectorSignature = null;
        }

        const agencyDropdown = document.getElementById('agencySelect');
        if (!forceUpdate && agencyDropdown && document.activeElement === agencyDropdown) {
          return;
        }

        let routeIDs = Object.keys(allRoutes)
          .map(id => Number(id))
          .filter(id => !Number.isNaN(id) && id !== 0 && canDisplayRoute(id));

        routeIDs.sort((a, b) => {
          const aHasVehicle = activeRoutesSet.has(a);
          const bHasVehicle = activeRoutesSet.has(b);
          if (aHasVehicle !== bHasVehicle) {
            return aHasVehicle ? -1 : 1;
          }
          const routeA = allRoutes[a] || {};
          const routeB = allRoutes[b] || {};
          const nameA = (routeA.Description || routeA.RouteName || `Route ${routeA.RouteID || a}` || '').trim().toUpperCase();
          const nameB = (routeB.Description || routeB.RouteName || `Route ${routeB.RouteID || b}` || '').trim().toUpperCase();
          if (nameA < nameB) return -1;
          if (nameA > nameB) return 1;
          return 0;
        });

        const agenciesSignature = agencies
          .map(a => `${a.url || ''}::${a.name || ''}::${a.type || ''}`)
          .join('|');

        const routeSignatureParts = routeIDs.map(routeID => {
          const route = allRoutes[routeID] || {};
          const checked = Object.prototype.hasOwnProperty.call(routeSelections, routeID)
            ? routeSelections[routeID]
            : activeRoutesSet.has(routeID);
          const infoText = typeof route.InfoText === 'string' ? route.InfoText.trim() : '';
          const desc = typeof route.Description === 'string' ? route.Description.trim() : '';
          const color = route.MapLineColor || '';
          const hasActiveVehicle = activeRoutesSet.has(routeID);
          return `${routeID}:${checked ? 1 : 0}:${color}:${desc}:${infoText}:${hasActiveVehicle ? 1 : 0}`;
        });

        const outOfServiceChecked = adminMode && canDisplayRoute(0)
          ? (Object.prototype.hasOwnProperty.call(routeSelections, 0)
            ? routeSelections[0]
            : activeRoutesSet.has(0))
          : null;

        const signatureParts = [
          baseURL,
          adminMode ? '1' : '0',
          kioskMode ? '1' : '0',
          adminKioskMode ? '1' : '0',
          displayMode || '',
          agenciesSignature,
          outOfServiceChecked === null ? 'na' : (outOfServiceChecked ? '1' : '0'),
          routeSignatureParts.join('|')
        ];

        const signature = signatureParts.join('||');
        if (!forceUpdate && signature === lastRouteSelectorSignature) {
          positionAllPanelTabs();
          return;
        }
        lastRouteSelectorSignature = signature;

        const previousContent = container.querySelector('.selector-content');
        const previousScrollTop = previousContent ? previousContent.scrollTop : 0;
        const activeElement = document.activeElement;
        const focusedElementId = activeElement && container.contains(activeElement) && activeElement.id
          ? activeElement.id
          : null;

        let html = `
          <div class="selector-header">
            <div class="selector-header-text">
              <div class="selector-title">Route Controls</div>
              <div class="selector-subtitle">Tailor the live map to the routes you care about.</div>
            </div>
          </div>
          <div class="selector-content">
            <div class="selector-section">
              <div class="selector-group selector-group--route-actions">
                <div class="selector-label">Select Routes</div>
                <div class="display-mode-group route-action-buttons">
                  <button type="button" class="pill-button" onclick="selectAllRoutes()">Select All</button>
                  <button type="button" class="pill-button" onclick="selectActiveRoutes()">Select Active</button>
                  <button type="button" class="pill-button" onclick="deselectAllRoutes()">Deselect All</button>
                </div>
              </div>
              <div class="route-list">
        `;

        if (adminMode && canDisplayRoute(0)) {
          let outChecked = Object.prototype.hasOwnProperty.call(routeSelections, 0) ? routeSelections[0] : activeRoutesSet.has(0);
          html += `
                <label class="route-option route-option--out">
                  <input type="checkbox" id="route_0" value="0" ${outChecked ? "checked" : ""}>
                  <span class="color-box route-option-swatch" style="background:${outOfServiceRouteColor};"></span>
                  <span class="route-option-text">
                    <span class="route-option-name">Out of Service</span>
                    <span class="route-option-detail">Vehicles without an assigned route</span>
                  </span>
                </label>
          `;
        }

        routeIDs.forEach(routeID => {
          const route = allRoutes[routeID] || {};
          const checked = Object.prototype.hasOwnProperty.call(routeSelections, routeID)
            ? routeSelections[routeID]
            : activeRoutesSet.has(routeID);
          const routeNameRaw = (route.Description || route.RouteName || '').trim();
          const routeName = routeNameRaw !== '' ? routeNameRaw : `Route ${route.RouteID || routeID}`;
          const infoText = typeof route.InfoText === 'string' ? route.InfoText.trim() : '';
          const hasActiveVehicle = activeRoutesSet.has(routeID);
          const detailLines = [];
          if (infoText) {
            detailLines.push(infoText);
          }
          if (!hasActiveVehicle) {
            detailLines.push('No buses currently assigned');
          }
          const detailHtml = detailLines.map(text => `<span class="route-option-detail">${text}</span>`).join('');
          const color = route.MapLineColor || '#A0AEC0';
          html += `
                <label class="route-option">
                  <input type="checkbox" id="route_${routeID}" value="${routeID}" ${checked ? "checked" : ""}>
                  <span class="color-box route-option-swatch" style="background:${color};"></span>
                  <span class="route-option-text">
                    <span class="route-option-name">${routeName}</span>
                    ${detailHtml}
                  </span>
                </label>
          `;
        });

        html += `
              </div>
            </div>
          </div>
        `;

        container.innerHTML = html;

        const newContent = container.querySelector('.selector-content');
        if (newContent) {
          newContent.scrollTop = previousScrollTop;
        }
        if (focusedElementId) {
          const replacementElement = document.getElementById(focusedElementId);
          if (replacementElement && typeof replacementElement.focus === 'function') {
            try {
              replacementElement.focus({ preventScroll: true });
            } catch (error) {
              replacementElement.focus();
            }
          }
        }
        let outChk = document.getElementById("route_0");
        if (outChk) {
          outChk.addEventListener("change", function() {
            routeSelections[0] = outChk.checked;
            applyRouteOptionState(outChk);
            refreshMap();
          });
          applyRouteOptionState(outChk);
        }
        routeIDs.forEach(routeID => {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) return;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.addEventListener("change", function() {
              routeSelections[routeID] = chk.checked;
              applyRouteOptionState(chk);
              refreshMap();
            });
            applyRouteOptionState(chk);
          }
        });

        positionAllPanelTabs();
      }

      function selectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) {
            outChk.checked = true;
            applyRouteOptionState(outChk);
          }
          routeSelections[0] = true;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.checked = true;
            applyRouteOptionState(chk);
          }
          routeSelections[routeID] = true;
        }
        refreshMap();
      }

      function selectActiveRoutes() {
        const activeSet = activeRoutes instanceof Set
          ? activeRoutes
          : new Set(Array.isArray(activeRoutes) ? activeRoutes : []);

        if (adminMode && canDisplayRoute(0)) {
          const outChk = document.getElementById("route_0");
          const shouldSelectOut = activeSet.has(0);
          if (outChk) {
            outChk.checked = shouldSelectOut;
            applyRouteOptionState(outChk);
          }
          routeSelections[0] = shouldSelectOut;
        }

        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          const numericRouteId = Number(routeID);
          const chk = document.getElementById("route_" + routeID);
          const shouldSelect = activeSet.has(numericRouteId);
          if (chk) {
            chk.checked = shouldSelect;
            applyRouteOptionState(chk);
          }
          routeSelections[numericRouteId] = shouldSelect;
        }

        refreshMap();
      }

      function deselectAllRoutes() {
        if (adminMode && canDisplayRoute(0)) {
          let outChk = document.getElementById("route_0");
          if (outChk) {
            outChk.checked = false;
            applyRouteOptionState(outChk);
          }
          routeSelections[0] = false;
        }
        for (let routeID in allRoutes) {
          if (!canDisplayRoute(routeID) || Number(routeID) === 0) continue;
          let chk = document.getElementById("route_" + routeID);
          if (chk) {
            chk.checked = false;
            applyRouteOptionState(chk);
          }
          routeSelections[routeID] = false;
        }
        refreshMap();
      }

      function setPanelToggleArrow(tab, arrowHtml) {
        if (!tab) return;
        const arrowElement = tab.querySelector('.panel-toggle__arrow');
        if (arrowElement) {
          arrowElement.innerHTML = arrowHtml;
        } else {
          tab.innerHTML = arrowHtml;
        }
      }

      // togglePanelVisibility toggles the provided panel's visibility and updates its tab arrow.
      function togglePanelVisibility(panelId, tabId, expandedArrow, collapsedArrow) {
        const panel = document.getElementById(panelId);
        const tab = document.getElementById(tabId);
        if (!panel || !tab) return;
        const isHidden = panel.classList.toggle('hidden');
        setPanelToggleArrow(tab, isHidden ? collapsedArrow : expandedArrow);
        positionAllPanelTabs();
        syncServiceAlertsBadge();
      }

      function toggleRoutePanel() {
        togglePanelVisibility('routeSelector', 'routeSelectorTab', '&#9664;', '&#9654;');
      }

      function toggleControlPanel() {
        togglePanelVisibility('controlPanel', 'controlPanelTab', '&#9654;', '&#9664;');
      }

      function shouldCollapsePanelsOnLoad() {
        return isCompactViewport();
      }

      function initializePanelStateForViewport() {
        if (!shouldCollapsePanelsOnLoad()) return;

        const controlPanel = document.getElementById('controlPanel');
        const controlTab = document.getElementById('controlPanelTab');
        const routePanel = document.getElementById('routeSelector');
        const routeTab = document.getElementById('routeSelectorTab');

        if (controlPanel && !controlPanel.classList.contains('hidden')) {
          controlPanel.classList.add('hidden');
        }
        if (controlTab) {
          setPanelToggleArrow(controlTab, '&#9664;');
        }

        if (routePanel && !routePanel.classList.contains('hidden')) {
          routePanel.classList.add('hidden');
        }
        if (routeTab) {
          setPanelToggleArrow(routeTab, '&#9654;');
        }

        positionAllPanelTabs();
        syncServiceAlertsBadge();
      }

      function renderRouteLegendContent(legendElement, routes) {
        if (!legendElement) return;
        legendElement.style.display = "block";
        legendElement.innerHTML = "";

        const title = document.createElement("div");
        title.className = "legend-title";
        title.textContent = "Routes";
        legendElement.appendChild(title);

        routes.forEach(route => {
          const item = document.createElement("div");
          item.className = "legend-item";

          const color = document.createElement("span");
          color.className = "legend-color";
          color.style.backgroundColor = route.color;
          item.appendChild(color);

          const textContainer = document.createElement("div");
          textContainer.className = "legend-text";

          const name = document.createElement("div");
          name.className = "legend-name";
          name.textContent = route.name;
          textContainer.appendChild(name);

          if (route.description) {
            const description = document.createElement("div");
            description.className = "legend-description";
            description.textContent = route.description;
            textContainer.appendChild(description);
          }

          item.appendChild(textContainer);
          legendElement.appendChild(item);
        });
      }

      function createOutOfServiceLegendEntry() {
        return {
          routeId: 0,
          name: 'Out of Service',
          description: 'Vehicles without an assigned route',
          color: outOfServiceRouteColor
        };
      }

      function extractLegendRouteIdentifiers(route) {
        const rawRouteId = route && typeof route === 'object'
          ? (route.routeId ?? route.routeID ?? route.id ?? null)
          : null;
        const numericId = Number(rawRouteId);
        if (Number.isFinite(numericId)) {
          return {
            rawRouteId,
            numericId,
            stringId: null
          };
        }
        const stringId = rawRouteId !== null && rawRouteId !== undefined
          ? String(rawRouteId).trim()
          : '';
        return {
          rawRouteId,
          numericId: null,
          stringId
        };
      }

      function buildLegendRouteKey(route) {
        const identifiers = extractLegendRouteIdentifiers(route);
        if (Number.isFinite(identifiers.numericId)) {
          return `num:${identifiers.numericId}`;
        }
        if (identifiers.stringId) {
          return `str:${identifiers.stringId.toLowerCase()}`;
        }
        if (route && typeof route.name === 'string' && route.name.trim() !== '') {
          return `name:${route.name.trim().toLowerCase()}`;
        }
        return null;
      }

      function compareLegendRoutes(a, b) {
        const aIdentifiers = extractLegendRouteIdentifiers(a);
        const bIdentifiers = extractLegendRouteIdentifiers(b);
        const aHasNumeric = Number.isFinite(aIdentifiers.numericId);
        const bHasNumeric = Number.isFinite(bIdentifiers.numericId);
        if (aHasNumeric && bHasNumeric) {
          return aIdentifiers.numericId - bIdentifiers.numericId;
        }
        if (aHasNumeric) return -1;
        if (bHasNumeric) return 1;
        const aLabel = aIdentifiers.stringId || (typeof a?.name === 'string' ? a.name.trim() : '');
        const bLabel = bIdentifiers.stringId || (typeof b?.name === 'string' ? b.name.trim() : '');
        return aLabel.localeCompare(bLabel, undefined, { numeric: true, sensitivity: 'base' });
      }

      function mergeLegendRoutes(primaryRoutes, additionalRoutes) {
        const mergedMap = new Map();
        let autoKeyCounter = 0;

        const appendRoute = (route, shouldOverride = false) => {
          if (!route || typeof route !== 'object') return;
          const key = buildLegendRouteKey(route);
          const mapKey = key !== null ? key : `auto:${autoKeyCounter++}`;
          if (mergedMap.has(mapKey)) {
            if (shouldOverride) {
              mergedMap.set(mapKey, route);
            }
            return;
          }
          mergedMap.set(mapKey, route);
        };

        (Array.isArray(primaryRoutes) ? primaryRoutes : []).forEach(route => appendRoute(route, true));
        (Array.isArray(additionalRoutes) ? additionalRoutes : []).forEach(route => appendRoute(route, false));

        const mergedRoutes = Array.from(mergedMap.values());
        mergedRoutes.sort(compareLegendRoutes);
        return mergedRoutes;
      }

      function buildLegendEntryFromState(routeId) {
        const numericRouteId = Number(routeId);
        if (!Number.isFinite(numericRouteId)) return null;
        if (numericRouteId === 0) {
          return createOutOfServiceLegendEntry();
        }

        const storedRoute = allRoutes?.[numericRouteId] || allRoutes?.[`${numericRouteId}`] || {};
        const routeIdLabel = `${numericRouteId}`;

        const nameCandidates = [
          storedRoute.Description,
          storedRoute.Name,
          storedRoute.RouteName
        ];
        const legendName = nameCandidates.find(value => typeof value === 'string' && value.trim() !== '');
        const name = legendName ? legendName.trim() : (routeIdLabel ? `Route ${routeIdLabel}` : 'Route');

        const descriptionCandidates = [
          storedRoute.InfoText,
          storedRoute.Description,
          storedRoute.RouteDescription
        ];
        const legendDescription = descriptionCandidates.find(value => typeof value === 'string' && value.trim() !== '');
        const description = legendDescription ? legendDescription.trim() : '';

        const color = getRouteColor(numericRouteId);

        return {
          routeId: numericRouteId,
          name,
          description,
          color
        };
      }

      function deriveLegendRoutesFromState(options = {}) {
        const { includeAllAvailableRoutes = false } = options || {};
        const legendEntries = [];
        const seenRouteIds = new Set();

        const addRouteId = candidateId => {
          const numericRouteId = Number(candidateId);
          if (!Number.isFinite(numericRouteId)) return;
          if (seenRouteIds.has(numericRouteId)) return;
          if (!canDisplayRoute(numericRouteId)) return;
          if (!includeAllAvailableRoutes && !isRouteSelected(numericRouteId)) return;

          const legendEntry = buildLegendEntryFromState(numericRouteId);
          if (!legendEntry) return;

          seenRouteIds.add(numericRouteId);
          legendEntries.push(legendEntry);
        };

        if (includeAllAvailableRoutes) {
          Object.keys(allRoutes).forEach(routeIdKey => {
            if (!Object.prototype.hasOwnProperty.call(allRoutes, routeIdKey)) return;
            addRouteId(routeIdKey);
          });
        } else {
          if (activeRoutes instanceof Set) {
            activeRoutes.forEach(addRouteId);
          } else if (Array.isArray(activeRoutes)) {
            activeRoutes.forEach(addRouteId);
          }

          Object.keys(routeSelections).forEach(routeIdKey => {
            if (!Object.prototype.hasOwnProperty.call(routeSelections, routeIdKey)) return;
            if (!routeSelections[routeIdKey]) return;
            addRouteId(routeIdKey);
          });
        }

        legendEntries.sort((a, b) => a.routeId - b.routeId);

        return legendEntries;
      }

      function updateRouteLegend(displayedRoutes = [], options = {}) {
        const legend = document.getElementById("routeLegend");
        if (!legend) return;

        const { forceHide = false, preserveOnEmpty = false } = options || {};
        const shouldShowLegend = kioskMode || adminKioskMode;

        if (!shouldShowLegend || forceHide) {
          legend.style.display = "none";
          legend.innerHTML = "";
          lastRenderedLegendRoutes = [];
          return;
        }

        const normalizedRoutes = Array.isArray(displayedRoutes) ? displayedRoutes : [];
        const filteredRoutes = normalizedRoutes.filter(route => {
          const candidateId = route?.routeId ?? route?.routeID ?? route?.id;
          if (adminKioskMode) {
            return routeHasActiveVehicles(candidateId);
          }
          return isRoutePublicById(candidateId);
        });

        const sanitizedRoutes = filteredRoutes.map(route => {
          const rawRouteId = route.routeId ?? route.routeID ?? route.id;
          const routeIdLabel = rawRouteId === undefined || rawRouteId === null ? "" : `${rawRouteId}`;
          const rawName = typeof route.name === "string" ? route.name : "";
          const name = rawName.trim() !== "" ? rawName.trim() : (routeIdLabel ? `Route ${routeIdLabel}` : "Route");
          const rawDescription = typeof route.description === "string" ? route.description : "";
          const description = rawDescription.trim();
          const color = typeof route.color === "string" && route.color.trim() !== "" ? route.color : "#000000";
          return {
            routeId: rawRouteId,
            name,
            description,
            color
          };
        });

        const shouldIncludeOutOfServiceLegend = isRouteSelected(0) && routeHasActiveVehicles(0);
        if (shouldIncludeOutOfServiceLegend) {
          const hasOutOfServiceEntry = sanitizedRoutes.some(route => {
            const candidateId = route?.routeId ?? route?.routeID ?? route?.id;
            return Number(candidateId) === 0;
          });
          if (!hasOutOfServiceEntry) {
            sanitizedRoutes.push(createOutOfServiceLegendEntry());
          }
        }

        const filterAdminLegendRoutes = routes => {
          if (!adminKioskMode) {
            return Array.isArray(routes) ? routes : [];
          }
          if (!Array.isArray(routes)) return [];
          return routes.filter(route => {
            const candidateId = route?.routeId ?? route?.routeID ?? route?.id;
            return routeHasActiveVehicles(candidateId);
          });
        };

        let routesToRender = filterAdminLegendRoutes(sanitizedRoutes);

        if (routesToRender.length === 0) {
          let fallbackRoutes = deriveLegendRoutesFromState({
            includeAllAvailableRoutes: adminKioskMode
          });
          fallbackRoutes = filterAdminLegendRoutes(fallbackRoutes);
          if (fallbackRoutes.length > 0) {
            routesToRender = fallbackRoutes;
          } else if (preserveOnEmpty && lastRenderedLegendRoutes.length > 0) {
            renderRouteLegendContent(legend, lastRenderedLegendRoutes);
            return;
          } else {
            legend.style.display = "none";
            legend.innerHTML = "";
            lastRenderedLegendRoutes = [];
            return;
          }
        } else if (adminKioskMode) {
          let additionalRoutes = deriveLegendRoutesFromState({ includeAllAvailableRoutes: true });
          additionalRoutes = filterAdminLegendRoutes(additionalRoutes);
          if (additionalRoutes.length > 0) {
            routesToRender = mergeLegendRoutes(routesToRender, additionalRoutes);
          }
          routesToRender = filterAdminLegendRoutes(routesToRender);
        }

        if (routesToRender.length === 0) {
          if (preserveOnEmpty && lastRenderedLegendRoutes.length > 0) {
            renderRouteLegendContent(legend, lastRenderedLegendRoutes);
          } else {
            legend.style.display = "none";
            legend.innerHTML = "";
            lastRenderedLegendRoutes = [];
          }
          return;
        }

        lastRenderedLegendRoutes = routesToRender;
        renderRouteLegendContent(legend, routesToRender);
      }

      // refreshMap updates route paths and bus locations.
      function refreshMap() {
        fetchBusLocations().then(fetchRoutePaths);
        if (Array.isArray(stopDataCache) && stopDataCache.length > 0) {
          renderBusStops(stopDataCache);
        }
      }

      function clearRefreshIntervals() {
        refreshIntervals.forEach(clearInterval);
        refreshIntervals = [];
      }

      function startRefreshIntervals() {
        refreshIntervals.push(setInterval(fetchBusLocations, 4000));
        refreshIntervals.push(setInterval(fetchBusStops, 60000));
        refreshIntervals.push(setInterval(fetchBlockAssignments, 60000));
        refreshIntervals.push(setInterval(() => {
          fetchStopArrivalTimes().then(allEtas => {
            cachedEtas = allEtas;
            updateCustomPopups();
          });
        }, 15000));
        refreshIntervals.push(setInterval(fetchRoutePaths, 15000));
        refreshIntervals.push(setInterval(fetchServiceAlerts, SERVICE_ALERT_REFRESH_INTERVAL_MS));
        if (incidentsAreAvailable()) {
          refreshIntervals.push(setInterval(refreshIncidents, INCIDENT_REFRESH_INTERVAL_MS));
          refreshIncidents();
        } else {
          setIncidentsVisibility(false);
        }
      }

      function showCookieBanner() {
        if (kioskMode || adminKioskMode) {
          return;
        }
        if (localStorage.getItem('agencyConsent') !== 'true') {
          const banner = document.getElementById('cookieBanner');
          banner.style.display = 'block';
          document.getElementById('cookieAccept').addEventListener('click', () => {
            localStorage.setItem('agencyConsent', 'true');
            localStorage.setItem('selectedAgency', baseURL);
            banner.style.display = 'none';
          });
        }
      }

      function loadAgencyData() {
        return fetchRouteColors().then(() => {
          const stopArrivalsPromise = fetchStopArrivalTimes().then(allEtas => {
            cachedEtas = allEtas || {};
            updateCustomPopups();
            return allEtas;
          });
          const headingCachePromise = loadVehicleHeadingCache();
          const tasks = [
            fetchBusStops(),
            fetchBlockAssignments(),
            headingCachePromise.then(() => fetchBusLocations().then(() => fetchRoutePaths())),
            stopArrivalsPromise
          ];
          return Promise.allSettled(tasks);
        });
      }

      function changeAgency(url) {
        if (localStorage.getItem('agencyConsent') === 'true') {
          localStorage.setItem('selectedAgency', url);
        }
        beginAgencyLoad();
        clearRefreshIntervals();
        setCurrentAgencyByUrl(url);
        baseURL = url;
        resetIncidentAlertState();
        resetServiceAlertsState();
        updateControlPanel();
        enforceIncidentVisibilityForCurrentAgency();
        fetchServiceAlerts();
        Object.values(markers).forEach(m => map.removeLayer(m));
        markers = {};
        Object.values(nameBubbles).forEach(b => {
          if (b.speedMarker) map.removeLayer(b.speedMarker);
          if (b.nameMarker) map.removeLayer(b.nameMarker);
          if (b.blockMarker) map.removeLayer(b.blockMarker);
        });
        nameBubbles = {};
        stopMarkers.forEach(m => map.removeLayer(m));
        stopMarkers = [];
        routeLayers.forEach(l => map.removeLayer(l));
        routeLayers = [];
        routePolylineCache.clear();
        lastRouteRenderState = {
          selectionKey: '',
          colorSignature: '',
          geometrySignature: '',
          useOverlapRenderer: !!(enableOverlapDashRendering && overlapRenderer)
        };
        lastRouteSelectorSignature = null;
        if (overlapRenderer) {
          overlapRenderer.reset();
        }
        busBlocks = {};
        previousBusData = {};
        cachedEtas = {};
        customPopups.forEach(p => p.remove());
        customPopups = [];
        allRoutes = {};
        routeSelections = {};
        routeStopAddressMap = {};
        routeStopRouteMap = {};
        activeRoutes = new Set();
        routeColors = {};
        routeVisibility = {};
        allRouteBounds = null;
        mapHasFitAllRoutes = false;
        updateRouteLegend([], { forceHide: true });
        updateRouteSelector(new Set(), true);
        loadAgencyData()
          .then(() => {
            startRefreshIntervals();
          })
          .catch(error => {
            console.error('Error loading agency data:', error);
          })
          .finally(() => {
            completeAgencyLoad();
          });
      }

      function getRouteColor(routeID) {
        if (routeID === 0) return outOfServiceRouteColor;
        return routeColors[routeID] || '#000000';
      }

      function initMap() {
          map = L.map('map', {
              zoomControl: false,
              crs: L.CRS.EPSG3857,
              zoomAnimation: true,
              markerZoomAnimation: true
          }).setView([38.03799212281404, -78.50981502838886], 15);
          sharedRouteRenderer = L.svg({ padding: 0 });
          if (sharedRouteRenderer) {
              map.addLayer(sharedRouteRenderer);
          }
          map.createPane('stopsPane');
          const stopsPane = map.getPane('stopsPane');
          if (stopsPane) {
              stopsPane.style.zIndex = 450;
              stopsPane.style.pointerEvents = 'auto';
          }
          map.createPane('busesPane');
          const busesPane = map.getPane('busesPane');
          if (busesPane) {
              busesPane.style.zIndex = 500;
              busesPane.style.pointerEvents = 'auto';
          }
          map.createPane('incidentHalosPane');
          const incidentHalosPane = map.getPane('incidentHalosPane');
          if (incidentHalosPane) {
              incidentHalosPane.style.zIndex = 540;
              incidentHalosPane.style.pointerEvents = 'none';
          }
          map.createPane('incidentsPane');
          const incidentsPane = map.getPane('incidentsPane');
          if (incidentsPane) {
              incidentsPane.style.zIndex = 550;
              incidentsPane.style.pointerEvents = 'auto';
          }
          incidentLayerGroup = L.layerGroup();
          incidentMarkers.forEach(entry => {
              if (entry && entry.marker) {
                  incidentLayerGroup.addLayer(entry.marker);
              }
          });
          if (incidentsVisible) {
              incidentLayerGroup.addTo(map);
          }
          if (!incidentHaloLayerGroup) {
              incidentHaloLayerGroup = L.layerGroup();
          }
          incidentMarkers.forEach(entry => {
              if (entry && entry.haloMarker) {
                  incidentHaloLayerGroup.addLayer(entry.haloMarker);
              }
          });
          if (incidentsVisible && incidentHaloLayerGroup) {
              incidentHaloLayerGroup.addTo(map);
          }
          const cartoLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
              attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
          });
          cartoLight.addTo(map);

          if (enableOverlapDashRendering) {
            overlapRenderer = new OverlapRouteRenderer(map, {
              sampleStepPx: 8,
              dashLengthPx: 16,
              minDashLengthPx: 0.5,
              matchTolerancePx: 6,
              strokeWeight: DEFAULT_ROUTE_STROKE_WEIGHT,
              minStrokeWeight: MIN_ROUTE_STROKE_WEIGHT,
              maxStrokeWeight: MAX_ROUTE_STROKE_WEIGHT,
              renderer: sharedRouteRenderer,
              pane: routePaneName
            });
            map.on('zoomend', () => {
              if (overlapRenderer) {
                overlapRenderer.handleZoomEnd();
              }
            });
          }

          if (kioskMode || adminKioskMode) {
            document.getElementById("routeSelector").style.display = "none";
            document.getElementById("routeSelectorTab").style.display = "none";
            const controlPanel = document.getElementById("controlPanel");
            if (controlPanel) {
              controlPanel.style.display = "none";
            }
            const controlPanelTab = document.getElementById("controlPanelTab");
            if (controlPanelTab) {
              controlPanelTab.style.display = "none";
            }
            syncServiceAlertsBadge();
          }
          map.on('zoom', () => {
              scheduleMarkerScaleUpdate();
              updatePopupPositions();
          });
          map.on('move', () => {
              updatePopupPositions();
          });
          map.on('zoomend', () => {
              if (stopDataCache.length > 0) {
                  renderBusStops(stopDataCache);
              }
              scheduleMarkerScaleUpdate();
              updatePopupPositions();
          });
          applyIncidentHaloStates();
      }

      function fetchBusStops() {
          if (isEtaSpotAgency()) {
              return fetchBusStopsEtaSpot();
          }
          return fetchBusStopsRideSystems();
      }

      function fetchBusStopsRideSystems() {
          const currentBaseURL = baseURL;
          const stopsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStops?APIKey=8882812681`;
          return fetch(stopsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  let stopsArray = data.stops || data;
                  if (stopsArray && Array.isArray(stopsArray)) {
                      stopDataCache = stopsArray;
                      renderBusStops(stopDataCache);
                  }
              })
              .catch(error => console.error('Error fetching bus stops:', error));
      }

      function fetchBusStopsEtaSpot() {
          const expectedBase = baseURL;
          const expectedType = currentAgencyType;
          const serviceUrl = getEtaSpotServiceUrl();
          if (!serviceUrl) {
              stopDataCache = [];
              renderBusStops(stopDataCache);
              return Promise.resolve();
          }
          const params = new URLSearchParams({
              service: 'get_stops',
              token: getEtaSpotToken()
          });
          const endpoint = `${serviceUrl}?${params.toString()}`;
          return fetch(endpoint)
              .then(response => response.json())
              .then(data => {
                  if (expectedBase !== baseURL || currentAgencyType !== expectedType) {
                      return;
                  }
                  const stopsArray = Array.isArray(data?.get_stops) ? data.get_stops : [];
                  const normalizedStops = [];
                  const newRouteStopRouteMap = {};
                  stopsArray.forEach(stop => {
                      const rawLat = stop?.lat ?? stop?.latitude ?? stop?.Latitude;
                      const rawLng = stop?.lng ?? stop?.longitude ?? stop?.Longitude;
                      const lat = Number(rawLat);
                      const lng = Number(rawLng);
                      if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
                          return;
                      }
                      const rawStopId = stop?.id ?? stop?.stopID ?? stop?.StopID;
                      const numericStopId = Number(rawStopId);
                      const stopId = Number.isFinite(numericStopId) ? numericStopId : (typeof rawStopId === 'string' ? rawStopId.trim() : null);
                      const candidateRouteIds = [];
                      if (Array.isArray(stop?.routes)) {
                          stop.routes.forEach(value => candidateRouteIds.push(value));
                      }
                      if (Array.isArray(stop?.routeIDs)) {
                          stop.routeIDs.forEach(value => candidateRouteIds.push(value));
                      }
                      if (stop?.rid !== undefined && stop?.rid !== null) {
                          candidateRouteIds.push(stop.rid);
                      }
                      const uniqueRouteIds = Array.from(new Set(candidateRouteIds.map(value => Number(value)).filter(Number.isFinite)));
                      const name = typeof stop?.name === 'string'
                          ? stop.name.trim()
                          : (typeof stop?.Name === 'string' ? stop.Name.trim() : '');
                      const routeStopId = stopId !== null && stopId !== undefined ? stopId : `${lat},${lng}`;
                      if (uniqueRouteIds.length > 0) {
                          newRouteStopRouteMap[`${routeStopId}`] = uniqueRouteIds.slice();
                      }
                      const normalized = {
                          StopID: stopId ?? routeStopId,
                          RouteStopID: routeStopId,
                          Latitude: lat,
                          Longitude: lng,
                          Description: name || `Stop ${routeStopId}`,
                          Name: name || `Stop ${routeStopId}`,
                          Routes: uniqueRouteIds.map(id => ({ RouteID: id })),
                          RouteIDs: uniqueRouteIds.slice(),
                          RouteID: uniqueRouteIds[0],
                          Code: typeof stop?.code === 'string' ? stop.code.trim() : '',
                          Direction: typeof stop?.direction === 'string' ? stop.direction.trim() : ''
                      };
                      normalizedStops.push(normalized);
                  });
                  routeStopRouteMap = newRouteStopRouteMap;
                  stopDataCache = normalizedStops;
                  renderBusStops(stopDataCache);
              })
              .catch(error => console.error('Error fetching CAT stops:', error));
      }

      function groupStopsByPixelDistance(stops, thresholdPx) {
          if (!Array.isArray(stops) || stops.length === 0) {
              return [];
          }

          const validStops = stops.map(stop => {
              const latitude = parseFloat(stop.Latitude ?? stop.latitude ?? stop.lat);
              const longitude = parseFloat(stop.Longitude ?? stop.longitude ?? stop.lon);
              if (!Number.isFinite(latitude) || !Number.isFinite(longitude)) {
                  return null;
              }
              return { latitude, longitude, stop };
          }).filter(entry => entry !== null);

          if (!map) {
              return validStops.map(entry => ({
                  latitude: entry.latitude,
                  longitude: entry.longitude,
                  stops: [entry.stop]
              }));
          }

          const groups = [];
          validStops.forEach(({ latitude, longitude, stop }) => {
              const stopPoint = map.latLngToLayerPoint([latitude, longitude]);
              let targetGroup = null;
              for (const group of groups) {
                  const groupPoint = map.latLngToLayerPoint([group.latitude, group.longitude]);
                  if (stopPoint.distanceTo(groupPoint) <= thresholdPx) {
                      targetGroup = group;
                      break;
                  }
              }
              if (targetGroup) {
                  targetGroup.stops.push(stop);
                  const totalStops = targetGroup.stops.length;
                  targetGroup.latitude = (targetGroup.latitude * (totalStops - 1) + latitude) / totalStops;
                  targetGroup.longitude = (targetGroup.longitude * (totalStops - 1) + longitude) / totalStops;
              } else {
                  groups.push({
                      latitude,
                      longitude,
                      stops: [stop]
                  });
              }
          });

          return groups;
      }

      function sanitizeStopName(name) {
          if (typeof name !== 'string') {
              return '';
          }
          return name.replace(/^Stop Name:\s*/i, '').trim();
      }

      function normalizeIdentifier(value) {
          if (value === undefined || value === null) {
              return null;
          }
          const str = `${value}`.trim();
          return str === '' ? null : str;
      }

      function getSelectedRouteIdSet() {
          const selected = new Set();
          Object.keys(allRoutes).forEach(routeId => {
              const numericId = Number(routeId);
              if (!Number.isNaN(numericId) && isRouteSelected(numericId)) {
                  selected.add(numericId);
              }
          });
          return selected;
      }

      function buildStopEntriesFromStops(stops) {
          if (!Array.isArray(stops)) {
              return [];
          }

          const entriesByKey = new Map();
          stops.forEach(stop => {
              if (!stop) {
                  return;
              }

              const latitude = stop.Latitude ?? stop.latitude ?? stop.lat;
              const longitude = stop.Longitude ?? stop.longitude ?? stop.lon;
              const routeStopId = normalizeIdentifier(stop.RouteStopID ?? stop.RouteStopId);
              const addressIdFromStop = normalizeIdentifier(stop.AddressID ?? stop.AddressId);
              const addressIdFromMap = routeStopId ? normalizeIdentifier(routeStopAddressMap[routeStopId]) : null;
              const fallbackStopId = normalizeIdentifier(stop.StopID ?? stop.StopId);

              const key = addressIdFromStop
                  || addressIdFromMap
                  || (routeStopId ? `ROUTESTOP_${routeStopId}`
                      : (fallbackStopId ? `STOP_${fallbackStopId}`
                          : `LOC_${latitude}_${longitude}`));

              if (!entriesByKey.has(key)) {
                  entriesByKey.set(key, {
                      addressId: addressIdFromStop || addressIdFromMap || null,
                      routeStopIds: new Set(),
                      stopIds: new Set(),
                      names: new Set(),
                      routeIds: new Set()
                  });
              }

              const entry = entriesByKey.get(key);

              if (routeStopId) {
                  entry.routeStopIds.add(routeStopId);
              }

              if (fallbackStopId) {
                  entry.stopIds.add(fallbackStopId);
              }

              const descriptionCandidates = [
                  stop.Description,
                  stop.Name,
                  stop.StopName,
                  stop.Line1,
                  stop.SignVerbiage
              ];
              const name = descriptionCandidates.find(value => typeof value === 'string' && value.trim() !== '');
              if (name) {
                  entry.names.add(sanitizeStopName(name));
              }

              const routeIdRaw = stop.RouteID ?? stop.RouteId;
              const routeIdNumeric = Number(routeIdRaw);
              if (!Number.isNaN(routeIdNumeric)) {
                  entry.routeIds.add(routeIdNumeric);
              }

              const routesArray = Array.isArray(stop.Routes) ? stop.Routes : [];
              routesArray.forEach(routeInfo => {
                  const candidateRouteId = Number(routeInfo?.RouteID ?? routeInfo?.RouteId ?? routeInfo?.Id);
                  if (!Number.isNaN(candidateRouteId)) {
                      entry.routeIds.add(candidateRouteId);
                  }
              });

              const routeIdsList = Array.isArray(stop.RouteIDs ?? stop.RouteIds)
                  ? (stop.RouteIDs ?? stop.RouteIds)
                  : [];
              routeIdsList.forEach(routeIdValue => {
                  const numericRouteId = Number(routeIdValue);
                  if (!Number.isNaN(numericRouteId)) {
                      entry.routeIds.add(numericRouteId);
                  }
              });
          });

          return Array.from(entriesByKey.values()).map(entry => ({
              addressId: entry.addressId,
              routeStopIds: Array.from(entry.routeStopIds),
              stopIdText: Array.from(entry.stopIds).join(', '),
              displayName: entry.names.size > 0 ? Array.from(entry.names).join(' / ') : 'Stop',
              routeIds: Array.from(entry.routeIds)
          }));
      }

      function collectRouteIdsForEntry(entry) {
          const routeIds = new Set();
          if (!entry) {
              return routeIds;
          }
          const addRouteId = value => {
              if (Array.isArray(value)) {
                  value.forEach(innerValue => addRouteId(innerValue));
                  return;
              }
              if (value === undefined || value === null) {
                  return;
              }
              let candidate = value;
              if (typeof candidate === 'string') {
                  candidate = candidate.trim();
                  if (candidate === '') {
                      return;
                  }
              }
              const numeric = Number(candidate);
              if (!Number.isNaN(numeric)) {
                  routeIds.add(numeric);
              }
          };
          if (Array.isArray(entry.routeIds)) {
              entry.routeIds.forEach(routeId => addRouteId(routeId));
          }
          if (Array.isArray(entry.routeStopIds)) {
              entry.routeStopIds.forEach(routeStopId => {
                  const mapped = routeStopRouteMap[routeStopId];
                  addRouteId(mapped);
              });
          }
          return routeIds;
      }

      function collectRouteIdsForStop(stop) {
          const routeIds = new Set();
          if (!stop) {
              return routeIds;
          }

          const addRouteId = value => {
              if (Array.isArray(value)) {
                  value.forEach(innerValue => addRouteId(innerValue));
                  return;
              }
              if (value === undefined || value === null) {
                  return;
              }
              let candidate = value;
              if (typeof candidate === 'string') {
                  candidate = candidate.trim();
                  if (candidate === '') {
                      return;
                  }
              }
              const numericRouteId = Number(candidate);
              if (!Number.isNaN(numericRouteId)) {
                  routeIds.add(numericRouteId);
              }
          };

          addRouteId(stop.RouteID ?? stop.RouteId);

          const routeStopId = normalizeIdentifier(stop.RouteStopID ?? stop.RouteStopId);
          if (routeStopId) {
              addRouteId(routeStopRouteMap[routeStopId]);
          }

          const routeIdsList = Array.isArray(stop.RouteIDs ?? stop.RouteIds)
              ? (stop.RouteIDs ?? stop.RouteIds)
              : [];
          routeIdsList.forEach(routeIdValue => addRouteId(routeIdValue));

          const routesArray = Array.isArray(stop.Routes) ? stop.Routes : [];
          routesArray.forEach(routeInfo => {
              addRouteId(routeInfo?.RouteID ?? routeInfo?.RouteId ?? routeInfo?.Id ?? routeInfo);
          });

          const singleRoute = stop.Route ?? stop.route;
          if (singleRoute && typeof singleRoute === 'object') {
              addRouteId(singleRoute.RouteID ?? singleRoute.RouteId ?? singleRoute.Id);
          }

          return routeIds;
      }

      function buildStopMarkerGradient(routeIds) {
          const colors = Array.from(new Set((Array.isArray(routeIds) ? routeIds : [])
              .map(routeId => getRouteColor(routeId))
              .filter(color => typeof color === 'string' && color.trim() !== '')));

          if (colors.length === 0) {
              return '#FFFFFF';
          }
          if (colors.length === 1) {
              return colors[0];
          }

          const segmentSize = 360 / colors.length;
          const segments = colors.map((color, index) => {
              const start = segmentSize * index;
              const end = segmentSize * (index + 1);
              return `${color} ${start}deg ${end}deg`;
          });
          return `conic-gradient(${segments.join(', ')})`;
      }

      function createStopMarkerIcon(routeIds) {
          const gradient = buildStopMarkerGradient(routeIds);
          const size = STOP_MARKER_ICON_SIZE;
          const outline = Math.max(0, Number(STOP_MARKER_OUTLINE_WIDTH) || 0);
          const html = `<div class="stop-marker-outer" style="--stop-marker-size:${size}px;--stop-marker-border-color:${STOP_MARKER_BORDER_COLOR};--stop-marker-outline-size:${outline}px;--stop-marker-outline-color:${STOP_MARKER_OUTLINE_COLOR};--stop-marker-gradient:${gradient};"></div>`;
          return L.divIcon({
              className: 'stop-marker-container leaflet-div-icon',
              html,
              iconSize: [size, size],
              iconAnchor: [size / 2, size / 2]
          });
      }

      function createStopGroupKey(routeStopIds, fallbackStopIdText) {
          const normalizedIds = Array.isArray(routeStopIds)
              ? Array.from(new Set(routeStopIds
                  .map(id => `${id}`)
                  .map(value => value.trim())
                  .filter(value => value !== '' && value.toLowerCase() !== 'undefined' && value.toLowerCase() !== 'null')))
                  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
              : [];
          return `${JSON.stringify(normalizedIds)}|${fallbackStopIdText || ''}`;
      }

      function sanitizeCssColor(color) {
          if (typeof color !== 'string') {
              return '';
          }
          let trimmed = color.trim();
          if (trimmed.length === 0) {
              return '';
          }
          if (/^#[0-9a-fA-F]{3,8}$/.test(trimmed)) {
              return trimmed;
          }
          if (/^[0-9a-fA-F]{3,8}$/.test(trimmed)) {
              return `#${trimmed}`;
          }
          if (/^rgba?\(\s*\d+(?:\.\d+)?\s*,\s*\d+(?:\.\d+)?\s*,\s*\d+(?:\.\d+)?(?:\s*,\s*(?:0|1|0?\.\d+))?\s*\)$/i.test(trimmed)) {
              return trimmed.replace(/\s+/g, ' ');
          }
          if (/^hsla?\(\s*\d+(?:\.\d+)?(?:deg|rad|turn)?\s*,\s*\d+(?:\.\d+)?%\s*,\s*\d+(?:\.\d+)?%(?:\s*,\s*(?:0|1|0?\.\d+))?\s*\)$/i.test(trimmed)) {
              return trimmed.replace(/\s+/g, ' ');
          }
          if (/^[a-zA-Z]+$/.test(trimmed)) {
              return trimmed;
          }
          return '';
      }

      function getColorWithAlpha(color, alpha) {
          const safeAlpha = Math.min(1, Math.max(0, Number(alpha) || 0));
          if (typeof color !== 'string' || color.trim() === '') {
              return `rgba(0, 0, 0, ${safeAlpha})`;
          }

          const trimmed = color.trim();
          if (trimmed.startsWith('#')) {
              let hex = trimmed.slice(1);
              if (hex.length === 3 || hex.length === 4) {
                  hex = hex.split('').map(char => char + char).join('');
              }
              if (hex.length === 6 || hex.length === 8) {
                  const r = parseInt(hex.slice(0, 2), 16);
                  const g = parseInt(hex.slice(2, 4), 16);
                  const b = parseInt(hex.slice(4, 6), 16);
                  const baseAlpha = hex.length === 8 ? parseInt(hex.slice(6, 8), 16) / 255 : 1;
                  if ([r, g, b, baseAlpha].some(value => Number.isNaN(value))) {
                      return `rgba(0, 0, 0, ${safeAlpha})`;
                  }
                  const combinedAlpha = Math.round(Math.min(1, Math.max(0, baseAlpha * safeAlpha)) * 1000) / 1000;
                  return `rgba(${r}, ${g}, ${b}, ${combinedAlpha})`;
              }
          } else {
              const rgbaMatch = trimmed.match(/rgba?\(([^)]+)\)/i);
              if (rgbaMatch) {
                  const parts = rgbaMatch[1].split(',').map(part => part.trim());
                  if (parts.length >= 3) {
                      const r = parseFloat(parts[0]);
                      const g = parseFloat(parts[1]);
                      const b = parseFloat(parts[2]);
                      if ([r, g, b].some(value => Number.isNaN(value))) {
                          return `rgba(0, 0, 0, ${safeAlpha})`;
                      }
                      let baseAlpha = parts.length >= 4 ? parseFloat(parts[3]) : 1;
                      if (Number.isNaN(baseAlpha)) {
                          baseAlpha = 1;
                      }
                      const combinedAlpha = Math.round(Math.min(1, Math.max(0, baseAlpha * safeAlpha)) * 1000) / 1000;
                      return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${combinedAlpha})`;
                  }
              }
          }

          return `rgba(0, 0, 0, ${safeAlpha})`;
      }

      function areStopArrivalsSupported() {
          return !isEtaSpotAgency();
      }

      function getNoArrivalDataMessage() {
          return areStopArrivalsSupported()
              ? 'No upcoming arrivals'
              : 'Real-time arrivals unavailable';
      }

      function buildEtaTableHtml(routeStopIds) {
          const normalizedRouteStopIds = Array.isArray(routeStopIds) ? routeStopIds : [];
          const etas = [];
          normalizedRouteStopIds.forEach(routeStopId => {
              if (cachedEtas[routeStopId]) {
                  cachedEtas[routeStopId].forEach(eta => etas.push(eta));
              }
          });
          const noArrivalMessage = getNoArrivalDataMessage();
          const etaRows = etas.length > 0
              ? etas.sort((a, b) => a.etaMinutes - b.etaMinutes || a.routeDescription.localeCompare(b.routeDescription))
                    .map(eta => {
                        const routeColor = getRouteColor(eta.RouteId);
                        const textColor = contrastBW(routeColor);
                        const shadowColor = getColorWithAlpha(routeColor, 0.35);
                        return `<tr><td style="padding: 5px; text-align: center;"><div class="route-pill" style="background: ${routeColor}; color: ${textColor}; --route-pill-shadow-color: ${shadowColor};">${eta.routeDescription}</div></td><td style="padding: 5px; text-align: center;">${eta.etaMinutes < 1 ? 'Arriving' : eta.etaMinutes + ' min'}</td></tr>`;
                    })
                    .join('')
              : `<tr><td colspan="2" style="padding: 5px; text-align: center;">${noArrivalMessage}</td></tr>`;
          return `
            <table style="width: 100%; margin-top: 10px; border-collapse: collapse;">
              <thead>
                <tr>
                  <th style="border-bottom: 1px solid white; padding: 5px;">Route</th>
                  <th style="border-bottom: 1px solid white; padding: 5px;">ETA</th>
                </tr>
              </thead>
              <tbody>
                ${etaRows}
              </tbody>
            </table>
          `;
      }

      function buildStopEntriesSectionHtml(stopEntries, multipleStops) {
          const noArrivalMessage = getNoArrivalDataMessage();
          if (!Array.isArray(stopEntries) || stopEntries.length === 0) {
              return `<div style="margin-top: 10px;">${noArrivalMessage}</div>`;
          }

          if (!multipleStops) {
              const entry = stopEntries[0];
              return buildEtaTableHtml(entry?.routeStopIds || []);
          }

          return stopEntries.map(entry => {
              const entryTitle = entry.displayName ? `<span class="stop-entry-title">${sanitizeStopName(entry.displayName)}</span>` : '';
              const entryIdLine = entry.stopIdText ? `<span class="stop-entry-id">Stop ID: ${entry.stopIdText}</span>` : '';
              const entryAddressIdText = normalizeIdentifier(entry?.addressId);
              const entryAddressLine = entryAddressIdText ? `<span class="stop-entry-id">Stop ID: ${entryAddressIdText}</span>` : '';
              const tableHtml = buildEtaTableHtml(entry.routeStopIds || []);
              return `<div class="stop-entry">${entryTitle}${entryIdLine}${entryAddressLine}${tableHtml}</div>`;
          }).join('');
      }

      function attachPopupCloseHandler(popupElement) {
          const closeButton = popupElement.querySelector('.custom-popup-close');
          if (!closeButton) {
              return;
          }
          closeButton.addEventListener('click', () => {
              popupElement.remove();
              customPopups = customPopups.filter(popup => popup !== popupElement);
          });
      }

      function setStopPopupContent(popupElement, groupInfo) {
          if (!popupElement || !groupInfo) {
              return;
          }

          popupElement.dataset.popupType = 'stop';
          const stopEntries = Array.isArray(groupInfo.stopEntries) ? groupInfo.stopEntries : [];
          const aggregatedRouteStopIds = Array.isArray(groupInfo.aggregatedRouteStopIds)
              ? groupInfo.aggregatedRouteStopIds
              : [];
          const fallbackStopIdText = typeof groupInfo.fallbackStopId === 'string'
              ? groupInfo.fallbackStopId
              : normalizeIdentifier(groupInfo.fallbackStopId) || '';
          const sanitizedStopName = sanitizeStopName(groupInfo.stopName || '');
          const multipleStops = stopEntries.length > 1;
          const primaryStopIdText = !multipleStops
              ? (stopEntries[0]?.stopIdText || fallbackStopIdText)
              : '';
          const entriesHtml = buildStopEntriesSectionHtml(stopEntries, multipleStops);
          const groupKey = groupInfo.groupKey || createStopGroupKey(aggregatedRouteStopIds, fallbackStopIdText);
          const primaryAddressIdText = !multipleStops
              ? normalizeIdentifier(stopEntries[0]?.addressId)
              : '';

          popupElement.dataset.routeStopIds = JSON.stringify(aggregatedRouteStopIds);
          popupElement.dataset.stopEntries = JSON.stringify(stopEntries);
          popupElement.dataset.stopName = sanitizedStopName;
          popupElement.dataset.fallbackStopId = fallbackStopIdText;
          popupElement.dataset.stopId = primaryStopIdText || '';
          popupElement.dataset.addressId = primaryAddressIdText || '';
          popupElement.dataset.groupKey = groupKey;

          const stopNameLine = (!multipleStops && sanitizedStopName)
              ? `<span class="stop-entry-title">${sanitizedStopName}</span><br>`
              : '';
          const addressIdLine = primaryAddressIdText ? `<span class="stop-entry-id">Address ID: ${primaryAddressIdText}</span><br>` : '';
          const stopIdLine = primaryStopIdText ? `<span class="stop-entry-id">Stop ID: ${primaryStopIdText}</span><br>` : '';

          popupElement.innerHTML = `
            <button class="custom-popup-close">&times;</button>
            ${stopNameLine}
            ${addressIdLine}
            ${stopIdLine}
            ${entriesHtml}
            <div class="custom-popup-arrow"></div>
          `;

          attachPopupCloseHandler(popupElement);
      }

      function getIncidentLocationText(incident) {
          if (!incident) return '';
          const candidates = [
              incident.FullDisplayAddress,
              incident.DisplayAddress,
              incident.Address,
              incident.AddressName,
              incident.IncidentAddress,
              incident.LocationDescription,
              incident.Location,
              incident.CrossStreet,
              incident.Intersection,
              incident.NearestIntersection,
              incident.CommonName,
              incident.CommonLocation
          ];
          for (const value of candidates) {
              if (typeof value !== 'string') continue;
              const trimmed = value.trim();
              if (trimmed) {
                  return trimmed;
              }
          }
          return '';
      }

      function setIncidentPopupContent(popupElement, config) {
          if (!popupElement) {
              return;
          }

          popupElement.dataset.popupType = 'incident';
          const incident = config && config.incident ? config.incident : null;
          const idValue = typeof config?.id === 'string'
              ? config.id
              : (typeof config?.incidentId === 'string' ? config.incidentId : '');
          if (idValue) {
              popupElement.dataset.incidentId = idValue;
          } else {
              delete popupElement.dataset.incidentId;
          }

          if (!incident) {
              popupElement.innerHTML = `
                <button class="custom-popup-close">&times;</button>
                <div class="incident-popup">
                  <div>Incident information is unavailable.</div>
                </div>
                <div class="custom-popup-arrow"></div>
              `;
              attachPopupCloseHandler(popupElement);
              return;
          }

          const typeLabel = getIncidentTypeLabel(incident) || 'Incident';
          const safeTypeLabel = escapeHtml(typeLabel);
          const iconUrl = buildPulsePointListIconUrl(getIncidentTypeCode(incident));
          const iconAlt = typeLabel ? `${typeLabel} icon` : 'Incident icon';
          const iconHtml = iconUrl
              ? `<div class="incident-popup__icon"><img src="${escapeAttribute(iconUrl)}" alt="${escapeAttribute(iconAlt)}" onerror="this.style.display='none';"></div>`
              : `<div class="incident-popup__icon"><span class="incident-popup__icon-fallback">${escapeHtml((typeLabel || 'I').charAt(0))}</span></div>`;

          const timeInfo = getIncidentReceivedTimeInfo(incident);
          const receivedLine = timeInfo
              ? `<div class="incident-popup__meta-line" title="${escapeAttribute(timeInfo.full)}">Received ${escapeHtml(timeInfo.display)}</div>`
              : '';
          const statusCandidates = [incident.Status, incident.IncidentStatus, incident.Stage];
          let statusText = '';
          for (const value of statusCandidates) {
              if (typeof value !== 'string') continue;
              const trimmed = value.trim();
              if (trimmed) {
                  statusText = trimmed;
                  break;
              }
          }
          const statusLine = statusText
              ? `<div class="incident-popup__meta-line">Status: ${escapeHtml(statusText)}</div>`
              : '';
          const locationText = getIncidentLocationText(incident);
          const locationLine = locationText
              ? `<div class="incident-popup__meta-line">Location: ${escapeHtml(locationText)}</div>`
              : '';
          const metaLines = [receivedLine, statusLine, locationLine].filter(Boolean).join('');
          const metaHtml = metaLines ? `<div class="incident-popup__meta">${metaLines}</div>` : '';

          const routes = Array.isArray(config?.routes) ? config.routes : [];
          const routeBadges = Array.isArray(routes)
              ? routes
                  .map(route => {
                      if (!route) return '';
                      if (typeof route === 'string') {
                          const trimmed = route.trim();
                          if (!trimmed) return '';
                          return `<span class="incident-popup__route">${escapeHtml(trimmed)}</span>`;
                      }
                      const nameCandidates = [route.name, route.RouteName, route.Description, route.Label];
                      let routeName = '';
                      for (const value of nameCandidates) {
                          if (typeof value !== 'string') continue;
                          const trimmed = value.trim();
                          if (trimmed) {
                              routeName = trimmed;
                              break;
                          }
                      }
                      if (!routeName) return '';
                      const colorCandidates = [route.color, route.Color, route.routeColor, route.RouteColor, route.fillColor, route.FillColor];
                      let routeColor = '';
                      for (const candidate of colorCandidates) {
                          const sanitized = sanitizeCssColor(candidate);
                          if (sanitized) {
                              routeColor = sanitized;
                              break;
                          }
                      }
                      if (!routeColor) {
                          const idCandidates = [route.routeId, route.RouteId, route.RouteID];
                          for (const idCandidate of idCandidates) {
                              if (idCandidate === undefined || idCandidate === null) continue;
                              const directColor = sanitizeCssColor(routeColors ? routeColors[idCandidate] : '');
                              if (directColor) {
                                  routeColor = directColor;
                                  break;
                              }
                              const numericId = Number(idCandidate);
                              if (!Number.isFinite(numericId)) continue;
                              const numericColor = sanitizeCssColor(routeColors ? routeColors[numericId] : '');
                              if (numericColor) {
                                  routeColor = numericColor;
                                  break;
                              }
                              const storedRoute = allRoutes ? (allRoutes[numericId] || allRoutes[`${numericId}`] || null) : null;
                              if (storedRoute) {
                                  const storedColor = sanitizeCssColor(storedRoute.MapLineColor || storedRoute.Color || storedRoute.RouteColor);
                                  if (storedColor) {
                                      routeColor = storedColor;
                                      break;
                                  }
                              }
                          }
                      }
                      const styleParts = [];
                      if (routeColor) {
                          styleParts.push(`background:${escapeAttribute(routeColor)}`);
                          styleParts.push(`border-color:${escapeAttribute(routeColor)}`);
                          const textColor = contrastBW(routeColor);
                          if (textColor) {
                              styleParts.push(`color:${escapeAttribute(textColor)}`);
                          }
                          const shadowColor = getColorWithAlpha(routeColor, 0.35);
                          if (shadowColor) {
                              styleParts.push(`box-shadow:0 10px 24px ${escapeAttribute(shadowColor)}`);
                          }
                      }
                      const styleAttr = styleParts.length ? ` style="${styleParts.join(';')}"` : '';
                      return `<span class="incident-popup__route"${styleAttr}>${escapeHtml(routeName)}</span>`;
                  })
                  .filter(Boolean)
              : [];
          const routesHtml = routeBadges.length
              ? `<div class="incident-popup__section"><div class="incident-popup__section-title">Routes Nearby</div><div class="incident-popup__routes-list">${routeBadges.join('')}</div></div>`
              : '';

          const units = extractIncidentUnits(incident);
          const unitsHtml = renderIncidentPopupUnitsSection(units);

          popupElement.innerHTML = `
            <button class="custom-popup-close">&times;</button>
            <div class="incident-popup">
              <div class="incident-popup__header">
                ${iconHtml}
                <div class="incident-popup__details">
                  <div class="incident-popup__title">${safeTypeLabel}</div>
                  ${metaHtml}
                </div>
              </div>
              ${routesHtml}
              ${unitsHtml}
            </div>
            <div class="custom-popup-arrow"></div>
          `;

          attachPopupCloseHandler(popupElement);
      }

      function getIncidentPopupElementById(id) {
          const normalizedId = getNormalizedIncidentId(id);
          if (!normalizedId) {
              return null;
          }
          for (const popupElement of customPopups) {
              if (!popupElement) continue;
              if (popupElement.dataset.popupType !== 'incident') continue;
              const popupId = popupElement.dataset.incidentId || '';
              if (popupId && getNormalizedIncidentId(popupId) === normalizedId) {
                  return popupElement;
              }
          }
          return null;
      }

      function buildIncidentPopupConfig(id) {
          const normalizedId = getNormalizedIncidentId(id);
          if (!normalizedId) {
              return null;
          }
          const entry = incidentMarkers.get(normalizedId);
          if (!entry || !entry.marker || typeof entry.marker.getLatLng !== 'function') {
              return null;
          }
          const latLng = entry.marker.getLatLng();
          if (!latLng) {
              return null;
          }
          const lat = Number(latLng.lat);
          const lng = Number(latLng.lng);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
              return null;
          }
          const routesEntry = incidentsNearRoutesLookup.get(normalizedId);
          const routes = routesEntry && Array.isArray(routesEntry.routes) ? routesEntry.routes : [];
          return {
              popupType: 'incident',
              position: [lat, lng],
              incident: entry.data || null,
              id: normalizedId,
              routes
          };
      }

      function refreshIncidentPopup(id) {
          const popupElement = getIncidentPopupElementById(id);
          if (!popupElement) {
              return;
          }
          const config = buildIncidentPopupConfig(id);
          if (!config) {
              popupElement.remove();
              customPopups = customPopups.filter(popup => popup !== popupElement);
              return;
          }
          popupElement.dataset.position = `${config.position[0]},${config.position[1]}`;
          setIncidentPopupContent(popupElement, config);
          updatePopupPosition(popupElement, config.position);
      }

      function refreshOpenIncidentPopups() {
          const ids = customPopups
              .filter(popupElement => popupElement && popupElement.dataset.popupType === 'incident')
              .map(popupElement => popupElement.dataset.incidentId || '')
              .filter(Boolean);
          ids.forEach(id => {
              refreshIncidentPopup(id);
          });
      }

      function removeIncidentPopupById(id) {
          const popupElement = getIncidentPopupElementById(id);
          if (!popupElement) {
              return;
          }
          popupElement.remove();
          customPopups = customPopups.filter(popup => popup !== popupElement);
      }

      function removeAllIncidentPopups() {
          customPopups = customPopups.filter(popupElement => {
              if (!popupElement) {
                  return false;
              }
              if (popupElement.dataset.popupType === 'incident') {
                  popupElement.remove();
                  return false;
              }
              return true;
          });
      }

      function renderBusStops(stopsArray) {
          if (!Array.isArray(stopsArray) || !map) {
              return;
          }

          stopMarkers.forEach(marker => map.removeLayer(marker));
          stopMarkers = [];

          const selectedRouteIdsSet = getSelectedRouteIdSet();

          const stopsForSelectedRoutes = selectedRouteIdsSet.size > 0
              ? stopsArray.filter(stop => {
                  const routeIds = collectRouteIdsForStop(stop);
                  if (routeIds.size === 0) {
                      return false;
                  }
                  for (const routeId of routeIds) {
                      if (selectedRouteIdsSet.has(routeId)) {
                          return true;
                      }
                  }
                  return false;
              })
              : [];

          const groupedStops = groupStopsByPixelDistance(stopsForSelectedRoutes, STOP_GROUPING_PIXEL_DISTANCE);
          const groupedData = [];

          groupedStops.forEach(group => {
              const stopEntries = buildStopEntriesFromStops(group.stops);
              if (stopEntries.length === 0) {
                  return;
              }

              const allRouteIdsForMarker = new Set();
              stopEntries.forEach(entry => {
                  collectRouteIdsForEntry(entry).forEach(routeId => {
                      if (!Number.isNaN(routeId)) {
                          allRouteIdsForMarker.add(routeId);
                      }
                  });
              });

              if (allRouteIdsForMarker.size === 0) {
                  group.stops.forEach(stop => {
                      collectRouteIdsForStop(stop).forEach(routeId => {
                          allRouteIdsForMarker.add(routeId);
                      });
                  });
              }

              const servesSelectedRoute = selectedRouteIdsSet.size > 0
                  ? Array.from(allRouteIdsForMarker).some(routeId => selectedRouteIdsSet.has(routeId))
                  : false;

              if (!servesSelectedRoute) {
                  return;
              }

              const stopPosition = [group.latitude, group.longitude];
              const aggregatedRouteStopIds = Array.from(new Set(stopEntries.flatMap(entry => entry.routeStopIds)))
                  .map(id => `${id}`)
                  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
              const fallbackStopIdSet = new Set();
              stopEntries.forEach(entry => {
                  if (typeof entry.stopIdText === 'string' && entry.stopIdText.trim() !== '') {
                      entry.stopIdText.split(',').forEach(value => {
                          const trimmed = value.trim();
                          if (trimmed) {
                              fallbackStopIdSet.add(trimmed);
                          }
                      });
                  }
              });
              const fallbackStopIdText = Array.from(fallbackStopIdSet)
                  .sort((a, b) => a.localeCompare(b, undefined, { numeric: true }))
                  .join(', ');
              const displayStopName = Array.from(new Set(stopEntries
                  .map(entry => sanitizeStopName(entry.displayName))
                  .filter(Boolean)))
                  .join(' / ') || 'Stop';
              const groupKey = createStopGroupKey(aggregatedRouteStopIds, fallbackStopIdText);
              const markerRouteIds = Array.from(allRouteIdsForMarker)
                  .filter(routeId => selectedRouteIdsSet.has(routeId))
                  .sort((a, b) => a - b);
              const markerIcon = createStopMarkerIcon(markerRouteIds);

              const groupInfo = {
                  position: stopPosition,
                  stopName: displayStopName,
                  fallbackStopId: fallbackStopIdText,
                  stopEntries,
                  aggregatedRouteStopIds,
                  groupKey
              };

              const stopMarker = L.marker(stopPosition, {
                  icon: markerIcon,
                  pane: 'stopsPane'
              }).addTo(map);

              stopMarker.on('click', () => {
                  createCustomPopup(Object.assign({ popupType: 'stop' }, groupInfo));
              });

              stopMarkers.push(stopMarker);
              groupedData.push(groupInfo);
          });

          stopMarkers.forEach(marker => {
              if (!marker) return;
              if (typeof marker.bringToFront === 'function') {
                  marker.bringToFront();
                  return;
              }
              if (typeof marker.setZIndexOffset === 'function') {
                  marker.setZIndexOffset(1000);
              }
          });

          if (customPopups.length > 0) {
              const groupByKey = new Map();
              groupedData.forEach(groupInfo => {
                  groupByKey.set(groupInfo.groupKey, groupInfo);
              });

              customPopups = customPopups.filter(popupElement => {
                  if (!popupElement) {
                      return false;
                  }
                  if (popupElement.dataset.popupType === 'incident') {
                      return true;
                  }
                  let parsedRouteStopIds = [];
                  try {
                      parsedRouteStopIds = JSON.parse(popupElement.dataset.routeStopIds || '[]');
                  } catch (error) {
                      parsedRouteStopIds = [];
                  }
                  const fallbackId = popupElement.dataset.fallbackStopId || '';
                  const key = popupElement.dataset.groupKey || createStopGroupKey(parsedRouteStopIds, fallbackId);
                  const matchingGroup = groupByKey.get(key);
                  if (matchingGroup) {
                      popupElement.dataset.position = `${matchingGroup.position[0]},${matchingGroup.position[1]}`;
                      setStopPopupContent(popupElement, matchingGroup);
                      updatePopupPosition(popupElement, matchingGroup.position);
                      return true;
                  }
                  popupElement.remove();
                  return false;
              });
          }
      }

      function createCustomPopup(config) {
          if (!config || !Array.isArray(config.position) || config.position.length !== 2) {
              return;
          }
          const popupType = typeof config.popupType === 'string' ? config.popupType : 'stop';
          const position = config.position;
          customPopups.forEach(popup => popup.remove());
          customPopups = [];
          const popupElement = document.createElement('div');
          popupElement.className = 'custom-popup';
          document.body.appendChild(popupElement);
          popupElement.dataset.position = `${position[0]},${position[1]}`;
          popupElement.dataset.popupType = popupType;
          if (popupType === 'incident') {
              setIncidentPopupContent(popupElement, config);
          } else {
              setStopPopupContent(popupElement, config);
          }
          updatePopupPosition(popupElement, position);
          customPopups.push(popupElement);
          if (typeof requestAnimationFrame === 'function') {
              requestAnimationFrame(() => centerPopupOnMap(popupElement));
          } else {
              centerPopupOnMap(popupElement);
          }
      }

      function updatePopupPosition(popupElement, position) {
          if (!map || typeof map?.latLngToContainerPoint !== 'function') {
              return;
          }
          const mapPos = map.latLngToContainerPoint(position);
          popupElement.style.left = `${mapPos.x}px`;
          popupElement.style.top = `${mapPos.y}px`;
      }

      function centerPopupOnMap(popupElement) {
          if (!popupElement || !map || typeof map?.panBy !== 'function') {
              return;
          }
          const mapContainer = typeof map.getContainer === 'function' ? map.getContainer() : null;
          if (!mapContainer) {
              return;
          }
          const mapRect = mapContainer.getBoundingClientRect();
          const popupRect = popupElement.getBoundingClientRect();
          if (mapRect.width === 0 || mapRect.height === 0 || popupRect.width === 0 || popupRect.height === 0) {
              return;
          }
          const mapCenterX = mapRect.width / 2;
          const mapCenterY = mapRect.height / 2;
          const popupCenterX = (popupRect.left - mapRect.left) + (popupRect.width / 2);
          const popupCenterY = (popupRect.top - mapRect.top) + (popupRect.height / 2);
          const deltaX = popupCenterX - mapCenterX;
          const deltaY = popupCenterY - mapCenterY;
          if (Math.abs(deltaX) < 1 && Math.abs(deltaY) < 1) {
              return;
          }
          map.panBy([deltaX, deltaY], { animate: true, duration: 0.35, easeLinearity: 0.25 });
      }

      function updatePopupPositions() {
          if (!map || typeof map?.latLngToContainerPoint !== 'function') {
              return;
          }
          const zooming = !!(map?._animatingZoom || (map?._zoomAnimated && map?._zooming));
          if (zooming) {
              return;
          }
          customPopups.forEach(popupElement => {
              const position = popupElement.dataset.position;
              if (position) {
                  const [latitude, longitude] = position.split(',').map(Number);
                  updatePopupPosition(popupElement, [latitude, longitude]);
              }
          });
      }

      function updateCustomPopups() {
          customPopups.forEach(popupElement => {
              if (!popupElement) {
                  return;
              }
              if (popupElement.dataset.popupType === 'incident') {
                  const popupId = popupElement.dataset.incidentId || '';
                  if (popupId) {
                      refreshIncidentPopup(popupId);
                  }
                  return;
              }
              const position = popupElement.dataset.position;
              if (position) {
                  let routeStopIds = [];
                  let stopEntries = [];
                  try {
                      routeStopIds = JSON.parse(popupElement.dataset.routeStopIds || '[]');
                  } catch (error) {
                      routeStopIds = [];
                  }
                  try {
                      stopEntries = JSON.parse(popupElement.dataset.stopEntries || '[]');
                  } catch (error) {
                      stopEntries = [];
                  }
                  const fallbackStopId = popupElement.dataset.fallbackStopId || '';
                  const stopName = popupElement.dataset.stopName || '';
                  const groupKey = popupElement.dataset.groupKey || createStopGroupKey(routeStopIds, fallbackStopId);
                  const groupInfo = {
                      position: position.split(',').map(Number),
                      stopName,
                      fallbackStopId,
                      stopEntries,
                      aggregatedRouteStopIds: routeStopIds,
                      groupKey
                  };
                  setStopPopupContent(popupElement, groupInfo);
              }
          });
      }

      function fetchStopArrivalTimes() {
          if (!areStopArrivalsSupported()) {
              return Promise.resolve({});
          }
          return fetchStopArrivalTimesRideSystems();
      }

      function fetchStopArrivalTimesRideSystems() {
          const currentBaseURL = baseURL;
          const arrivalTimesApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetStopArrivalTimes?APIKey=8882812681`;
          return fetch(arrivalTimesApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return {};
                  const allEtas = {};
                  const records = Array.isArray(data?.StopArrivalTimes) ? data.StopArrivalTimes : (Array.isArray(data) ? data : []);
                  records.forEach(arrival => {
                      const routeStopId = arrival?.RouteStopId ?? arrival?.RouteStopID;
                      if (routeStopId === undefined || routeStopId === null) {
                          return;
                      }
                      if (!allEtas[routeStopId]) {
                          allEtas[routeStopId] = [];
                      }
                      const times = Array.isArray(arrival?.Times) ? arrival.Times : [];
                      times.forEach(time => {
                          const etaMinutes = Number.isFinite(time?.Seconds) ? Math.max(0, Math.round(time.Seconds / 60)) : null;
                          allEtas[routeStopId].push({
                              routeDescription: arrival?.RouteDescription ?? arrival?.RouteLongName ?? arrival?.RouteName ?? '',
                              etaMinutes,
                              RouteId: arrival?.RouteId ?? arrival?.RouteID
                          });
                      });
                  });
                  return allEtas;
              })
              .catch(error => {
                  console.error('Error fetching stop arrival times:', error);
                  return {};
              });
      }


      class OverlapRouteRenderer {
        constructor(map, options = {}) {
          this.map = map;
          this.options = Object.assign({
            sampleStepPx: 8,
            dashLengthPx: 16,
            minDashLengthPx: 0.5,
            matchTolerancePx: 6,
            headingToleranceDeg: 20,
            simplifyTolerancePx: 0.75,
            latLngEqualityMargin: 1e-9,
            strokeWeight: DEFAULT_ROUTE_STROKE_WEIGHT,
            minStrokeWeight: MIN_ROUTE_STROKE_WEIGHT,
            maxStrokeWeight: MAX_ROUTE_STROKE_WEIGHT
          }, options);
          this.layers = [];
          this.routeGeometries = new Map();
          this.selectedRoutes = [];
          this.currentZoom = typeof map?.getZoom === 'function' ? map.getZoom() : null;
          this.renderer = options.renderer || null;
          this.routePaneName = typeof options.pane === 'string' && options.pane ? options.pane : routePaneName;
        }

        reset() {
          this.clearLayers();
          this.routeGeometries.clear();
          this.selectedRoutes = [];
        }

        clearLayers() {
          this.layers.forEach(layer => {
            if (layer && this.map.hasLayer(layer)) {
              this.map.removeLayer(layer);
            }
          });
          this.layers = [];
        }

        updateRoutes(routeGeometryMap, selectedRouteIds) {
          if (!Array.isArray(selectedRouteIds) || selectedRouteIds.length === 0) {
            this.reset();
            return this.getLayers();
          }

          const geometryEntries = routeGeometryMap instanceof Map
            ? Array.from(routeGeometryMap.entries())
            : Object.entries(routeGeometryMap || {});

          const desiredIds = new Set(
            selectedRouteIds
              .map(id => Number(id))
              .filter(id => !Number.isNaN(id))
          );

          const nextGeometries = new Map();
          geometryEntries.forEach(([key, value]) => {
            const numericKey = Number(key);
            if (!Number.isNaN(numericKey) && desiredIds.has(numericKey) && Array.isArray(value)) {
              nextGeometries.set(numericKey, value);
            }
          });

          this.routeGeometries = nextGeometries;
          this.selectedRoutes = Array.from(this.routeGeometries.keys()).sort((a, b) => a - b);

          const mapZoom = typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null;
          if (Number.isFinite(mapZoom)) {
            this.currentZoom = mapZoom;
          }

          this.render();
          return this.getLayers();
        }

        handleZoomFrame(targetZoom) {
          if (this.routeGeometries.size === 0 || this.selectedRoutes.length === 0) {
            return this.getLayers();
          }

          const zoom = Number.isFinite(targetZoom)
            ? targetZoom
            : (typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null);
          if (!Number.isFinite(zoom)) {
            return this.getLayers();
          }

          this.currentZoom = zoom;
          this.render();
          return this.getLayers();
        }

        handleZoomEnd() {
          const zoom = typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null;
          return this.handleZoomFrame(zoom);
        }

        getLayers() {
          return this.layers.slice();
        }

        hasPersistentPixelCache() {
          return false;
        }

        computeStrokeWeight(zoom = this.currentZoom) {
          const minWeight = Number.isFinite(this.options.minStrokeWeight)
            ? this.options.minStrokeWeight
            : MIN_ROUTE_STROKE_WEIGHT;
          const maxWeight = Number.isFinite(this.options.maxStrokeWeight)
            ? this.options.maxStrokeWeight
            : MAX_ROUTE_STROKE_WEIGHT;
          const computed = computeRouteStrokeWeight(zoom);
          if (!Number.isFinite(computed)) {
            return Math.max(minWeight, Math.min(maxWeight, DEFAULT_ROUTE_STROKE_WEIGHT));
          }
          return Math.max(minWeight, Math.min(maxWeight, computed));
        }

        render() {
          if (!this.map) return;
          if (this.routeGeometries.size === 0 || this.selectedRoutes.length === 0) {
            this.clearLayers();
            return;
          }

          const zoom = Number.isFinite(this.currentZoom)
            ? this.currentZoom
            : (typeof this.map?.getZoom === 'function' ? this.map.getZoom() : null);
          if (!Number.isFinite(zoom)) {
            this.clearLayers();
            return;
          }

          this.clearLayers();

          const step = Number.isFinite(this.options.sampleStepPx) && this.options.sampleStepPx > 0
            ? this.options.sampleStepPx
            : 8;
          const tolerance = Number.isFinite(this.options.matchTolerancePx)
            ? this.options.matchTolerancePx
            : 6;
          const headingToleranceRad = (Number.isFinite(this.options.headingToleranceDeg)
            ? this.options.headingToleranceDeg
            : 20) * Math.PI / 180;

          const segmentsByRoute = new Map();
          const spatialItems = [];

          this.routeGeometries.forEach((latlngs, routeId) => {
            if (!Array.isArray(latlngs) || latlngs.length < 2) {
              return;
            }

            const segments = this.resampleRoute(routeId, latlngs, zoom, step);
            if (!Array.isArray(segments) || segments.length === 0) {
              return;
            }

            segmentsByRoute.set(routeId, segments);

            segments.forEach(segment => {
              spatialItems.push({
                minX: segment.bounds.minX - tolerance,
                minY: segment.bounds.minY - tolerance,
                maxX: segment.bounds.maxX + tolerance,
                maxY: segment.bounds.maxY + tolerance,
                segment
              });
            });
          });

          if (spatialItems.length === 0) {
            this.clearLayers();
            return;
          }

          const tree = createSpatialIndex({ maxEntries: this.options.maxEntries });
          if (!tree || typeof tree.load !== 'function' || typeof tree.search !== 'function') {
            console.error('RBush spatial index instance is invalid; skipping overlap rendering.');
            this.clearLayers();
            return;
          }

          tree.clear?.();
          tree.load(spatialItems);
          this.populateSharedRoutes(spatialItems, tree, tolerance, headingToleranceRad);

          const groups = this.buildGroups(segmentsByRoute, zoom);
          this.drawGroups(groups);
        }

        populateSharedRoutes(spatialItems, tree, tolerance, headingToleranceRad) {
          const processedPairs = new Set();

          spatialItems.forEach(item => {
            const segment = item.segment;
            if (!segment) return;

            const candidates = tree.search(item);
            candidates.forEach(candidate => {
              const other = candidate.segment;
              if (!other || other === segment) return;
              if (other.routeId === segment.routeId) return;

              const pairKey = segment.routeId < other.routeId
                ? `${segment.routeId}:${segment.index}|${other.routeId}:${other.index}`
                : `${other.routeId}:${other.index}|${segment.routeId}:${segment.index}`;
              if (processedPairs.has(pairKey)) return;

              processedPairs.add(pairKey);
              if (!this.segmentsOverlap(segment, other, tolerance, headingToleranceRad)) return;

              segment.sharedRoutes.add(other.routeId);
              other.sharedRoutes.add(segment.routeId);

              this.applyRouteOffset(segment, other);
              this.applyRouteOffset(other, segment);
            });
          });
        }

        applyRouteOffset(target, source) {
          if (!target || !source) return;
          if (!target.routeOffsets) {
            target.routeOffsets = {};
          }

          const sourceOffset = this.extractRouteOffset(source, source.routeId);
          if (!Number.isFinite(sourceOffset)) {
            return;
          }

          const existing = target.routeOffsets[source.routeId];
          const candidate = Number.isFinite(existing?.min) ? Math.min(existing.min, sourceOffset) : sourceOffset;
          target.routeOffsets[source.routeId] = { min: candidate };
        }

        extractRouteOffset(segment, routeId) {
          if (!segment) return null;
          const offsets = segment.routeOffsets || {};
          const direct = offsets[routeId];
          if (direct && Number.isFinite(direct.min)) {
            return direct.min;
          }

          const values = [];
          const startVal = Number(segment.start?.cumulativeLength);
          if (Number.isFinite(startVal)) values.push(startVal);
          const endVal = Number(segment.end?.cumulativeLength);
          if (Number.isFinite(endVal)) values.push(endVal);
          return values.length > 0 ? Math.min(...values) : null;
        }

        buildGroups(segmentsByRoute, zoom) {
          const groups = [];

          segmentsByRoute.forEach((segments, routeId) => {
            const ordered = segments.slice().sort((a, b) => {
              const aOffset = Number(a.start?.cumulativeLength) || 0;
              const bOffset = Number(b.start?.cumulativeLength) || 0;
              return aOffset - bOffset;
            });

            let current = null;

            ordered.forEach(segment => {
              const sharedRoutes = Array.from(segment.sharedRoutes || []).sort((a, b) => a - b);
              if (sharedRoutes.length === 0) return;

              const primary = sharedRoutes[0];
              if (primary !== routeId) {
                return;
              }

              const needsNewGroup = !current
                || !this.sameRouteSet(current.routes, sharedRoutes)
                || !this.latLngsClose(current.lastLatLng, segment.start.latlng);

              if (needsNewGroup) {
                if (current) {
                  const finalized = this.finalizeGroup(current, zoom);
                  if (finalized) {
                    groups.push(finalized);
                  }
                }

                current = {
                  routes: sharedRoutes,
                  segments: [],
                  points: [],
                  offsets: new Map(),
                  lastLatLng: null
                };
              }

              current.segments.push(segment);

              if (current.points.length === 0) {
                current.points.push(segment.start.latlng);
              } else if (!this.latLngsClose(current.points[current.points.length - 1], segment.start.latlng)) {
                current.points.push(segment.start.latlng);
              }
              current.points.push(segment.end.latlng);
              current.lastLatLng = segment.end.latlng;

              const routeOffsets = segment.routeOffsets || {};
              current.routes.forEach(routeKey => {
                const candidate = Number(routeOffsets?.[routeKey]?.min ?? routeOffsets?.[routeKey]);
                if (Number.isFinite(candidate)) {
                  const existing = current.offsets.get(routeKey);
                  if (!Number.isFinite(existing) || candidate < existing) {
                    current.offsets.set(routeKey, candidate);
                  }
                }
              });
            });

            if (current) {
              const finalized = this.finalizeGroup(current, zoom);
              if (finalized) {
                groups.push(finalized);
              }
              current = null;
            }
          });

          return groups;
        }

        finalizeGroup(group, zoom) {
          const points = this.collapsePoints(group.points || []);
          if (points.length < 2) {
            return null;
          }

          const lengthPx = group.segments.reduce((sum, segment) => {
            const value = Number(segment.lengthPx);
            return sum + (Number.isFinite(value) ? value : 0);
          }, 0);

          const primaryRoute = group.routes[0];
          const offsetCandidates = group.segments
            .map(segment => Number(segment.routeOffsets?.[primaryRoute]?.min ?? segment.routeOffsets?.[primaryRoute]))
            .filter(value => Number.isFinite(value));
          const offsetPx = offsetCandidates.length > 0 ? Math.min(...offsetCandidates) : 0;

          const offsetMap = new Map();
          group.offsets.forEach((value, key) => {
            if (Number.isFinite(value)) {
              offsetMap.set(key, value);
            }
          });

          return {
            routes: group.routes.slice(),
            points,
            lengthPx,
            offsetPx,
            routeOffsets: offsetMap
          };
        }

        collapsePoints(points) {
          const collapsed = [];
          points.forEach(point => {
            if (collapsed.length === 0 || !this.latLngsClose(collapsed[collapsed.length - 1], point)) {
              collapsed.push(point);
            }
          });
          return collapsed;
        }

        sameRouteSet(a, b) {
          if (!Array.isArray(a) || !Array.isArray(b)) return false;
          if (a.length !== b.length) return false;
          for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false;
          }
          return true;
        }

        latLngsClose(a, b) {
          if (!a || !b) return false;
          const tolerance = this.options.latLngEqualityMargin || 1e-9;
          const latA = a.lat ?? a?.latlng?.lat ?? 0;
          const lngA = a.lng ?? a?.latlng?.lng ?? 0;
          const latB = b.lat ?? b?.latlng?.lat ?? 0;
          const lngB = b.lng ?? b?.latlng?.lng ?? 0;
          return Math.abs(latA - latB) <= tolerance && Math.abs(lngA - lngB) <= tolerance;
        }

        drawGroups(groups) {
          const newLayers = [];
          const dashBase = this.options.dashLengthPx;
          const minDash = this.options.minDashLengthPx;
          const weight = this.computeStrokeWeight();

          groups.forEach(group => {
            if (!group || !Array.isArray(group.routes) || group.routes.length === 0) return;
            if (!Array.isArray(group.points) || group.points.length < 2) return;

            const coords = group.points.map(latlng => [latlng.lat, latlng.lng]);
            const sortedRoutes = group.routes.slice().sort((a, b) => a - b);
            const offsetsByRoute = new Map();

            if (group.routeOffsets instanceof Map) {
              group.routeOffsets.forEach((value, routeId) => {
                const numericRoute = Number(routeId);
                const numericValue = Number(value);
                if (Number.isFinite(numericRoute) && Number.isFinite(numericValue)) {
                  const existing = offsetsByRoute.get(numericRoute);
                  if (!Number.isFinite(existing) || numericValue < existing) {
                    offsetsByRoute.set(numericRoute, numericValue);
                  }
                }
              });
            } else if (group.routeOffsets && typeof group.routeOffsets === 'object') {
              Object.entries(group.routeOffsets).forEach(([routeKey, info]) => {
                const numericRoute = Number(routeKey);
                const numericValue = Number(info?.min ?? info);
                if (Number.isFinite(numericRoute) && Number.isFinite(numericValue)) {
                  const existing = offsetsByRoute.get(numericRoute);
                  if (!Number.isFinite(existing) || numericValue < existing) {
                    offsetsByRoute.set(numericRoute, numericValue);
                  }
                }
              });
            }

            if (sortedRoutes.length === 1) {
              const routeId = sortedRoutes[0];
              const layer = L.polyline(coords, mergeRouteLayerOptions({
                color: getRouteColor(routeId),
                weight,
                opacity: 1,
                lineCap: 'round',
                lineJoin: 'round'
              }, this.renderer, this.routePaneName)).addTo(this.map);
              newLayers.push(layer);
              return;
            }

            const groupLength = group.lengthPx || 0;
            if (!(groupLength > 0)) return;
            const stripeCount = sortedRoutes.length;
            let dashLength = dashBase;
            if (dashLength * stripeCount > groupLength) {
              dashLength = groupLength / stripeCount;
            }
            if (!(dashLength > 0)) {
              dashLength = minDash;
            }

            const gapLength = dashLength * (stripeCount - 1);
            const patternLength = dashLength + gapLength;

            let baseOffsetValue;
            const tolerance = 1e-9;
            let anchorRouteId = null;
            let anchorOffset = -Infinity;

            sortedRoutes.forEach(routeId => {
              const offsetValue = offsetsByRoute.get(routeId);
              if (Number.isFinite(offsetValue)) {
                if (
                  anchorRouteId === null ||
                  offsetValue > anchorOffset + tolerance ||
                  (Math.abs(offsetValue - anchorOffset) <= tolerance && routeId < anchorRouteId)
                ) {
                  anchorRouteId = routeId;
                  anchorOffset = offsetValue;
                }
              }
            });

            if (anchorRouteId !== null && Number.isFinite(anchorOffset)) {
              const anchorIndex = sortedRoutes.indexOf(anchorRouteId);
              baseOffsetValue = anchorOffset - dashLength * anchorIndex;
            } else {
              const rawOffset = Number(group.offsetPx);
              baseOffsetValue = Number.isFinite(rawOffset) ? rawOffset : 0;
            }

            sortedRoutes.forEach((routeId, index) => {
              let dashOffsetValue = baseOffsetValue + dashLength * index;
              if (patternLength > 0) {
                const targetOffset = offsetsByRoute.get(routeId);
                if (Number.isFinite(targetOffset)) {
                  const diff = targetOffset - dashOffsetValue;
                  const adjustment = Math.round(diff / patternLength);
                  if (Number.isFinite(adjustment) && adjustment !== 0) {
                    dashOffsetValue += adjustment * patternLength;
                  }
                }
                dashOffsetValue = ((dashOffsetValue % patternLength) + patternLength) % patternLength;
              }

              const layer = L.polyline(coords, mergeRouteLayerOptions({
                color: getRouteColor(routeId),
                weight,
                opacity: 1,
                dashArray: `${dashLength} ${gapLength}`,
                dashOffset: `${dashOffsetValue}`,
                lineCap: 'butt',
                lineJoin: 'round'
              }, this.renderer, this.routePaneName)).addTo(this.map);
              newLayers.push(layer);
            });
          });

          this.layers = newLayers;
        }

        simplifyLatLngs(latlngs, zoom) {
          if (!Array.isArray(latlngs) || latlngs.length === 0) {
            return [];
          }

          const projected = latlngs.map(latlng => this.map.project(latlng, zoom));
          let simplified = projected;
          if (projected.length > 2 && this.options.simplifyTolerancePx > 0 && L.LineUtil && L.LineUtil.simplify) {
            simplified = L.LineUtil.simplify(projected, this.options.simplifyTolerancePx);
          }

          return simplified.map(pt => ({
            point: L.point(pt.x, pt.y),
            latlng: this.map.unproject(pt, zoom)
          }));
        }

        resampleRoute(routeId, latlngs, zoom, step) {
          const simplified = this.simplifyLatLngs(latlngs, zoom);
          if (simplified.length < 2) {
            return [];
          }

          const samples = [];
          const first = simplified[0];
          samples.push({
            latlng: first.latlng,
            point: first.point,
            cumulativeLength: 0
          });

          let traversed = 0;
          let distanceSinceLast = 0;

          for (let i = 1; i < simplified.length; i++) {
            const prev = simplified[i - 1];
            const curr = simplified[i];
            const segmentLength = this.distance(prev.point, curr.point);
            if (segmentLength === 0) {
              continue;
            }

            let consumed = 0;
            while (distanceSinceLast + (segmentLength - consumed) >= step) {
              const remaining = step - distanceSinceLast;
              consumed += remaining;
              const ratio = consumed / segmentLength;
              const samplePoint = this.interpolatePoint(prev.point, curr.point, ratio);
              const sampleLatLng = this.map.unproject(samplePoint, zoom);
              traversed += remaining;
              samples.push({
                latlng: sampleLatLng,
                point: samplePoint,
                cumulativeLength: traversed
              });
              distanceSinceLast = 0;
            }

            const leftover = segmentLength - consumed;
            traversed += leftover;
            distanceSinceLast += leftover;
          }

          const last = simplified[simplified.length - 1];
          const lastSample = samples[samples.length - 1];
          if (!this.latLngsClose(lastSample.latlng, last.latlng)) {
            samples.push({
              latlng: last.latlng,
              point: last.point,
              cumulativeLength: traversed
            });
          } else {
            lastSample.cumulativeLength = traversed;
          }

          const segments = [];
          for (let i = 0; i < samples.length - 1; i++) {
            const start = samples[i];
            const end = samples[i + 1];
            const lengthPx = this.distance(start.point, end.point);
            if (!(lengthPx > 0)) {
              continue;
            }

            const bounds = {
              minX: Math.min(start.point.x, end.point.x),
              minY: Math.min(start.point.y, end.point.y),
              maxX: Math.max(start.point.x, end.point.x),
              maxY: Math.max(start.point.y, end.point.y)
            };
            const midpoint = L.point(
              (start.point.x + end.point.x) / 2,
              (start.point.y + end.point.y) / 2
            );
            const heading = Math.atan2(end.point.y - start.point.y, end.point.x - start.point.x);
            const offsetValues = [];
            const startOffset = Number(start.cumulativeLength);
            if (Number.isFinite(startOffset)) offsetValues.push(startOffset);
            const endOffset = Number(end.cumulativeLength);
            if (Number.isFinite(endOffset)) offsetValues.push(endOffset);

            const routeOffsets = {};
            if (offsetValues.length > 0) {
              routeOffsets[routeId] = { min: Math.min(...offsetValues) };
            }

            segments.push({
              routeId,
              index: segments.length,
              start,
              end,
              lengthPx,
              bounds,
              midpoint,
              heading,
              routeOffsets,
              sharedRoutes: new Set([routeId])
            });
          }

          return segments;
        }

        interpolatePoint(a, b, t) {
          return L.point(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t
          );
        }

        distance(a, b) {
          const ax = a?.x ?? 0;
          const ay = a?.y ?? 0;
          const bx = b?.x ?? 0;
          const by = b?.y ?? 0;
          const dx = bx - ax;
          const dy = by - ay;
          return Math.sqrt(dx * dx + dy * dy);
        }

        segmentsOverlap(a, b, tolerance, headingToleranceRad) {
          const midpointDistance = this.distance(a.midpoint, b.midpoint);
          if (midpointDistance > tolerance) {
            return false;
          }

          const headingDiff = this.smallestHeadingDifference(a.heading, b.heading);
          if (headingDiff > headingToleranceRad && Math.abs(Math.PI - headingDiff) > headingToleranceRad) {
            return false;
          }

          const startDistance = this.distance(a.start.point, b.start.point);
          const endDistance = this.distance(a.end.point, b.end.point);
          const crossStart = this.distance(a.start.point, b.end.point);
          const crossEnd = this.distance(a.end.point, b.start.point);
          const closeEnough = Math.min(startDistance, endDistance, crossStart, crossEnd) <= tolerance * 2;

          return closeEnough;
        }

        smallestHeadingDifference(a, b) {
          let diff = Math.abs(a - b);
          diff = diff % (Math.PI * 2);
          if (diff > Math.PI) diff = (Math.PI * 2) - diff;
          return diff;
        }
      }
      // Fetch routes from GetRoutes.
      function fetchRouteColors() {
        if (isEtaSpotAgency()) {
          return fetchEtaSpotRouteColors();
        }
        return fetchRideSystemsRouteColors();
      }

      function fetchRideSystemsRouteColors() {
        console.log('Fetching route colors...');
        const routesApiUrl = `${baseURL}/Services/JSONPRelay.svc/GetRoutes?APIKey=8882812681`;
        return fetch(routesApiUrl)
          .then(response => response.json())
          .then(data => {
            if (Array.isArray(data)) {
              data.forEach(route => {
                setRouteVisibility(route);
                allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                if (canDisplayRoute(route.RouteID)) {
                  routeColors[route.RouteID] = route.MapLineColor;
                  console.log(`Route ID: ${route.RouteID}, Color: ${route.MapLineColor}`);
                } else {
                  delete routeColors[route.RouteID];
                  console.log(`Route ID: ${route.RouteID} hidden due to display settings`);
                }
              });
            }
          })
          .catch(error => console.error('Error fetching route colors:', error));
      }

      function fetchEtaSpotRouteColors() {
        const expectedBase = baseURL;
        const expectedType = currentAgencyType;
        const serviceUrl = getEtaSpotServiceUrl();
        if (!serviceUrl) {
          routeColors = {};
          return Promise.resolve();
        }
        const params = new URLSearchParams({
          service: 'get_routes',
          token: getEtaSpotToken()
        });
        const endpoint = `${serviceUrl}?${params.toString()}`;
        return fetch(endpoint)
          .then(response => response.json())
          .then(data => {
            if (baseURL !== expectedBase || currentAgencyType !== expectedType) {
              return;
            }
            const routes = Array.isArray(data?.get_routes) ? data.get_routes : [];
            const updatedRouteColors = {};
            routes.forEach(route => {
              const rawId = route?.id ?? route?.routeID ?? route?.RouteID;
              const numericRouteId = Number(rawId);
              if (!Number.isFinite(numericRouteId)) {
                return;
              }
              const name = typeof route?.name === 'string' ? route.name.trim() : '';
              const shortName = typeof route?.shortName === 'string' ? route.shortName.trim() : '';
              const description = name || shortName || `Route ${numericRouteId}`;
              const color = typeof route?.color === 'string' ? route.color.trim() : '';
              const textColor = typeof route?.textColor === 'string' ? route.textColor.trim() : '';
              const record = {
                RouteID: numericRouteId,
                RouteName: shortName || description,
                Description: description,
                Name: name || description,
                ShortName: shortName || '',
                MapLineColor: color || '#000000',
                TextColor: textColor || '',
                IsVisibleOnMap: route?.isActive !== false && route?.isActive !== 0,
                _source: 'etaspot'
              };
              setRouteVisibility(record);
              allRoutes[numericRouteId] = Object.assign(allRoutes[numericRouteId] || {}, record);
              if (canDisplayRoute(numericRouteId)) {
                updatedRouteColors[numericRouteId] = record.MapLineColor;
              }
            });
            routeColors = updatedRouteColors;
          })
          .catch(error => {
            console.error('Error fetching CAT route colors:', error);
          });
      }

      function fetchRoutePaths() {
          if (isEtaSpotAgency()) {
              return fetchRoutePathsEtaSpot();
          }
          return fetchRoutePathsRideSystems();
      }

      // Fetch route paths from GetRoutesForMapWithSchedule and center map on relevant routes.
      function fetchRoutePathsRideSystems() {
          const currentBaseURL = baseURL;
          const routePathsApiUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetRoutesForMapWithScheduleWithEncodedLine?APIKey=8882812681`;
          return fetch(routePathsApiUrl)
              .then(response => response.json())
              .then(data => {
                  if (currentBaseURL !== baseURL) return;
                  const activeRoutesForBounds = new Set();
                  activeRoutes.forEach(routeId => {
                      const numericRouteId = Number(routeId);
                      if (Number.isFinite(numericRouteId) && numericRouteId !== 0) {
                          activeRoutesForBounds.add(numericRouteId);
                      }
                  });
                  const hasActiveServiceRoutes = activeRoutesForBounds.size > 0;
                  let bounds = null;
                  let fallbackBounds = null;
                  const displayedRoutes = new Map();
                  const rendererGeometries = new Map();
                  const simpleGeometries = [];
                  const selectedRouteIds = [];
                  const updatedRouteStopAddressMap = {};
                  const updatedRouteStopRouteMap = {};
                  const useOverlapRenderer = enableOverlapDashRendering && overlapRenderer;
                  const seenRouteIds = new Set();
                  let geometryChanged = false;

                  if (Array.isArray(data)) {
                      data.forEach(route => {
                          setRouteVisibility(route);
                          allRoutes[route.RouteID] = Object.assign(allRoutes[route.RouteID] || {}, route);
                  const numericRouteId = Number(route.RouteID);
                  const isNumericRoute = !Number.isNaN(numericRouteId);

                  if (Array.isArray(route.Stops)) {
                      route.Stops.forEach(stop => {
                          const routeStopId = Number(stop.RouteStopID ?? stop.RouteStopId);
                          const addressId = stop.AddressID ?? stop.AddressId;
                          if (!Number.isNaN(routeStopId)) {
                              const routeStopKey = `${routeStopId}`;
                              if (isNumericRoute) {
                                  if (!Array.isArray(updatedRouteStopRouteMap[routeStopKey])) {
                                      updatedRouteStopRouteMap[routeStopKey] = [];
                                  }
                                  if (!updatedRouteStopRouteMap[routeStopKey].includes(numericRouteId)) {
                                      updatedRouteStopRouteMap[routeStopKey].push(numericRouteId);
                                  }
                              }
                              if (addressId !== undefined && addressId !== null && `${addressId}`.trim() !== '') {
                                  updatedRouteStopAddressMap[routeStopKey] = `${addressId}`;
                              }
                          }
                      });
                  }

                  const routeAllowed = canDisplayRoute(route.RouteID);
                          if (isNumericRoute && route.EncodedPolyline) {
                              seenRouteIds.add(numericRouteId);
                          }

                          if (!routeAllowed) {
                              return;
                          }

                          const isSelected = isRouteSelected(route.RouteID);
                          if (route.EncodedPolyline && isNumericRoute) {
                              const shouldIncludeInBounds = !hasActiveServiceRoutes || activeRoutesForBounds.has(numericRouteId);
                              let cacheEntry = routePolylineCache.get(numericRouteId);
                              let latLngPath;
                              let polyBounds = null;

                              if (!cacheEntry || cacheEntry.encoded !== route.EncodedPolyline) {
                                  const decodedPolyline = polyline.decode(route.EncodedPolyline);
                                  latLngPath = decodedPolyline.map(coords => L.latLng(coords[0], coords[1]));
                                  if (Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                      polyBounds = L.latLngBounds(latLngPath);
                                  }
                                  const entry = {
                                      encoded: route.EncodedPolyline,
                                      latLngPath,
                                      bounds: polyBounds
                                  };
                                  routePolylineCache.set(numericRouteId, entry);
                                  ensureRouteProjectedPath(entry);
                                  cacheEntry = routePolylineCache.get(numericRouteId);
                                  if (isSelected) {
                                      geometryChanged = true;
                                  }
                              } else {
                                  latLngPath = cacheEntry.latLngPath;
                                  polyBounds = cacheEntry.bounds || null;
                                  if (!polyBounds && Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                      polyBounds = L.latLngBounds(latLngPath);
                                      cacheEntry.bounds = polyBounds;
                                  }
                                  ensureRouteProjectedPath(cacheEntry);
                              }

                              let candidateBounds = polyBounds;
                              if (!candidateBounds && Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                  candidateBounds = L.latLngBounds(latLngPath);
                                  if (cacheEntry) {
                                      cacheEntry.bounds = candidateBounds;
                                  } else {
                                      const existing = routePolylineCache.get(numericRouteId);
                                      if (existing) {
                                          existing.bounds = candidateBounds;
                                      }
                                  }
                              }

                              if (candidateBounds) {
                                  fallbackBounds = fallbackBounds
                                      ? fallbackBounds.extend(candidateBounds)
                                      : L.latLngBounds(candidateBounds);
                                  if (shouldIncludeInBounds) {
                                      bounds = bounds
                                          ? bounds.extend(candidateBounds)
                                          : L.latLngBounds(candidateBounds);
                                  }
                              }

                              if (isSelected && Array.isArray(latLngPath) && latLngPath.length >= 2) {
                                  const routeColor = getRouteColor(route.RouteID);
                                  selectedRouteIds.push(numericRouteId);
                                  if (useOverlapRenderer) {
                                      rendererGeometries.set(numericRouteId, latLngPath);
                                  } else {
                                      simpleGeometries.push({ routeId: numericRouteId, latLngPath, routeColor });
                                  }

                                  const storedRoute = allRoutes[route.RouteID] || {};
                                  const legendNameCandidates = [
                                      storedRoute.Description,
                                      route.Description,
                                      storedRoute.Name,
                                      route.Name,
                                      storedRoute.RouteName,
                                      route.RouteName
                                  ];
                                  let legendName = legendNameCandidates.find(value => typeof value === 'string' && value.trim() !== '');
                                  legendName = legendName ? legendName.trim() : `Route ${route.RouteID}`;
                                  const rawDescription = storedRoute.InfoText ?? route.InfoText ?? '';
                                  const legendDescription = typeof rawDescription === 'string' ? rawDescription.trim() : '';
                                  const legendRouteId = isNumericRoute ? numericRouteId : route.RouteID;
                                  displayedRoutes.set(route.RouteID, {
                                      routeId: legendRouteId,
                                      color: routeColor,
                                      name: legendName,
                                      description: legendDescription
                                  });
                              }
                          } else if (isSelected && isNumericRoute) {
                              if (routePolylineCache.has(numericRouteId)) {
                                  routePolylineCache.delete(numericRouteId);
                              }
                              geometryChanged = true;
                          }
                      });

                      const previousSelectedIds = new Set(lastRouteRenderState.selectionKey
                          ? lastRouteRenderState.selectionKey.split('|').filter(Boolean).map(id => Number(id))
                          : []);
                      Array.from(routePolylineCache.keys()).forEach(routeId => {
                          if (!seenRouteIds.has(routeId)) {
                              if (previousSelectedIds.has(routeId)) {
                                  geometryChanged = true;
                              }
                              routePolylineCache.delete(routeId);
                          }
                      });

                      const selectedRouteIdsSorted = selectedRouteIds.slice().sort((a, b) => a - b);
                      const selectionKey = selectedRouteIdsSorted.join('|');
                      const colorSignature = selectedRouteIdsSorted.map(id => `${id}:${getRouteColor(id)}`).join('|');
                      const geometrySignature = selectedRouteIdsSorted
                          .map(id => `${id}:${routePolylineCache.get(id)?.encoded || ''}`)
                          .join('|');
                      const rendererFlag = !!useOverlapRenderer;

                      let shouldRender = routeLayers.length === 0 ||
                        rendererFlag !== lastRouteRenderState.useOverlapRenderer ||
                        selectionKey !== lastRouteRenderState.selectionKey ||
                        colorSignature !== lastRouteRenderState.colorSignature ||
                        geometrySignature !== lastRouteRenderState.geometrySignature ||
                        geometryChanged;

                      if (shouldRender) {
                          routeLayers.forEach(layer => map.removeLayer(layer));
                          routeLayers = [];
                          if (useOverlapRenderer) {
                              const layers = overlapRenderer.updateRoutes(rendererGeometries, selectedRouteIdsSorted);
                              routeLayers = layers;
                          } else {
                              const currentStrokeWeight = computeRouteStrokeWeight(typeof map?.getZoom === 'function' ? map.getZoom() : null);
                              simpleGeometries.forEach(({ routeId, latLngPath, routeColor }) => {
                              const routeLayer = L.polyline(latLngPath, mergeRouteLayerOptions({
                                      color: routeColor,
                                      weight: currentStrokeWeight,
                                      opacity: 1,
                                      lineCap: 'round',
                                      lineJoin: 'round'
                                  })).addTo(map);
                                  routeLayers.push(routeLayer);
                              });
                          }
                      }

                      lastRouteRenderState = {
                          selectionKey,
                          colorSignature,
                          geometrySignature,
                          useOverlapRenderer: rendererFlag
                      };

                      routeStopAddressMap = updatedRouteStopAddressMap;
                      routeStopRouteMap = updatedRouteStopRouteMap;
                      updateCustomPopups();
                      if (Array.isArray(stopDataCache) && stopDataCache.length > 0) {
                          renderBusStops(stopDataCache);
                      }
                      if (!bounds && fallbackBounds) {
                          bounds = fallbackBounds;
                      }
                      if (bounds) {
                          allRouteBounds = bounds;
                          if (!mapHasFitAllRoutes) {
                              if (!kioskMode && !adminKioskMode) {
                                  map.fitBounds(allRouteBounds, { padding: [20, 20] });
                              }
                              mapHasFitAllRoutes = true;
                          }
                      }
                      evaluateIncidentRouteAlerts();
                      updateRouteSelector(activeRoutes);
                      stopMarkers.forEach(stopMarker => stopMarker.bringToFront());
                  }
                  updateRouteLegend(Array.from(displayedRoutes.values()), { preserveOnEmpty: true });
              })
              .catch(error => {
                  console.error("Error fetching route paths:", error);
                  if (kioskMode || adminKioskMode) {
                      updateRouteLegend(lastRenderedLegendRoutes, { preserveOnEmpty: true });
                  } else {
                      updateRouteLegend([], { forceHide: true });
                  }
              });
      }

      function fetchRoutePathsEtaSpot() {
          const expectedBase = baseURL;
          const expectedType = currentAgencyType;
          const serviceUrl = getEtaSpotServiceUrl();
          if (!serviceUrl) {
              routeLayers.forEach(layer => map && map.removeLayer(layer));
              routeLayers = [];
              routePolylineCache.clear();
              updateRouteLegend([], { forceHide: true });
              return Promise.resolve();
          }
          const params = new URLSearchParams({
              service: 'get_patterns',
              token: getEtaSpotToken()
          });
          const endpoint = `${serviceUrl}?${params.toString()}`;
          return fetch(endpoint)
              .then(response => response.json())
              .then(data => {
                  if (expectedBase !== baseURL || currentAgencyType !== expectedType) {
                      return;
                  }
                  const patterns = Array.isArray(data?.get_patterns) ? data.get_patterns : [];
                  const routeSegments = new Map();
                  patterns.forEach(pattern => {
                      const segments = decodeEtaSpotPatternSegments(pattern);
                      if (!Array.isArray(segments) || segments.length === 0) {
                          return;
                      }
                      const routes = Array.isArray(pattern?.routes) ? pattern.routes : [];
                      routes.forEach(routeIdValue => {
                          const numericRouteId = Number(routeIdValue);
                          if (!Number.isFinite(numericRouteId)) {
                              return;
                          }
                          if (!routeSegments.has(numericRouteId)) {
                              routeSegments.set(numericRouteId, []);
                          }
                          const segmentClones = segments.map(segment => segment.map(point => {
                              if (typeof L !== 'undefined' && typeof L.latLng === 'function') {
                                  return L.latLng(point.lat, point.lng);
                              }
                              return { lat: point.lat, lng: point.lng };
                          }));
                          routeSegments.get(numericRouteId).push(...segmentClones);
                      });
                  });

                  const updatedCache = new Map();
                  routeLayers.forEach(layer => map && map.removeLayer(layer));
                  routeLayers = [];

                  const displayedRoutes = [];
                  let bounds = null;
                  const zoom = typeof map?.getZoom === 'function' ? map.getZoom() : null;
                  const strokeWeight = computeRouteStrokeWeight(zoom);

                  routeSegments.forEach((segments, routeId) => {
                      const validSegments = (Array.isArray(segments) ? segments : [])
                          .map(segment => Array.isArray(segment) ? segment.filter(point => point && Number.isFinite(point.lat) && Number.isFinite(point.lng)) : [])
                          .filter(segment => segment.length >= 2);
                      if (validSegments.length === 0) {
                          return;
                      }

                      let aggregatedBounds = null;
                      validSegments.forEach(segment => {
                          if (typeof L !== 'undefined' && typeof L.latLngBounds === 'function') {
                              const segmentBounds = L.latLngBounds(segment);
                              if (!aggregatedBounds) {
                                  aggregatedBounds = segmentBounds;
                              } else {
                                  aggregatedBounds.extend(segmentBounds);
                              }
                          }
                      });

                      const longestSegment = validSegments.reduce((longest, segment) => {
                          if (!longest) return segment;
                          return segment.length > longest.length ? segment : longest;
                      }, null);

                      if (longestSegment) {
                          updatedCache.set(routeId, {
                              encoded: null,
                              latLngPath: longestSegment,
                              bounds: aggregatedBounds,
                              latLngSegments: validSegments
                          });
                      }

                      if (!isRouteSelected(routeId)) {
                          return;
                      }

                      const routeColor = getRouteColor(routeId);
                      const legendName = getRouteDisplayName(routeId);
                      displayedRoutes.push({ routeId, name: legendName, color: routeColor });

                      validSegments.forEach(segment => {
                          if (typeof L !== 'undefined' && typeof L.polyline === 'function') {
                              const layer = L.polyline(segment, mergeRouteLayerOptions({
                                  color: routeColor,
                                  weight: strokeWeight,
                                  opacity: 1,
                                  lineCap: 'round',
                                  lineJoin: 'round'
                              })).addTo(map);
                              routeLayers.push(layer);
                          }
                          if (typeof L !== 'undefined' && typeof L.latLngBounds === 'function') {
                              const segmentBounds = L.latLngBounds(segment);
                              if (!bounds) {
                                  bounds = segmentBounds;
                              } else {
                                  bounds.extend(segmentBounds);
                              }
                          }
                      });
                  });

                  routePolylineCache.clear();
                  updatedCache.forEach((value, key) => {
                      routePolylineCache.set(key, value);
                  });

                  updateCustomPopups();
                  if (Array.isArray(stopDataCache) && stopDataCache.length > 0) {
                      renderBusStops(stopDataCache);
                  }
                  evaluateIncidentRouteAlerts();
                  updateRouteSelector(activeRoutes);
                  stopMarkers.forEach(marker => {
                      if (marker && typeof marker.bringToFront === 'function') {
                          marker.bringToFront();
                      }
                  });

                  if (bounds && map) {
                      allRouteBounds = bounds;
                      if (!mapHasFitAllRoutes) {
                          if (!kioskMode && !adminKioskMode) {
                              try {
                                  map.fitBounds(bounds, { padding: [20, 20] });
                              } catch (error) {
                                  console.error('Failed to fit bounds for CAT routes:', error);
                              }
                          }
                          mapHasFitAllRoutes = true;
                      }
                  }

                  if (displayedRoutes.length > 0) {
                      updateRouteLegend(displayedRoutes, { preserveOnEmpty: true });
                  } else if (kioskMode || adminKioskMode) {
                      updateRouteLegend(lastRenderedLegendRoutes, { preserveOnEmpty: true });
                  } else {
                      updateRouteLegend([], { forceHide: true });
                  }
              })
              .catch(error => {
                  console.error('Error fetching CAT route paths:', error);
                  if (kioskMode || adminKioskMode) {
                      updateRouteLegend(lastRenderedLegendRoutes, { preserveOnEmpty: true });
                  } else {
                      updateRouteLegend([], { forceHide: true });
                  }
              });
      }

      function decodeEtaSpotPatternSegments(pattern) {
          const rawPoints = [];
          if (Array.isArray(pattern?.decLine)) {
              pattern.decLine.forEach(point => {
                  const lat = Number(point?.lat ?? point?.Lat ?? point?.latitude ?? point?.Latitude);
                  const lng = Number(point?.lng ?? point?.Lng ?? point?.longitude ?? point?.Longitude);
                  if (Number.isFinite(lat) && Number.isFinite(lng)) {
                      rawPoints.push({ lat, lng });
                  }
              });
          }
          if (rawPoints.length === 0 && typeof pattern?.encLine === 'string' && pattern.encLine.trim() !== '') {
              try {
                  const decoded = polyline.decode(pattern.encLine.trim());
                  decoded.forEach(coords => {
                      if (!Array.isArray(coords) || coords.length < 2) {
                          return;
                      }
                      const lat = Number(coords[0]);
                      const lng = Number(coords[1]);
                      if (Number.isFinite(lat) && Number.isFinite(lng)) {
                          rawPoints.push({ lat, lng });
                      }
                  });
              } catch (error) {
                  console.error('Failed to decode CAT pattern polyline:', error);
              }
          }
          return splitPolylineSegmentsByDistance(rawPoints, 600);
      }

      function splitPolylineSegmentsByDistance(points, thresholdMeters) {
          const segments = [];
          if (!Array.isArray(points) || points.length < 2) {
              return segments;
          }
          const maxDistance = Number.isFinite(thresholdMeters) ? thresholdMeters : 600;
          let currentSegment = [];
          for (let i = 0; i < points.length; i += 1) {
              const currentPoint = points[i];
              if (!currentPoint || !Number.isFinite(currentPoint.lat) || !Number.isFinite(currentPoint.lng)) {
                  continue;
              }
              if (currentSegment.length === 0) {
                  currentSegment.push({ lat: currentPoint.lat, lng: currentPoint.lng });
                  continue;
              }
              const previousPoint = currentSegment[currentSegment.length - 1];
              const distance = computeHaversineDistanceMeters(previousPoint.lat, previousPoint.lng, currentPoint.lat, currentPoint.lng);
              if (!Number.isFinite(distance) || distance > maxDistance) {
                  if (currentSegment.length >= 2) {
                      segments.push(currentSegment);
                  }
                  currentSegment = [{ lat: currentPoint.lat, lng: currentPoint.lng }];
              } else {
                  currentSegment.push({ lat: currentPoint.lat, lng: currentPoint.lng });
              }
          }
          if (currentSegment.length >= 2) {
              segments.push(currentSegment);
          }
          return segments;
      }

      function computeHaversineDistanceMeters(lat1, lon1, lat2, lon2) {
          if (![lat1, lon1, lat2, lon2].every(Number.isFinite)) {
              return Infinity;
          }
          const toRadians = Math.PI / 180;
          const deltaLat = (lat2 - lat1) * toRadians;
          const deltaLon = (lon2 - lon1) * toRadians;
          const sinLat = Math.sin(deltaLat / 2);
          const sinLon = Math.sin(deltaLon / 2);
          const startLatRad = lat1 * toRadians;
          const endLatRad = lat2 * toRadians;
          const a = sinLat * sinLat + Math.cos(startLatRad) * Math.cos(endLatRad) * sinLon * sinLon;
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(Math.max(0, 1 - a)));
          return EARTH_RADIUS_METERS * c;
      }

      function fetchBlockAssignments() {
          if (isEtaSpotAgency()) {
              busBlocks = {};
              return Promise.resolve();
          }
          return fetchBlockAssignmentsRideSystems();
      }

      function fetchBlockAssignmentsRideSystems() {
          const currentBaseURL = baseURL;
          const d = new Date();
          const ds = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear()}`;
          const schedUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetScheduleVehicleCalendarByDateAndRoute?dateString=${encodeURIComponent(ds)}`;
          return fetch(schedUrl)
              .then(response => response.json())
              .then(sched => {
                  if (currentBaseURL !== baseURL) return;
                  const ids = (sched || []).map(s => s.ScheduleVehicleCalendarID).join(',');
                  if (!ids) {
                      busBlocks = {};
                      return;
                  }
                  const blockUrl = `${currentBaseURL}/Services/JSONPRelay.svc/GetDispatchBlockGroupData?scheduleVehicleCalendarIdsString=${ids}`;
                  return fetch(blockUrl).then(r => r.json());
              })
              .then(data => {
                  if (currentBaseURL !== baseURL || !data) return;
                  const groups = data?.BlockGroups || [];
                  const alias = {
                      "[01]": "[01]/[04]",
                      "[03]": "[05]/[03]",
                      "[04]": "[01]/[04]",
                      "[05]": "[05]/[03]",
                      "[06]": "[22]/[06]",
                      "[10]": "[20]/[10]",
                      "[15]": "[26]/[15]",
                      "[16] AM": "[21]/[16] AM",
                      "[17]": "[23]/[17]",
                      "[18] AM": "[24]/[18] AM",
                      "[20] AM": "[20]/[10]",
                      "[21] AM": "[21]/[16] AM",
                      "[22] AM": "[22]/[06]",
                      "[23]": "[23]/[17]",
                      "[24] AM": "[24]/[18] AM",
                      "[26] AM": "[26]/[15]"
                  };
                  const mapping = {};
                  groups.forEach(g => {
                      const block = (g.BlockGroupId || '').trim();
                      const vehicleId = g.Blocks?.[0]?.Trips?.[0]?.VehicleID ?? g.VehicleId;
                      if (block && block.includes('[') && vehicleId != null) {
                          mapping[vehicleId] = alias[block] || block;
                      }
                  });
                  busBlocks = mapping;
              })
              .catch(error => console.error('Error fetching block assignments:', error));
      }

      async function fetchBusLocations() {
          try {
              const headingPromise = loadVehicleHeadingCache();
              if (headingPromise && typeof headingPromise.then === 'function') {
                  await headingPromise;
              }
          } catch (error) {
              console.info('Proceeding without cached vehicle headings.', error);
          }
          try {
              await loadBusSVG();
          } catch (error) {
              console.error('Failed to load bus marker SVG before fetching locations:', error);
          }
          if (isEtaSpotAgency()) {
              return fetchBusLocationsEtaSpot();
          }
          return fetchBusLocationsRideSystems();
      }

      async function fetchBusLocationsRideSystems() {
          const expectedBase = baseURL;
          const expectedType = currentAgencyType;
          const apiUrl = `${expectedBase}/Services/JSONPRelay.svc/GetMapVehiclePoints?APIKey=8882812681&returnVehiclesNotAssignedToRoute=true`;
          try {
              const response = await fetch(apiUrl);
              if (!response.ok) {
                  throw new Error(`Network response was not ok: ${response.status} ${response.statusText}`);
              }
              const data = await response.json();
              if (baseURL !== expectedBase || currentAgencyType !== expectedType || !Array.isArray(data)) {
                  return;
              }
              const activeRoutesSet = new Set();
              const vehicles = [];
              data.forEach(vehicle => {
                  const vehicleID = vehicle?.VehicleID;
                  const lat = Number(vehicle?.Latitude);
                  const lng = Number(vehicle?.Longitude);
                  if (vehicleID === undefined || vehicleID === null || Number.isNaN(lat) || Number.isNaN(lng)) {
                      return;
                  }
                  let routeID = vehicle?.RouteID;
                  if (!routeID && adminMode) {
                      routeID = 0;
                  } else if (!routeID) {
                      return;
                  }
                  const numericRouteId = Number(routeID);
                  const effectiveRouteId = Number.isNaN(numericRouteId) ? routeID : numericRouteId;
                  if (!canDisplayRoute(effectiveRouteId)) {
                      return;
                  }
                  if (!adminMode && !Object.prototype.hasOwnProperty.call(routeColors, effectiveRouteId)) {
                      return;
                  }
                  activeRoutesSet.add(effectiveRouteId);
                  vehicles.push({
                      vehicleID,
                      newPosition: [lat, lng],
                      isMoving: Number(vehicle?.GroundSpeed) > 0,
                      busName: vehicle?.Name,
                      routeID: effectiveRouteId,
                      heading: vehicle?.Heading,
                      groundSpeed: vehicle?.GroundSpeed
                  });
              });
              await renderVehiclesOnMap(vehicles, activeRoutesSet);
          } catch (error) {
              console.error('Error fetching bus locations:', error);
          }
      }

      async function fetchBusLocationsEtaSpot() {
          const expectedBase = baseURL;
          const expectedType = currentAgencyType;
          const serviceUrl = getEtaSpotServiceUrl();
          if (!serviceUrl) {
              await renderVehiclesOnMap([], new Set());
              return;
          }
          const params = new URLSearchParams({
              service: 'get_vehicles',
              token: getEtaSpotToken()
          });
          const endpoint = `${serviceUrl}?${params.toString()}`;
          try {
              const response = await fetch(endpoint, { cache: 'no-store' });
              if (!response.ok) {
                  throw new Error(`Vehicle request failed: ${response.status} ${response.statusText}`);
              }
              const payload = await response.json();
              if (baseURL !== expectedBase || currentAgencyType !== expectedType) {
                  return;
              }
              const records = Array.isArray(payload?.get_vehicles) ? payload.get_vehicles : [];
              const activeRoutesSet = new Set();
              const vehicles = [];
              records.forEach(vehicle => {
                  const vehicleID = vehicle?.equipmentID ?? vehicle?.vehicleID ?? vehicle?.id;
                  const lat = Number(vehicle?.lat ?? vehicle?.latitude);
                  const lng = Number(vehicle?.lng ?? vehicle?.longitude);
                  if (vehicleID === undefined || vehicleID === null || Number.isNaN(lat) || Number.isNaN(lng)) {
                      return;
                  }
                  let routeID = vehicle?.routeID ?? vehicle?.routeId ?? vehicle?.route;
                  if (!routeID && adminMode) {
                      routeID = 0;
                  } else if (!routeID) {
                      return;
                  }
                  const numericRouteId = Number(routeID);
                  const effectiveRouteId = Number.isNaN(numericRouteId) ? routeID : numericRouteId;
                  if (!canDisplayRoute(effectiveRouteId)) {
                      return;
                  }
                  if (!adminMode && !Object.prototype.hasOwnProperty.call(routeColors, effectiveRouteId)) {
                      return;
                  }
                  activeRoutesSet.add(effectiveRouteId);
                  const groundSpeedValue = Number(vehicle?.speed ?? vehicle?.groundSpeed ?? vehicle?.velocity);
                  const groundSpeed = Number.isFinite(groundSpeedValue) ? groundSpeedValue : 0;
                  const busName = typeof vehicle?.name === 'string' && vehicle.name.trim() !== ''
                      ? vehicle.name.trim()
                      : (vehicleID !== undefined && vehicleID !== null ? `Vehicle ${vehicleID}` : `Route ${effectiveRouteId}`);
                  vehicles.push({
                      vehicleID,
                      newPosition: [lat, lng],
                      isMoving: groundSpeed > 0,
                      busName,
                      routeID: effectiveRouteId,
                      heading: vehicle?.heading,
                      groundSpeed
                  });
              });
              await renderVehiclesOnMap(vehicles, activeRoutesSet);
          } catch (error) {
              console.error('Error fetching CAT vehicle locations:', error);
          }
      }

      async function renderVehiclesOnMap(vehicles, activeRoutesSet) {
          const normalizedVehicles = Array.isArray(vehicles) ? vehicles : [];
          const normalizedActiveRoutes = activeRoutesSet instanceof Set
              ? activeRoutesSet
              : new Set(Array.isArray(activeRoutesSet) ? activeRoutesSet : []);
          activeRoutes = normalizedActiveRoutes;
          updateRouteSelector(normalizedActiveRoutes);

          const markerMetricsForZoom = computeBusMarkerMetrics(map && typeof map?.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM);
          const currentBusData = {};

          for (const v of normalizedVehicles) {
              if (!v || v.vehicleID === undefined || v.vehicleID === null) {
                  continue;
              }
              const { vehicleID, newPosition, busName, routeID, heading, groundSpeed } = v;
              if (!isRouteSelected(routeID)) {
                  continue;
              }
              currentBusData[vehicleID] = true;
              const state = ensureBusMarkerState(vehicleID);
              const routeColor = getRouteColor(routeID) || outOfServiceRouteColor;
              const glyphColor = computeBusMarkerGlyphColor(routeColor);
              const fallbackHeading = getVehicleHeadingFallback(vehicleID, heading);
              const headingDeg = updateBusMarkerHeading(state, newPosition, fallbackHeading, groundSpeed);
              const accessibleLabel = buildBusMarkerAccessibleLabel(busName, headingDeg, groundSpeed);
              const gpsIsStale = isVehicleGpsStale(v);
              const isStopped = isBusConsideredStopped(groundSpeed);

              state.busName = busName;
              state.routeID = routeID;
              state.fillColor = routeColor;
              state.glyphColor = glyphColor;
              state.headingDeg = headingDeg;
              state.accessibleLabel = accessibleLabel;
              state.isStale = gpsIsStale;
              state.isStopped = isStopped;
              state.groundSpeed = groundSpeed;
              state.lastUpdateTimestamp = Date.now();
              rememberCachedVehicleHeading(vehicleID, headingDeg, state.lastUpdateTimestamp);

              if (!state.size) {
                  setBusMarkerSize(state, markerMetricsForZoom);
              }

              if (markers[vehicleID]) {
                  animateMarkerTo(markers[vehicleID], newPosition);
                  markers[vehicleID].routeID = routeID;
                  queueBusMarkerVisualUpdate(vehicleID, {
                      fillColor: routeColor,
                      glyphColor,
                      headingDeg,
                      stale: gpsIsStale,
                      accessibleLabel,
                      stopped: isStopped
                  });
              } else {
                  try {
                      const icon = await createBusMarkerDivIcon(vehicleID, state);
                      if (!icon) {
                          continue;
                      }
                      const marker = L.marker(newPosition, { icon, pane: 'busesPane', interactive: false, keyboard: false });
                      marker.routeID = routeID;
                      marker.addTo(map);
                      markers[vehicleID] = marker;
                      state.marker = marker;
                      registerBusMarkerElements(vehicleID);
                      attachBusMarkerInteractions(vehicleID);
                      updateBusMarkerRootClasses(state);
                      updateBusMarkerZIndex(state);
                      applyBusMarkerOutlineWidth(state);
                  } catch (error) {
                      console.error(`Failed to create bus marker icon for vehicle ${vehicleID}:`, error);
                  }
              }

              if (adminMode && displayMode === DISPLAY_MODES.SPEED && !kioskMode) {
                  const speedIcon = createSpeedBubbleDivIcon(routeColor, groundSpeed, markerMetricsForZoom.scale, headingDeg);
                  if (speedIcon) {
                      nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                      if (nameBubbles[vehicleID].speedMarker) {
                          animateMarkerTo(nameBubbles[vehicleID].speedMarker, newPosition);
                          nameBubbles[vehicleID].speedMarker.setIcon(speedIcon);
                      } else {
                          nameBubbles[vehicleID].speedMarker = L.marker(newPosition, { icon: speedIcon, interactive: false, pane: 'busesPane' }).addTo(map);
                      }
                  } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                      map.removeLayer(nameBubbles[vehicleID].speedMarker);
                      delete nameBubbles[vehicleID].speedMarker;
                  }
              } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].speedMarker) {
                  map.removeLayer(nameBubbles[vehicleID].speedMarker);
                  delete nameBubbles[vehicleID].speedMarker;
              }

              if (adminMode && !kioskMode) {
                  const nameIcon = createNameBubbleDivIcon(busName, routeColor, markerMetricsForZoom.scale, headingDeg);
                  if (nameIcon) {
                      nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                      if (nameBubbles[vehicleID].nameMarker) {
                          animateMarkerTo(nameBubbles[vehicleID].nameMarker, newPosition);
                          nameBubbles[vehicleID].nameMarker.setIcon(nameIcon);
                      } else {
                          nameBubbles[vehicleID].nameMarker = L.marker(newPosition, { icon: nameIcon, interactive: false, pane: 'busesPane' }).addTo(map);
                      }
                  } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                      map.removeLayer(nameBubbles[vehicleID].nameMarker);
                      delete nameBubbles[vehicleID].nameMarker;
                  }

                  const blockName = busBlocks[vehicleID];
                  if (displayMode === DISPLAY_MODES.BLOCK && blockName && blockName.includes('[')) {
                      const blockIcon = createBlockBubbleDivIcon(blockName, routeColor, markerMetricsForZoom.scale, headingDeg);
                      if (blockIcon) {
                          nameBubbles[vehicleID] = nameBubbles[vehicleID] || {};
                          if (nameBubbles[vehicleID].blockMarker) {
                              animateMarkerTo(nameBubbles[vehicleID].blockMarker, newPosition);
                              nameBubbles[vehicleID].blockMarker.setIcon(blockIcon);
                          } else {
                              nameBubbles[vehicleID].blockMarker = L.marker(newPosition, { icon: blockIcon, interactive: false, pane: 'busesPane' }).addTo(map);
                          }
                      } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                          map.removeLayer(nameBubbles[vehicleID].blockMarker);
                          delete nameBubbles[vehicleID].blockMarker;
                      }
                  } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                      map.removeLayer(nameBubbles[vehicleID].blockMarker);
                      delete nameBubbles[vehicleID].blockMarker;
                  }
              } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].nameMarker) {
                  map.removeLayer(nameBubbles[vehicleID].nameMarker);
                  delete nameBubbles[vehicleID].nameMarker;
              } else if (nameBubbles[vehicleID] && nameBubbles[vehicleID].blockMarker) {
                  map.removeLayer(nameBubbles[vehicleID].blockMarker);
                  delete nameBubbles[vehicleID].blockMarker;
              }

              if (nameBubbles[vehicleID]) {
                  const hasMarkers = Boolean(nameBubbles[vehicleID].speedMarker || nameBubbles[vehicleID].nameMarker || nameBubbles[vehicleID].blockMarker);
                  if (hasMarkers) {
                      nameBubbles[vehicleID].lastScale = markerMetricsForZoom.scale;
                  } else {
                      delete nameBubbles[vehicleID];
                  }
              }
          }

          Object.keys(markers).forEach(vehicleID => {
              if (!currentBusData[vehicleID] || !isRouteSelected(markers[vehicleID].routeID)) {
                  map.removeLayer(markers[vehicleID]);
                  delete markers[vehicleID];
                  clearBusMarkerState(vehicleID);
                  if (nameBubbles[vehicleID]) {
                      if (nameBubbles[vehicleID].speedMarker) map.removeLayer(nameBubbles[vehicleID].speedMarker);
                      if (nameBubbles[vehicleID].nameMarker) map.removeLayer(nameBubbles[vehicleID].nameMarker);
                      if (nameBubbles[vehicleID].blockMarker) map.removeLayer(nameBubbles[vehicleID].blockMarker);
                      delete nameBubbles[vehicleID];
                  }
              }
          });

          previousBusData = currentBusData;
      }
      function updateBusMarkerColorElements(state) {
          if (!state) {
              return;
          }
          const normalizedFill = normalizeRouteColor(state.fillColor);
          const normalizedGlyph = normalizeGlyphColor(state.glyphColor, normalizedFill);
          state.fillColor = normalizedFill;
          state.glyphColor = normalizedGlyph;
          if (state.elements?.routeColor) {
              state.elements.routeColor.setAttribute('fill', normalizedFill);
              state.elements.routeColor.style.fill = normalizedFill;
          }
          if (state.elements?.centerRing) {
              state.elements.centerRing.setAttribute('fill', normalizedGlyph);
              state.elements.centerRing.style.fill = normalizedGlyph;
          }
          if (state.elements?.centerSquare) {
              state.elements.centerSquare.setAttribute('fill', normalizedGlyph);
              state.elements.centerSquare.style.fill = normalizedGlyph;
          }
          if (state.elements?.heading) {
              state.elements.heading.setAttribute('fill', normalizedGlyph);
              state.elements.heading.style.fill = normalizedGlyph;
          }
      }

      function ensureCenterSquareElement(svgEl) {
          if (!svgEl) {
              return null;
          }
          let square = svgEl.querySelector(`#${BUS_MARKER_STOPPED_SQUARE_ID}`);
          if (square) {
              return square;
          }
          const namespace = 'http://www.w3.org/2000/svg';
          square = document.createElementNS(namespace, 'rect');
          square.setAttribute('id', BUS_MARKER_STOPPED_SQUARE_ID);
          square.setAttribute('width', `${BUS_MARKER_STOPPED_SQUARE_SIZE_PX}`);
          square.setAttribute('height', `${BUS_MARKER_STOPPED_SQUARE_SIZE_PX}`);
          const halfSize = BUS_MARKER_STOPPED_SQUARE_SIZE_PX / 2;
          const x = BUS_MARKER_CENTER_RING_CENTER_X - halfSize;
          const y = BUS_MARKER_CENTER_RING_CENTER_Y - halfSize;
          square.setAttribute('x', x.toFixed(2));
          square.setAttribute('y', y.toFixed(2));
          square.style.display = 'none';
          square.style.pointerEvents = 'none';
          const centerRing = svgEl.querySelector(`#${BUS_MARKER_CENTER_RING_ID}`);
          const centerRingClass = centerRing?.getAttribute('class');
          if (centerRingClass) {
              square.setAttribute('class', centerRingClass);
          }
          const heading = svgEl.querySelector('#heading');
          if (heading && heading.parentNode) {
              heading.parentNode.insertBefore(square, heading);
          } else if (centerRing && centerRing.parentNode) {
              centerRing.parentNode.insertBefore(square, centerRing.nextSibling);
          } else {
              svgEl.appendChild(square);
          }
          return square;
      }

      function setCenterShapeDisplay(centerRing, centerSquare, isStopped) {
          const showSquare = Boolean(isStopped);
          if (centerRing) {
              centerRing.style.display = showSquare ? 'none' : 'inline';
          }
          if (centerSquare) {
              centerSquare.style.display = showSquare ? 'inline' : 'none';
          }
      }

      function applyStoppedVisualStateToSvg(svgEl, isStopped) {
          if (!svgEl) {
              return;
          }
          const centerSquare = ensureCenterSquareElement(svgEl);
          const centerRing = svgEl.querySelector(`#${BUS_MARKER_CENTER_RING_ID}`);
          setCenterShapeDisplay(centerRing, centerSquare, isStopped);
      }

      function ensureBusMarkerStoppedElements(state) {
          if (!state?.elements?.svg) {
              return;
          }
          const square = ensureCenterSquareElement(state.elements.svg);
          if (square) {
              state.elements.centerSquare = square;
          }
          if (!state.elements.centerRing || !state.elements.centerRing.isConnected) {
              const ring = state.elements.svg.querySelector(`#${BUS_MARKER_CENTER_RING_ID}`);
              if (ring) {
                  state.elements.centerRing = ring;
              }
          }
      }

      function applyBusMarkerStoppedVisualState(state) {
          if (!state?.elements?.svg) {
              return;
          }
          ensureBusMarkerStoppedElements(state);
          setCenterShapeDisplay(state.elements.centerRing, state.elements.centerSquare, state.isStopped);
      }

      function setBusMarkerContrastOverrideColor(color) {
          if (typeof color === 'string' && color.trim().length > 0) {
              busMarkerContrastOverrideColor = color.trim();
          } else {
              busMarkerContrastOverrideColor = null;
          }
          Object.keys(busMarkerStates).forEach(vehicleID => {
              const state = busMarkerStates[vehicleID];
              if (!state) {
                  return;
              }
              const routeColor = state.fillColor || BUS_MARKER_DEFAULT_ROUTE_COLOR;
              const glyphColor = computeBusMarkerGlyphColor(routeColor);
              state.glyphColor = glyphColor;
              queueBusMarkerVisualUpdate(vehicleID, { glyphColor });
          });
      }

      if (typeof window !== 'undefined') {
          window.setBusMarkerContrastOverrideColor = setBusMarkerContrastOverrideColor;
      }

      function getTextMeasurementContext() {
          if (!textMeasurementCanvas && typeof document !== 'undefined') {
              textMeasurementCanvas = document.createElement('canvas');
          }
          return textMeasurementCanvas ? textMeasurementCanvas.getContext('2d') : null;
      }

      function measureLabelTextWidth(text, fontSizePx, fontWeight = 'bold') {
          const ctx = getTextMeasurementContext();
          const normalizedFontSize = Math.max(1, Number(fontSizePx) || 0);
          if (!ctx) {
              return (typeof text === 'string' ? text.length : 0) * normalizedFontSize * 0.6;
          }
          ctx.font = `${fontWeight} ${normalizedFontSize}px ${BUS_MARKER_LABEL_FONT_FAMILY}`;
          const metrics = ctx.measureText(text || '');
          return metrics && Number.isFinite(metrics.width)
              ? metrics.width
              : (typeof text === 'string' ? text.length : 0) * normalizedFontSize * 0.6;
      }

      function roundToTwoDecimals(value) {
          return Math.round((Number(value) || 0) * 100) / 100;
      }

      function getBusMarkerVisibleExtents() {
          if (busMarkerVisibleExtents) {
              return busMarkerVisibleExtents;
          }

          const fallbackExtents = {
              top: BUS_MARKER_PIVOT_Y,
              bottom: BUS_MARKER_VIEWBOX_HEIGHT - BUS_MARKER_PIVOT_Y,
              left: BUS_MARKER_PIVOT_X,
              right: BUS_MARKER_VIEWBOX_WIDTH - BUS_MARKER_PIVOT_X
          };

          if (!BUS_MARKER_SVG_TEXT || typeof document === 'undefined') {
              return fallbackExtents;
          }

          try {
              const template = document.createElement('template');
              template.innerHTML = BUS_MARKER_SVG_TEXT.trim();
              const svgEl = template.content.firstElementChild;
              if (!svgEl) {
                  throw new Error('Failed to parse bus marker SVG for bounds computation.');
              }
              const clone = svgEl.cloneNode(true);

              clone.querySelectorAll('rect').forEach(rect => {
                  const width = Number(rect.getAttribute('width'));
                  const height = Number(rect.getAttribute('height'));
                  if (width === 0 && height === 0) {
                      rect.remove();
                  }
              });

              clone.querySelectorAll('circle').forEach(circle => {
                  const radius = Number(circle.getAttribute('r'));
                  if (radius === 0) {
                      circle.remove();
                  }
              });

              clone.setAttribute('width', `${BUS_MARKER_VIEWBOX_WIDTH}`);
              clone.setAttribute('height', `${BUS_MARKER_VIEWBOX_HEIGHT}`);
              clone.style.position = 'absolute';
              clone.style.visibility = 'hidden';
              clone.style.pointerEvents = 'none';
              clone.style.left = '-9999px';
              clone.style.top = '-9999px';

              const host = document.body || document.documentElement;
              if (!host) {
                  throw new Error('Document does not have an attachable host element for bounds computation.');
              }

              host.appendChild(clone);
              let bbox = null;
              try {
                  bbox = clone.getBBox();
              } finally {
                  clone.remove();
              }

              if (bbox && Number.isFinite(bbox.x) && Number.isFinite(bbox.y) && Number.isFinite(bbox.width) && Number.isFinite(bbox.height)) {
                  busMarkerVisibleExtents = {
                      top: BUS_MARKER_PIVOT_Y - bbox.y,
                      bottom: (bbox.y + bbox.height) - BUS_MARKER_PIVOT_Y,
                      left: BUS_MARKER_PIVOT_X - bbox.x,
                      right: (bbox.x + bbox.width) - BUS_MARKER_PIVOT_X
                  };
                  return busMarkerVisibleExtents;
              }
          } catch (error) {
              console.error('Failed to compute bus marker visible extents:', error);
          }

          busMarkerVisibleExtents = fallbackExtents;
          return busMarkerVisibleExtents;
      }

      function computeBusMarkerVerticalExtentsForHeading(headingDeg) {
          const extents = getBusMarkerVisibleExtents();
          if (!extents) {
              return null;
          }

          const normalizedHeading = normalizeHeadingDegrees(Number.isFinite(headingDeg) ? headingDeg : BUS_MARKER_DEFAULT_HEADING);
          const radians = normalizedHeading * Math.PI / 180;
          const sin = Math.sin(radians);
          const cos = Math.cos(radians);

          const corners = [
              { x: -extents.left, y: -extents.top },
              { x: extents.right, y: -extents.top },
              { x: extents.right, y: extents.bottom },
              { x: -extents.left, y: extents.bottom }
          ];

          let minY = Infinity;
          let maxY = -Infinity;
          for (const corner of corners) {
              const rotatedY = corner.x * sin + corner.y * cos;
              if (rotatedY < minY) {
                  minY = rotatedY;
              }
              if (rotatedY > maxY) {
                  maxY = rotatedY;
              }
          }

          if (!Number.isFinite(minY) || !Number.isFinite(maxY)) {
              return null;
          }

          return {
              top: Math.abs(minY),
              bottom: Math.abs(maxY)
          };
      }

      function computeLabelLeaderOffset(scale, headingDeg, position = 'above') {
          const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
          const normalizedHeading = normalizeHeadingDegrees(
              Number.isFinite(headingDeg) ? headingDeg : BUS_MARKER_DEFAULT_HEADING
          );
          const conversionFactor = (BUS_MARKER_BASE_WIDTH_PX * safeScale) / BUS_MARKER_VIEWBOX_WIDTH;
          const fallbackWidth = BUS_MARKER_BASE_WIDTH_PX * safeScale;
          const fallbackHeight = fallbackWidth * BUS_MARKER_ASPECT_RATIO;
          const fallbackHalfDiagonal = Math.sqrt(fallbackWidth * fallbackWidth + fallbackHeight * fallbackHeight) / 2;
          const clearance = LABEL_VERTICAL_CLEARANCE_PX * safeScale;

          const headingRelativeToVertical = normalizedHeading % 180;
          const deviationFromVertical = Math.min(headingRelativeToVertical, 180 - headingRelativeToVertical);
          const verticality = Math.pow(
              Math.max(0, Math.cos(deviationFromVertical * Math.PI / 180)),
              LABEL_VERTICAL_ALIGNMENT_EXPONENT
          );
          const verticalAlignmentBonus = LABEL_VERTICAL_ALIGNMENT_BONUS_PX * safeScale * verticality;
          const horizontalAlignmentBonus = LABEL_HORIZONTAL_ALIGNMENT_BONUS_PX * safeScale * (1 - verticality);

          const verticalExtents = computeBusMarkerVerticalExtentsForHeading(normalizedHeading);
          if (!verticalExtents) {
              return Math.max(0, fallbackHalfDiagonal + clearance + verticalAlignmentBonus + horizontalAlignmentBonus);
          }

          let extentSvgUnits;
          if (position === 'below') {
              extentSvgUnits = verticalExtents.bottom;
          } else if (position === 'above') {
              extentSvgUnits = verticalExtents.top;
          } else {
              extentSvgUnits = Math.max(verticalExtents.top, verticalExtents.bottom);
          }

          if (!Number.isFinite(extentSvgUnits)) {
              return Math.max(0, fallbackHalfDiagonal + clearance + verticalAlignmentBonus + horizontalAlignmentBonus);
          }

          const extentPx = extentSvgUnits * conversionFactor;
          const totalOffset = extentPx + clearance + verticalAlignmentBonus + horizontalAlignmentBonus;
          return totalOffset > 0 ? totalOffset : 0;
      }

      function createSpeedBubbleDivIcon(routeColor, groundSpeed, scale, headingDeg) {
          if (!Number.isFinite(groundSpeed)) {
              return null;
          }
          const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
          const fillColor = typeof routeColor === 'string' && routeColor.trim().length > 0
              ? routeColor
              : BUS_MARKER_DEFAULT_ROUTE_COLOR;
          const textColor = computeBusMarkerGlyphColor(fillColor);
          const normalizedSpeed = Math.max(0, Math.round(groundSpeed));
          const label = `${normalizedSpeed} MPH`;
          const fontSize = Math.max(BUS_MARKER_LABEL_MIN_FONT_PX, SPEED_BUBBLE_BASE_FONT_PX * safeScale);
          const horizontalPadding = SPEED_BUBBLE_HORIZONTAL_PADDING * safeScale;
          const verticalPadding = SPEED_BUBBLE_VERTICAL_PADDING * safeScale;
          const textWidth = measureLabelTextWidth(label, fontSize);
          const width = Math.max(SPEED_BUBBLE_MIN_WIDTH * safeScale, textWidth + horizontalPadding * 2);
          const height = Math.max(SPEED_BUBBLE_MIN_HEIGHT * safeScale, fontSize + verticalPadding * 2);
          const radius = SPEED_BUBBLE_CORNER_RADIUS * safeScale;
          const strokeWidth = Math.max(1, LABEL_BASE_STROKE_WIDTH * safeScale);
          const svgWidth = roundToTwoDecimals(width);
          const svgHeight = roundToTwoDecimals(height);
          const radiusRounded = roundToTwoDecimals(radius);
          const strokeWidthRounded = roundToTwoDecimals(strokeWidth);
          const textX = roundToTwoDecimals(svgWidth / 2);
          const baselineShift = fontSize * LABEL_TEXT_VERTICAL_ADJUSTMENT_RATIO;
          const textY = roundToTwoDecimals(svgHeight / 2 + baselineShift);
          const anchorX = roundToTwoDecimals(svgWidth / 2);
          const leaderOffset = roundToTwoDecimals(computeLabelLeaderOffset(safeScale, headingDeg, 'below'));
          const anchorY = -leaderOffset;
          const svg = `
              <svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg" style="pointer-events: none;">
                  <g>
                      <rect x="0" y="0" width="${svgWidth}" height="${svgHeight}" rx="${radiusRounded}" ry="${radiusRounded}" fill="${fillColor}" stroke="white" stroke-width="${strokeWidthRounded}" />
                      <text x="${textX}" y="${textY}" dominant-baseline="middle" alignment-baseline="middle" text-anchor="middle" font-size="${roundToTwoDecimals(fontSize)}" font-weight="bold" fill="${textColor}" font-family="FGDC">${escapeHtml(label)}</text>
                  </g>
              </svg>`;
          return L.divIcon({
              html: svg,
              className: 'leaflet-div-icon bus-label-icon',
              iconSize: [svgWidth, svgHeight],
              iconAnchor: [anchorX, anchorY]
          });
      }

      function createNameBubbleDivIcon(busName, routeColor, scale, headingDeg) {
          if (typeof busName !== 'string' || busName.trim().length === 0) {
              return null;
          }
          const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
          const name = busName.trim();
          const fillColor = typeof routeColor === 'string' && routeColor.trim().length > 0
              ? routeColor
              : BUS_MARKER_DEFAULT_ROUTE_COLOR;
          const fontSize = Math.max(BUS_MARKER_LABEL_MIN_FONT_PX, NAME_BUBBLE_BASE_FONT_PX * safeScale);
          const horizontalPadding = NAME_BUBBLE_HORIZONTAL_PADDING * safeScale;
          const verticalPadding = NAME_BUBBLE_VERTICAL_PADDING * safeScale;
          const frameInset = NAME_BUBBLE_FRAME_INSET * safeScale;
          const textWidth = measureLabelTextWidth(name, fontSize);
          const rectWidth = Math.max(NAME_BUBBLE_MIN_WIDTH * safeScale, textWidth + horizontalPadding * 2);
          const rectHeight = Math.max(NAME_BUBBLE_MIN_HEIGHT * safeScale, fontSize + verticalPadding * 2);
          const svgWidth = roundToTwoDecimals(rectWidth);
          const svgHeight = roundToTwoDecimals(rectHeight + frameInset * 2);
          const radius = NAME_BUBBLE_CORNER_RADIUS * safeScale;
          const strokeWidth = Math.max(1, LABEL_BASE_STROKE_WIDTH * safeScale);
          const radiusRounded = roundToTwoDecimals(radius);
          const strokeWidthRounded = roundToTwoDecimals(strokeWidth);
          const rectY = roundToTwoDecimals(frameInset);
          const rectHeightRounded = roundToTwoDecimals(rectHeight);
          const textX = roundToTwoDecimals(svgWidth / 2);
          const baselineShift = fontSize * LABEL_TEXT_VERTICAL_ADJUSTMENT_RATIO;
          const textY = roundToTwoDecimals(rectY + rectHeight / 2 + baselineShift);
          const anchorX = textX;
          const leaderOffset = roundToTwoDecimals(computeLabelLeaderOffset(safeScale, headingDeg, 'above'));
          const anchorY = svgHeight + leaderOffset;
          const textColor = computeBusMarkerGlyphColor(fillColor);
          const fontSizeRounded = roundToTwoDecimals(fontSize);
          const svg = `
              <svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg" style="pointer-events: none;">
                  <g>
                      <rect x="0" y="${rectY}" width="${svgWidth}" height="${rectHeightRounded}" rx="${radiusRounded}" ry="${radiusRounded}" fill="${fillColor}" stroke="white" stroke-width="${strokeWidthRounded}" />
                      <text x="${textX}" y="${textY}" dominant-baseline="middle" alignment-baseline="middle" text-anchor="middle" font-size="${fontSizeRounded}" font-weight="bold" fill="${textColor}" font-family="FGDC">${escapeHtml(name)}</text>
                  </g>
              </svg>`;
          return L.divIcon({
              html: svg,
              className: 'leaflet-div-icon bus-label-icon',
              iconSize: [svgWidth, svgHeight],
              iconAnchor: [anchorX, anchorY]
          });
      }

      function createBlockBubbleDivIcon(blockName, routeColor, scale, headingDeg) {
          if (typeof blockName !== 'string' || blockName.trim() === '') {
              return null;
          }
          const safeScale = Number.isFinite(scale) && scale > 0 ? scale : 1;
          const name = blockName.trim();
          const fillColor = typeof routeColor === 'string' && routeColor.trim().length > 0
              ? routeColor
              : BUS_MARKER_DEFAULT_ROUTE_COLOR;
          const fontSize = Math.max(BUS_MARKER_LABEL_MIN_FONT_PX, BLOCK_BUBBLE_BASE_FONT_PX * safeScale);
          const horizontalPadding = BLOCK_BUBBLE_HORIZONTAL_PADDING * safeScale;
          const verticalPadding = BLOCK_BUBBLE_VERTICAL_PADDING * safeScale;
          const frameInset = BLOCK_BUBBLE_FRAME_INSET * safeScale;
          const textWidth = measureLabelTextWidth(name, fontSize);
          const rectWidth = Math.max(BLOCK_BUBBLE_MIN_WIDTH * safeScale, textWidth + horizontalPadding * 2);
          const rectHeight = Math.max(BLOCK_BUBBLE_MIN_HEIGHT * safeScale, fontSize + verticalPadding * 2);
          const svgWidth = roundToTwoDecimals(rectWidth);
          const svgHeight = roundToTwoDecimals(rectHeight + frameInset * 2);
          const radius = BLOCK_BUBBLE_CORNER_RADIUS * safeScale;
          const strokeWidth = Math.max(1, LABEL_BASE_STROKE_WIDTH * safeScale);
          const radiusRounded = roundToTwoDecimals(radius);
          const strokeWidthRounded = roundToTwoDecimals(strokeWidth);
          const rectY = roundToTwoDecimals(frameInset);
          const rectHeightRounded = roundToTwoDecimals(rectHeight);
          const textX = roundToTwoDecimals(svgWidth / 2);
          const baselineShift = fontSize * LABEL_TEXT_VERTICAL_ADJUSTMENT_RATIO;
          const textY = roundToTwoDecimals(rectY + rectHeight / 2 + baselineShift);
          const anchorX = textX;
          const leaderOffset = roundToTwoDecimals(computeLabelLeaderOffset(safeScale, headingDeg, 'below'));
          const anchorY = -leaderOffset;
          const textColor = computeBusMarkerGlyphColor(fillColor);
          const fontSizeRounded = roundToTwoDecimals(fontSize);
          const svg = `
              <svg width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg" style="pointer-events: none;">
                  <g>
                      <rect x="0" y="${rectY}" width="${svgWidth}" height="${rectHeightRounded}" rx="${radiusRounded}" ry="${radiusRounded}" fill="${fillColor}" stroke="white" stroke-width="${strokeWidthRounded}" />
                      <text x="${textX}" y="${textY}" dominant-baseline="middle" alignment-baseline="middle" text-anchor="middle" font-size="${fontSizeRounded}" font-weight="bold" fill="${textColor}" font-family="FGDC">${escapeHtml(name)}</text>
                  </g>
              </svg>`;
          return L.divIcon({
              html: svg,
              className: 'leaflet-div-icon bus-label-icon',
              iconSize: [svgWidth, svgHeight],
              iconAnchor: [anchorX, anchorY]
          });
      }

      function updateBusMarkerHeading(state, newPosition, fallbackHeading, groundSpeedMph) {
          if (!state) {
              return BUS_MARKER_DEFAULT_HEADING;
          }
          const lat = Array.isArray(newPosition) ? Number(newPosition[0]) : Number(newPosition?.lat ?? newPosition?.Latitude);
          const lng = Array.isArray(newPosition) ? Number(newPosition[1]) : Number(newPosition?.lng ?? newPosition?.Longitude);
          if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
              return state.headingDeg ?? BUS_MARKER_DEFAULT_HEADING;
          }
          const current = L.latLng(lat, lng);
          const history = Array.isArray(state.positionHistory) ? state.positionHistory : [];
          const previous = history.length > 0 ? history[history.length - 1] : null;
          let heading = Number.isFinite(state.headingDeg) ? state.headingDeg : BUS_MARKER_DEFAULT_HEADING;
          const sanitizedSpeedMph = Number.isFinite(groundSpeedMph) ? Math.max(0, groundSpeedMph) : null;
          const speedMetersPerSecond = sanitizedSpeedMph === null ? null : sanitizedSpeedMph * METERS_PER_SECOND_PER_MPH;
          const hasSufficientSpeed = speedMetersPerSecond === null || speedMetersPerSecond >= MIN_HEADING_SPEED_METERS_PER_SECOND;
          if (previous) {
              const distance = previous.distanceTo(current);
              const shouldUpdateHeading = distance >= MIN_HEADING_DISTANCE_METERS && hasSufficientSpeed;
              if (shouldUpdateHeading) {
                  const computed = computeBearingDegrees(previous, current);
                  if (Number.isFinite(computed)) {
                      heading = computed;
                  }
              } else if (!Number.isFinite(heading)) {
                  const fallback = Number.isFinite(fallbackHeading) ? fallbackHeading : BUS_MARKER_DEFAULT_HEADING;
                  heading = fallback;
              }
              if (distance >= MIN_POSITION_UPDATE_METERS) {
                  history.push(current);
                  if (history.length > 2) {
                      history.shift();
                  }
              } else {
                  history[history.length - 1] = current;
              }
          } else {
              const fallback = Number.isFinite(fallbackHeading) ? fallbackHeading : heading;
              heading = Number.isFinite(fallback) ? fallback : BUS_MARKER_DEFAULT_HEADING;
              history.push(current);
          }
          state.positionHistory = history;
          state.headingDeg = normalizeHeadingDegrees(heading);
          return state.headingDeg;
      }

      function computeBearingDegrees(fromLatLng, toLatLng) {
          if (!fromLatLng || !toLatLng) {
              return BUS_MARKER_DEFAULT_HEADING;
          }
          const lat1 = fromLatLng.lat * Math.PI / 180;
          const lat2 = toLatLng.lat * Math.PI / 180;
          const dLon = (toLatLng.lng - fromLatLng.lng) * Math.PI / 180;
          const y = Math.sin(dLon) * Math.cos(lat2);
          const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
          const theta = Math.atan2(y, x);
          const bearing = theta * 180 / Math.PI;
          return normalizeHeadingDegrees(bearing);
      }

      function normalizeHeadingDegrees(degrees) {
          const normalized = Number.isFinite(degrees) ? degrees : BUS_MARKER_DEFAULT_HEADING;
          return ((normalized % 360) + 360) % 360;
      }

      function buildBusMarkerAccessibleLabel(busName, headingDeg, groundSpeed) {
          const name = busName && `${busName}`.trim().length > 0 ? `${busName}`.trim() : 'Vehicle';
          const direction = bearingToDirection(headingDeg);
          const speedText = formatBusSpeed(groundSpeed);
          return `${name}  ${direction}  ${speedText}`;
      }

      function isBusConsideredStopped(groundSpeed) {
          if (!Number.isFinite(groundSpeed)) {
              return false;
          }
          const speed = Math.max(0, Math.round(groundSpeed));
          return speed <= 1;
      }

      function bearingToDirection(headingDeg) {
          if (!Number.isFinite(headingDeg)) {
              return 'Unknown direction';
          }
          const compass = [
              'Northbound',
              'Northeastbound',
              'Eastbound',
              'Southeastbound',
              'Southbound',
              'Southwestbound',
              'Westbound',
              'Northwestbound'
          ];
          const normalized = normalizeHeadingDegrees(headingDeg);
          const index = Math.round(normalized / 45) % compass.length;
          return compass[index];
      }

      function formatBusSpeed(groundSpeed) {
          if (!Number.isFinite(groundSpeed)) {
              return 'Speed unavailable';
          }
          const speed = Math.max(0, Math.round(groundSpeed));
          if (speed <= 1) {
              return 'Stopped';
          }
          return `${speed} mph`;
      }

      function escapeHtml(value) {
          if (value === null || value === undefined) {
              return '';
          }
          return `${value}`
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;');
      }

      function contrastBW(hex) {
          if (typeof hex !== 'string' || hex.trim().length === 0) {
              return '#FFFFFF';
          }
          let normalized = hex.trim().replace(/^#/, '');
          if (normalized.length === 3) {
              normalized = normalized.split('').map(ch => ch + ch).join('');
          }
          if (normalized.length !== 6 || /[^0-9a-fA-F]/.test(normalized)) {
              return '#FFFFFF';
          }
          const r = parseInt(normalized.substring(0, 2), 16) / 255;
          const g = parseInt(normalized.substring(2, 4), 16) / 255;
          const b = parseInt(normalized.substring(4, 6), 16) / 255;
          const L = 0.2126 * r + 0.7152 * g + 0.0722 * b;
          return L > 0.55 ? '#000000' : '#FFFFFF';
      }

      async function loadBusSVG() {
          if (BUS_MARKER_SVG_TEXT) {
              return BUS_MARKER_SVG_TEXT;
          }
          if (!BUS_MARKER_SVG_LOAD_PROMISE) {
              BUS_MARKER_SVG_LOAD_PROMISE = fetch(BUS_MARKER_SVG_URL)
                  .then(response => {
                      if (!response.ok) {
                          throw new Error(`Failed to load bus marker SVG: ${response.status} ${response.statusText}`);
                      }
                      return response.text();
                  })
                  .then(text => {
                      const template = document.createElement('template');
                      template.innerHTML = text.trim();
                      const parsedSvg = template.content.firstElementChild;
                      if (!parsedSvg || parsedSvg.tagName.toLowerCase() !== 'svg') {
                          throw new Error('Loaded bus marker asset is not a valid SVG.');
                      }
                      BUS_MARKER_SVG_TEXT = parsedSvg.outerHTML;
                      busMarkerVisibleExtents = null;
                      BUS_MARKER_SVG_LOAD_PROMISE = null;
                      return BUS_MARKER_SVG_TEXT;
                  })
                  .catch(error => {
                      BUS_MARKER_SVG_LOAD_PROMISE = null;
                      throw error;
                  });
          }
          return BUS_MARKER_SVG_LOAD_PROMISE;
      }

      async function createBusMarkerDivIcon(vehicleID, state) {
          if (!state) {
              return null;
          }
          try {
              await loadBusSVG();
          } catch (error) {
              console.error('Failed to load bus marker SVG:', error);
              return null;
          }
          if (!BUS_MARKER_SVG_TEXT) {
              return null;
          }
          if (!state.size) {
              const zoom = map && typeof map?.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM;
              setBusMarkerSize(state, computeBusMarkerMetrics(zoom));
          }
          const width = state.size?.widthPx ?? BUS_MARKER_BASE_WIDTH_PX;
          const height = state.size?.heightPx ?? width * BUS_MARKER_ASPECT_RATIO;
          const anchorX = width * BUS_MARKER_ICON_ANCHOR_X_RATIO;
          const anchorY = height * BUS_MARKER_ICON_ANCHOR_Y_RATIO;
          const headingDeg = Number.isFinite(state?.headingDeg) ? state.headingDeg : BUS_MARKER_DEFAULT_HEADING;
          const normalizedHeading = normalizeHeadingDegrees(headingDeg);
          const label = state?.accessibleLabel && state.accessibleLabel.trim().length > 0
              ? state.accessibleLabel.trim()
              : `Vehicle ${vehicleID}`;
          const template = document.createElement('template');
          template.innerHTML = BUS_MARKER_SVG_TEXT.trim();
          const svgEl = template.content.firstElementChild;
          if (!svgEl || svgEl.tagName.toLowerCase() !== 'svg') {
              return null;
          }
          svgEl.classList.add('bus-marker__svg');
          svgEl.setAttribute('viewBox', `0 0 ${BUS_MARKER_VIEWBOX_WIDTH} ${BUS_MARKER_VIEWBOX_HEIGHT}`);
          svgEl.setAttribute('preserveAspectRatio', 'xMidYMid meet');
          svgEl.setAttribute('focusable', 'false');
          svgEl.setAttribute('role', 'img');
          svgEl.setAttribute('aria-label', label);
          svgEl.setAttribute('overflow', 'visible');
          svgEl.style.width = '100%';
          svgEl.style.height = '100%';
          svgEl.style.transformOrigin = BUS_MARKER_TRANSFORM_ORIGIN;
          svgEl.style.transform = `rotate(${normalizedHeading.toFixed(2)}deg)`;

          const routeFillColor = normalizeRouteColor(state.fillColor);
          const glyphFillColor = normalizeGlyphColor(state.glyphColor, routeFillColor);
          state.fillColor = routeFillColor;
          state.glyphColor = glyphFillColor;
          ensureCenterSquareElement(svgEl);
          applyColorsToBusMarkerSvg(svgEl, routeFillColor, glyphFillColor);
          applyStoppedVisualStateToSvg(svgEl, state.isStopped);

          const existingTitle = svgEl.querySelector('title');
          let title = existingTitle;
          if (!title) {
              title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
              svgEl.insertBefore(title, svgEl.firstChild);
          }
          title.textContent = label;

          const rootClasses = ['bus-marker__root'];
          if (state?.isStale) rootClasses.push('is-stale');
          if (state?.isSelected) rootClasses.push('is-selected');
          if (state?.isHovered) rootClasses.push('is-hover');
          const root = document.createElement('div');
          root.className = rootClasses.join(' ');
          root.dataset.vehicleId = `${vehicleID}`;
          root.setAttribute('role', 'img');
          root.setAttribute('aria-label', label);
          root.style.pointerEvents = 'none';
          root.style.touchAction = 'none';
          root.style.cursor = 'default';
          root.appendChild(svgEl);

          const wrapper = document.createElement('div');
          wrapper.appendChild(root);

          return L.divIcon({
              html: wrapper.innerHTML,
              className: 'leaflet-div-icon bus-marker',
              iconSize: [width, height],
              iconAnchor: [anchorX, anchorY]
          });
      }

      function registerBusMarkerElements(vehicleID) {
          const state = busMarkerStates[vehicleID];
          const marker = markers[vehicleID];
          if (!state || !marker) {
              return null;
          }
          const iconElement = marker.getElement();
          if (!iconElement) {
              return null;
          }
          iconElement.style.pointerEvents = 'none';
          const root = iconElement.querySelector('.bus-marker__root');
          const svg = root ? root.querySelector('.bus-marker__svg') : null;
          const title = svg ? svg.querySelector('title') : null;
          const routeShape = svg ? svg.querySelector('#route_color') : null;
          const centerSquare = svg ? ensureCenterSquareElement(svg) : null;
          const centerRing = svg ? svg.querySelector(`#${BUS_MARKER_CENTER_RING_ID}`) : null;
          const heading = svg ? svg.querySelector('#heading') : null;
          state.elements = {
              icon: iconElement,
              root,
              svg,
              title,
              routeColor: routeShape,
              centerRing,
              centerSquare,
              heading
          };
          if (root) {
              root.dataset.vehicleId = `${vehicleID}`;
              root.style.pointerEvents = 'none';
              root.style.touchAction = 'none';
              root.style.cursor = 'default';
              if (root.hasAttribute('tabindex')) {
                  root.removeAttribute('tabindex');
              }
              if (root.dataset && root.dataset.busMarkerFocusBound) {
                  delete root.dataset.busMarkerFocusBound;
              }
          }
          if (svg) {
              svg.style.pointerEvents = 'none';
              svg.style.transformOrigin = BUS_MARKER_TRANSFORM_ORIGIN;
          }
          updateBusMarkerColorElements(state);
          applyBusMarkerStoppedVisualState(state);
          return state.elements;
      }

      function queueBusMarkerVisualUpdate(vehicleID, update = {}) {
          if (!vehicleID) {
              return;
          }
          const existing = pendingBusVisualUpdates.get(vehicleID) || {};
          Object.assign(existing, update);
          pendingBusVisualUpdates.set(vehicleID, existing);
          if (busMarkerVisualUpdateFrame === null) {
              busMarkerVisualUpdateFrame = requestAnimationFrame(flushBusMarkerVisualUpdates);
          }
      }

      function flushBusMarkerVisualUpdates() {
          busMarkerVisualUpdateFrame = null;
          pendingBusVisualUpdates.forEach((update, vehicleID) => {
              applyBusMarkerVisualUpdate(vehicleID, update);
          });
          pendingBusVisualUpdates.clear();
      }

      function applyBusMarkerVisualUpdate(vehicleID, update) {
          const state = busMarkerStates[vehicleID];
          if (!state) {
              return;
          }
          const elements = state.elements || registerBusMarkerElements(vehicleID);
          if (!elements || !elements.root) {
              return;
          }
          if (update && Object.prototype.hasOwnProperty.call(update, 'fillColor')) {
              state.fillColor = update.fillColor;
          }
          if (update && Object.prototype.hasOwnProperty.call(update, 'glyphColor')) {
              state.glyphColor = update.glyphColor;
          }
          updateBusMarkerColorElements(state);
          if (update && typeof update.stale === 'boolean') {
              state.isStale = update.stale;
          }
          if (update && typeof update.accessibleLabel === 'string') {
              state.accessibleLabel = update.accessibleLabel;
          }
          if (update && Number.isFinite(update.headingDeg)) {
              state.headingDeg = normalizeHeadingDegrees(update.headingDeg);
          }
          if (update && Object.prototype.hasOwnProperty.call(update, 'stopped')) {
              state.isStopped = Boolean(update.stopped);
          }
          applyBusMarkerStoppedVisualState(state);
          const rotationDeg = normalizeHeadingDegrees(Number.isFinite(state.headingDeg) ? state.headingDeg : BUS_MARKER_DEFAULT_HEADING);
          if (elements.svg) {
              elements.svg.style.transform = `rotate(${rotationDeg.toFixed(2)}deg)`;
              if (state.accessibleLabel) {
                  elements.svg.setAttribute('aria-label', state.accessibleLabel);
              }
          }
          if (elements.root && state.accessibleLabel) {
              elements.root.setAttribute('aria-label', state.accessibleLabel);
          }
          if (elements.title && state.accessibleLabel) {
              elements.title.textContent = state.accessibleLabel;
          }
          updateBusMarkerRootClasses(state);
          updateBusMarkerZIndex(state);
          applyBusMarkerOutlineWidth(state);
      }

      function applyBusMarkerOutlineWidth(state) {
          if (!state?.elements?.svg) {
              return;
          }
          state.elements.svg.style.opacity = state.isStale ? '0.6' : '1';
      }

      function updateBusMarkerRootClasses(state) {
          if (!state?.elements?.root) {
              return;
          }
          const root = state.elements.root;
          root.classList.toggle('is-stale', Boolean(state.isStale));
          root.classList.toggle('is-selected', Boolean(state.isSelected));
          root.classList.toggle('is-hover', Boolean(state.isHovered));
      }

      function updateBusMarkerZIndex(state) {
          if (!state?.marker) {
              return;
          }
          let offset = 0;
          if (state.isSelected) {
              offset = 800;
          }
          if (state.isHovered) {
              offset = Math.max(offset, 1000);
          }
          state.marker.setZIndexOffset(offset);
      }

      function setBusMarkerHovered(vehicleID, isHovered) {
          const state = busMarkerStates[vehicleID];
          if (!state) {
              return;
          }
          const next = Boolean(isHovered);
          if (state.isHovered === next) {
              return;
          }
          state.isHovered = next;
          updateBusMarkerRootClasses(state);
          updateBusMarkerZIndex(state);
          applyBusMarkerOutlineWidth(state);
      }

      function setBusMarkerSelected(vehicleID, isSelected) {
          const state = busMarkerStates[vehicleID];
          if (!state) {
              return;
          }
          const next = Boolean(isSelected);
          if (state.isSelected === next) {
              return;
          }
          state.isSelected = next;
          updateBusMarkerRootClasses(state);
          updateBusMarkerZIndex(state);
          applyBusMarkerOutlineWidth(state);
      }

      function attachBusMarkerInteractions(vehicleID) {
          const state = busMarkerStates[vehicleID];
          const marker = markers[vehicleID];
          if (!state || !marker) {
              return;
          }
          if (typeof marker.off === 'function') {
              marker.off();
          }
          if (marker.options) {
              marker.options.interactive = false;
              marker.options.keyboard = false;
          }
          if (selectedVehicleId === vehicleID) {
              selectedVehicleId = null;
          }
          if (state.isHovered || state.isSelected) {
              state.isHovered = false;
              state.isSelected = false;
              updateBusMarkerRootClasses(state);
              updateBusMarkerZIndex(state);
              applyBusMarkerOutlineWidth(state);
          }
          const elements = state.elements || registerBusMarkerElements(vehicleID);
          const icon = elements?.icon;
          const root = elements?.root;
          const svg = elements?.svg;
          if (icon) {
              icon.style.pointerEvents = 'none';
          }
          if (root) {
              root.style.pointerEvents = 'none';
              root.style.touchAction = 'none';
              root.style.cursor = 'default';
              if (root.hasAttribute('tabindex')) {
                  root.removeAttribute('tabindex');
              }
              if (root.dataset && root.dataset.busMarkerFocusBound) {
                  delete root.dataset.busMarkerFocusBound;
              }
          }
          if (svg) {
              svg.style.pointerEvents = 'none';
          }
          state.markerEventsBound = false;
      }

      async function updateBusMarkerSizes(metricsOverride = null) {
          if (!map) {
              return;
          }
          const zoom = typeof map.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM;
          const metrics = metricsOverride || computeBusMarkerMetrics(zoom);
          try {
              await loadBusSVG();
          } catch (error) {
              console.error('Failed to load bus marker SVG while updating sizes:', error);
          }
          for (const vehicleID of Object.keys(markers)) {
              const marker = markers[vehicleID];
              const state = busMarkerStates[vehicleID];
              if (!marker || !state) {
                  continue;
              }
              const currentWidth = state.size?.widthPx;
              if (currentWidth && Math.abs(currentWidth - metrics.widthPx) < 0.1) {
                  continue;
              }
              setBusMarkerSize(state, metrics);
              try {
                  const icon = await createBusMarkerDivIcon(vehicleID, state);
                  if (!icon) {
                      continue;
                  }
                  marker.setIcon(icon);
                  registerBusMarkerElements(vehicleID);
                  attachBusMarkerInteractions(vehicleID);
                  updateBusMarkerRootClasses(state);
                  updateBusMarkerZIndex(state);
                  applyBusMarkerOutlineWidth(state);
              } catch (error) {
                  console.error(`Failed to resize bus marker for vehicle ${vehicleID}:`, error);
              }
          }
          updateLabelIconsForMetrics(metrics);
      }

      function updateLabelIconsForMetrics(metrics) {
          if (!metrics || !Number.isFinite(metrics.scale) || !map) {
              return;
          }
          const scale = metrics.scale;
          Object.keys(nameBubbles).forEach(vehicleID => {
              const bubble = nameBubbles[vehicleID];
              const state = busMarkerStates[vehicleID];
              const marker = markers[vehicleID];
              if (!bubble || !state || !marker) {
                  return;
              }
              const routeColor = state.fillColor || getRouteColor(state.routeID) || outOfServiceRouteColor;
              const speedMarker = bubble.speedMarker;
              const nameMarker = bubble.nameMarker;
              const blockMarker = bubble.blockMarker;

              if (speedMarker) {
                  if (adminMode && displayMode === DISPLAY_MODES.SPEED && !kioskMode && Number.isFinite(state.groundSpeed)) {
                      const speedIcon = createSpeedBubbleDivIcon(routeColor, state.groundSpeed, scale, state.headingDeg);
                      if (speedIcon) {
                          speedMarker.setIcon(speedIcon);
                      } else {
                          map.removeLayer(speedMarker);
                          delete bubble.speedMarker;
                      }
                  } else {
                      map.removeLayer(speedMarker);
                      delete bubble.speedMarker;
                  }
              }

              if (nameMarker) {
                  if (adminMode && !kioskMode) {
                      const nameIcon = createNameBubbleDivIcon(state.busName, routeColor, scale, state.headingDeg);
                      if (nameIcon) {
                          nameMarker.setIcon(nameIcon);
                      } else {
                          map.removeLayer(nameMarker);
                          delete bubble.nameMarker;
                      }
                  } else {
                      map.removeLayer(nameMarker);
                      delete bubble.nameMarker;
                  }
              }

              if (blockMarker) {
                  const blockName = busBlocks[vehicleID];
                  if (adminMode && !kioskMode && displayMode === DISPLAY_MODES.BLOCK && blockName && blockName.includes('[')) {
                      const blockIcon = createBlockBubbleDivIcon(blockName, routeColor, scale, state.headingDeg);
                      if (blockIcon) {
                          blockMarker.setIcon(blockIcon);
                      } else {
                          map.removeLayer(blockMarker);
                          delete bubble.blockMarker;
                      }
                  } else {
                      map.removeLayer(blockMarker);
                      delete bubble.blockMarker;
                  }
              }

              const hasMarkers = Boolean(bubble.speedMarker || bubble.nameMarker || bubble.blockMarker);
              if (hasMarkers) {
                  bubble.lastScale = scale;
              } else {
                  delete nameBubbles[vehicleID];
              }
          });
      }

      function scheduleMarkerScaleUpdate() {
          if (!map) {
              return;
          }
          const zoom = typeof map.getZoom === 'function' ? map.getZoom() : BUS_MARKER_BASE_ZOOM;
          const metrics = computeBusMarkerMetrics(zoom);
          pendingMarkerScaleMetrics = Object.assign({}, metrics);
          if (markerScaleUpdateFrame !== null) {
              return;
          }
          markerScaleUpdateFrame = requestAnimationFrame(async () => {
              markerScaleUpdateFrame = null;
              const metricsToApply = pendingMarkerScaleMetrics;
              pendingMarkerScaleMetrics = null;
              if (!metricsToApply) {
                  return;
              }
              try {
                  await updateBusMarkerSizes(metricsToApply);
              } catch (error) {
                  console.error('Failed to update bus marker sizes:', error);
              }
          });
      }

      function clearBusMarkerState(vehicleID) {
          pendingBusVisualUpdates.delete(vehicleID);
          if (selectedVehicleId === vehicleID) {
              selectedVehicleId = null;
          }
          if (busMarkerStates[vehicleID]) {
              delete busMarkerStates[vehicleID];
          }
      }

      function isVehicleGpsStale(vehicle) {
          if (!vehicle) {
              return false;
          }
          if (vehicle.IsStale === true || vehicle.Stale === true || vehicle.StaleGPS === true) {
              return true;
          }
          if (vehicle.HasValidGps === false || vehicle.IsRealtime === false) {
              return true;
          }
          const ageFields = [
              vehicle.SecondsSinceReport,
              vehicle.SecondsSinceLastReport,
              vehicle.SecondsSinceLastUpdate,
              vehicle.SecondsSinceUpdate,
              vehicle.SecondsSinceLastGps,
              vehicle.LastGpsAgeSeconds,
              vehicle.LocationAge,
              vehicle.GPSSignalAge,
              vehicle.Age,
              vehicle.AgeInSeconds
          ];
          for (let i = 0; i < ageFields.length; i += 1) {
              const value = Number(ageFields[i]);
              if (Number.isFinite(value) && value > GPS_STALE_THRESHOLD_SECONDS) {
                  return true;
              }
          }
          return false;
      }

      function animateMarkerTo(marker, newPosition) {
        if (!marker || !newPosition) return;
        const hasArrayPosition = Array.isArray(newPosition) && newPosition.length >= 2;
        const endPos = hasArrayPosition ? L.latLng(newPosition) : L.latLng(newPosition?.lat, newPosition?.lng);
        if (!endPos || Number.isNaN(endPos.lat) || Number.isNaN(endPos.lng)) return;

        const startPos = marker.getLatLng();
        if (!startPos) {
          marker.setLatLng(endPos);
          return;
        }

        const positionsMatch = typeof startPos.equals === 'function'
          ? startPos.equals(endPos, 1e-7)
          : (Math.abs(startPos.lat - endPos.lat) < 1e-7 && Math.abs(startPos.lng - endPos.lng) < 1e-7);

        if (positionsMatch) {
          marker.setLatLng(endPos);
          return;
        }

        const duration = 1000;
        const startTime = performance.now();
        function animate(time) {
          const elapsed = time - startTime;
          const t = Math.min(elapsed / duration, 1);
          const currentPos = L.latLng(
            startPos.lat + t * (endPos.lat - startPos.lat),
            startPos.lng + t * (endPos.lng - startPos.lng)
          );
          marker.setLatLng(currentPos);
          if (t < 1) requestAnimationFrame(animate);
        }
        requestAnimationFrame(animate);
      }

      document.addEventListener("DOMContentLoaded", () => {
        initializePanelStateForViewport();
        beginAgencyLoad();
        loadAgencies()
          .then(() => {
            initMap();
            showCookieBanner();
            enforceIncidentVisibilityForCurrentAgency();
            return loadAgencyData()
              .then(() => {
                startRefreshIntervals();
              });
          })
          .catch(error => {
            console.error('Error during initial load:', error);
          })
          .finally(() => {
            completeAgencyLoad();
          });
      });
    </script>
  </head>
  <body>
    <div id="map"></div>
    <div id="routeLegend" aria-live="polite"></div>
    <div id="controlPanel" class="selector-panel"></div>
    <div id="routeSelector" class="selector-panel"></div>
    <div id="controlPanelTab" class="panel-toggle panel-toggle--left" onclick="toggleControlPanel()" title="Toggle system controls">
      <span class="panel-toggle__arrow" aria-hidden="true">&#9654;</span>
      <span id="controlPanelAlertBadge" class="panel-toggle__badge" hidden></span>
    </div>
    <div id="routeSelectorTab" class="panel-toggle panel-toggle--right" onclick="toggleRoutePanel()" title="Toggle route selector">
      <span class="panel-toggle__arrow" aria-hidden="true">&#9664;</span>
    </div>
    <div class="credit">proof of concept created by pat cox  phc6j@virginia.edu</div>
    <div id="cookieBanner" class="cookie-banner" style="display:none;">
      This site stores your selected transit agency on your device to remember your preference.
      <button id="cookieAccept">OK</button>
    </div>
    <div id="loadingOverlay" class="loading-overlay" aria-live="polite" aria-busy="false">
      <div class="loading-overlay__inner">
        <div class="loading-overlay__spinner" aria-hidden="true"></div>
        <div class="loading-overlay__text">Loading agency data</div>
      </div>
    </div>
  </body>
</html>
