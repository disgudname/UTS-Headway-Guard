<!DOCTYPE html>
<html>
<head>
  <title>Replay Map - Headway Guard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@mapbox/polyline@1.1.1"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <style>
    @font-face {
      font-family: 'FGDC';
      src: url('FGDC.ttf') format('truetype');
    }
    :root {
      --controls-height: 90px;
    }
    html, body { height: 100%; margin: 0; font-family: 'FGDC', sans-serif; overflow: hidden; }
    #map { height: calc(100% - var(--controls-height)); width: 100%; }
    #controls { position: fixed; bottom: 0; left: 0; width: 100%; background: rgba(255,255,255,0.9); display: flex; flex-wrap: wrap; align-items: center; padding: 5px; box-sizing: border-box; z-index: 1000; }
    #controls > * { margin: 2px; }
    #controls input, #controls button {
      padding: 6px;
      font-size: 14px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    #controls button.selected {
      background-color: #ccc;
    }
    #controls button.speed-btn {
      font-family: sans-serif;
      font-size: 16px;
      font-weight: bold;
    }
    #timeline { flex: 1; margin: 0 10px; }
    #busSelector {
      width: 300px;
      position: fixed;
      top: 10px;
      left: 10px;
      bottom: calc(var(--controls-height) + 20px);
      z-index: 1100;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      overflow-y: auto;
      transition: transform 0.3s ease;
      font-size: 21px;
    }
    #busSelector.hidden { transform: translateX(-320px); }
    #busSelector h3 { margin-top: 0; }
    #busSelector button {
      margin: 5px 2px;
      padding: 5px 10px;
      font-size: 24px;
      font-family: 'FGDC', sans-serif;
      background-color: #E57200;
      color: black;
      border: none;
      border-radius: 20px;
      cursor: pointer;
    }
    #busSelector label { display: block; margin-bottom: 5px; cursor: pointer; }
    #busSelectorTab {
      position: fixed;
      top: 50%;
      left: 0;
      width: 30px;
      height: 60px;
      background: #ccc;
      border-top-right-radius: 10px;
      border-bottom-right-radius: 10px;
      cursor: pointer;
      display: block;
      transform: translateY(-50%);
      z-index: 1150;
      text-align: center;
      line-height: 60px;
      font-size: 20px;
      user-select: none;
      transition: left 0.3s ease;
    }
    #routeSelector {
      width: 300px;
      position: fixed;
      top: 10px;
      right: 10px;
      bottom: calc(var(--controls-height) + 20px);
      z-index: 1100;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      overflow-y: auto;
      transition: transform 0.3s ease;
      font-size: 21px;
    }
    #routeSelector.hidden { transform: translateX(320px); }
    #routeSelector h3 { margin-top: 0; }
    #routeSelector button {
      margin: 5px 2px;
      padding: 5px 10px;
      font-size: 24px;
      font-family: 'FGDC', sans-serif;
      background-color: #E57200;
      color: black;
      border: none;
      border-radius: 20px;
      cursor: pointer;
    }
    #routeSelector label { display: block; margin-bottom: 5px; cursor: pointer; }
    #routeSelector .color-box {
      display: inline-block;
      width: 12px;
      height: 12px;
      margin-right: 5px;
      vertical-align: middle;
    }
    #routeSelectorTab {
      position: fixed;
      top: 50%;
      right: 0;
      width: 30px;
      height: 60px;
      background: #ccc;
      border-top-left-radius: 10px;
      border-bottom-left-radius: 10px;
      cursor: pointer;
      display: block;
      transform: translateY(-50%);
      z-index: 1150;
      text-align: center;
      line-height: 60px;
      font-size: 20px;
      user-select: none;
      transition: right 0.3s ease;
    }
    @media (max-width: 600px) {
      :root { --controls-height: 180px; }
      #busSelector { width: 80%; left: 10%; font-size: 18px; bottom: calc(var(--controls-height) + 20px); }
      #busSelector.hidden { transform: translateX(calc(-100% - 20px)); }
      #busSelector button { font-size: 20px; }
      #busSelector label { font-size: 18px; }
      #busSelectorTab { width: 40px; height: 80px; font-size: 28px; }
      #routeSelector { width: 80%; right: 10%; font-size: 18px; bottom: calc(var(--controls-height) + 20px); }
      #routeSelector.hidden { transform: translateX(calc(100% + 20px)); }
      #routeSelector button { font-size: 20px; }
      #routeSelector label { font-size: 18px; }
      #routeSelectorTab { width: 40px; height: 80px; font-size: 28px; }
      #timeline { flex: 1 0 100%; }
      #timeLabel { flex: 0 0 100%; text-align: center; }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div id="busSelector" class="hidden"></div>
  <div id="busSelectorTab" onclick="toggleBusPanel()">&#9664;</div>
  <div id="routeSelector" class="hidden"></div>
  <div id="routeSelectorTab" onclick="togglePanel()">&#9654;</div>
  <div id="controls">
    <label for="datePicker">Date</label>
    <input id="datePicker" placeholder="Date">
    <label for="startTime">From</label>
    <input id="startTime" placeholder="Start time">
    <label for="endTime">To</label>
    <input id="endTime" placeholder="End time">
    <button id="loadRangeBtn">Load</button>
    <button id="pauseBtn">&#10074;&#10074;</button>
    <button id="playBtn" class="speed-btn">1x</button>
    <button id="ff2Btn" class="speed-btn">2x</button>
    <button id="ff4Btn" class="speed-btn">4x</button>
    <button id="ff8Btn" class="speed-btn">8x</button>
    <button id="ff10Btn" class="speed-btn">10x</button>
    <button id="ff30Btn" class="speed-btn">30x</button>
    <button id="ff100Btn" class="speed-btn">100x</button>
    <button id="ff200Btn" class="speed-btn">200x</button>
    <input type="range" id="timeline" min="0" value="0">
    <span id="timeLabel"></span>
  </div>
  <script>
    let map = L.map('map', { zoomControl: false }).setView([38.03799212281404, -78.50981502838886], 15);
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    flatpickr("#datePicker", {
      dateFormat: "Y-m-d",
      defaultDate: new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' })
    });
    flatpickr("#startTime", {
      enableTime: true,
      noCalendar: true,
      dateFormat: "H:i",
      time_24hr: true,
      defaultDate: "00:00"
    });
    flatpickr("#endTime", {
      enableTime: true,
      noCalendar: true,
      dateFormat: "H:i",
      time_24hr: true,
      defaultDate: "23:59"
    });

    let playbackData = [];
    let playbackTimes = [];
    let startTime = null;
    let endTime = null;
    let userEndTime = null;
    let loadedHours = new Set();
    let markers = {};
    let nameMarkers = {};
    let speedMarkers = {};
    let blockMarkers = {};
    let routeLayers = [];
    let timer = null;       // handle for scheduled frame advance
    let playbackSpeed = 1;  // 1x, 2x, 4x, 8x, 10x, 30x, 100x, 200x
    let routeColors = {};
    let allRoutes = {};
    let routeSelections = {};
    let activeRoutes = new Set();
    let allBuses = {};
    let busSelections = {};
    let activeBuses = new Set();
    let showSpeed = true; // default to showing speed
    let showBlockNumbers = false;
    let showLabels = true;
    let lastPositions = {};
    let currentFrameIndex = 0;
    const outOfServiceRouteColor = '#000000';
    let isPlaying = false;
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const ff2Btn = document.getElementById('ff2Btn');
    const ff4Btn = document.getElementById('ff4Btn');
    const ff8Btn = document.getElementById('ff8Btn');
    const ff10Btn = document.getElementById('ff10Btn');
    const ff30Btn = document.getElementById('ff30Btn');
    const ff100Btn = document.getElementById('ff100Btn');
    const ff200Btn = document.getElementById('ff200Btn');

    function positionBusTab() {
      const panel = document.getElementById('busSelector');
      const tab = document.getElementById('busSelectorTab');
      if (!panel || !tab) return;
      const panelStyle = window.getComputedStyle(panel);
      const gap = parseFloat(panelStyle.left) || 0;
      const offset = panel.offsetWidth + gap;
      tab.style.left = panel.classList.contains('hidden') ? '0' : offset + 'px';
    }

    function positionRouteTab() {
      const panel = document.getElementById('routeSelector');
      const tab = document.getElementById('routeSelectorTab');
      if (!panel || !tab) return;
      const panelStyle = window.getComputedStyle(panel);
      const gap = parseFloat(panelStyle.right) || 0;
      const offset = panel.offsetWidth + gap;
      tab.style.right = panel.classList.contains('hidden') ? '0' : offset + 'px';
    }

    function updateControlsHeight() {
      const controls = document.getElementById('controls');
      if (!controls) return;
      const height = controls.offsetHeight;
      document.documentElement.style.setProperty('--controls-height', height + 'px');
    }
    window.addEventListener('load', () => {
      positionBusTab();
      positionRouteTab();
      updateControlsHeight();
      if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(updateControlsHeight);
      }
    });
    window.addEventListener('resize', () => { positionBusTab(); positionRouteTab(); updateControlsHeight(); });

    function updateSpeedButtons() {
      playBtn.classList.remove('selected');
      pauseBtn.classList.remove('selected');
      ff2Btn.classList.remove('selected');
      ff4Btn.classList.remove('selected');
      ff8Btn.classList.remove('selected');
      ff10Btn.classList.remove('selected');
      ff30Btn.classList.remove('selected');
      ff100Btn.classList.remove('selected');
      ff200Btn.classList.remove('selected');
      if (!isPlaying) {
        pauseBtn.classList.add('selected');
      } else if (playbackSpeed === 1) {
        playBtn.classList.add('selected');
      } else if (playbackSpeed === 2) {
        ff2Btn.classList.add('selected');
      } else if (playbackSpeed === 4) {
        ff4Btn.classList.add('selected');
      } else if (playbackSpeed === 8) {
        ff8Btn.classList.add('selected');
      } else if (playbackSpeed === 10) {
        ff10Btn.classList.add('selected');
      } else if (playbackSpeed === 30) {
        ff30Btn.classList.add('selected');
      } else if (playbackSpeed === 100) {
        ff100Btn.classList.add('selected');
      } else if (playbackSpeed === 200) {
        ff200Btn.classList.add('selected');
      }
    }

    function fetchRoutes() {
      return fetch('/v1/transloc/routes')
        .then(r => r.json())
        .then(data => {
          if (Array.isArray(data)) {
            data.forEach(route => {
              routeColors[route.RouteID] = route.MapLineColor;
              allRoutes[route.RouteID] = route;
              if (route.EncodedPolyline) {
                allRoutes[route.RouteID].decodedPolyline = polyline.decode(route.EncodedPolyline);
              }
            });
          }
        })
        .catch(err => console.error('Error fetching routes', err));
    }

    function getContrastColor(hexColor) {
      hexColor = hexColor.replace('#', '');
      const r = parseInt(hexColor.substring(0,2), 16);
      const g = parseInt(hexColor.substring(2,4), 16);
      const b = parseInt(hexColor.substring(4,6), 16);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.5 ? '#000000' : '#FFFFFF';
    }

    function getRouteColor(routeID) {
      if (routeID === 0) return outOfServiceRouteColor;
      return routeColors[routeID] || '#000000';
    }

    function isRouteSelected(routeID) {
      if (routeSelections.hasOwnProperty(routeID)) return routeSelections[routeID];
      return activeRoutes.has(Number(routeID));
    }

    function isBusSelected(busID) {
      if (busSelections.hasOwnProperty(busID)) return busSelections[busID];
      return activeBuses.has(Number(busID));
    }

    function refreshReplay() {
      const timeline = document.getElementById('timeline');
      const ms = parseInt(timeline.value);
      showFrame(currentFrameIndex, isNaN(ms) ? undefined : ms);
    }

    // Toggle between displaying speed or block numbers.
    function toggleSpeedOrBlock() {
      if (showSpeed) {
        showSpeed = false;
        showBlockNumbers = true;
      } else {
        showSpeed = true;
        showBlockNumbers = false;
      }
      const btn = document.getElementById('toggleDisplayButton');
      if (btn) btn.innerHTML = showSpeed ? 'Show Block Numbers' : 'Show Speed';
      refreshReplay();
    }

    function toggleLabels() {
      showLabels = !showLabels;
      const btn = document.getElementById('toggleLabelsButton');
      if (btn) btn.innerHTML = showLabels ? 'Hide Labels' : 'Show Labels';
      refreshReplay();
    }

    function updateBusSelector(activeBusesSet) {
      const container = document.getElementById('busSelector');
      if (!container) return;
      let busIDs = Object.keys(allBuses).map(Number);
      busIDs.sort((a,b) => {
        let nameA = allBuses[a].toUpperCase();
        let nameB = allBuses[b].toUpperCase();
        if (nameA < nameB) return -1;
        if (nameA > nameB) return 1;
        return 0;
      });
      let html = "<h3>Select Buses</h3>" +
        "<button onclick='selectAllBuses()'>Select All</button>" +
        "<button onclick='deselectAllBuses()'>Deselect All</button><br/><br/>";
      busIDs.forEach(id => {
        let checked = busSelections.hasOwnProperty(id) ? busSelections[id] : activeBusesSet.has(id);
        let name = allBuses[id] || id;
        html += `<label><input type="checkbox" id="bus_${id}" value="${id}" ${checked ? "checked" : ""}> ${name}</label>`;
      });
      container.innerHTML = html;
      busIDs.forEach(id => {
        let chk = document.getElementById('bus_' + id);
        if (chk) {
          chk.addEventListener('change', function() {
            busSelections[id] = chk.checked;
            refreshReplay();
          });
        }
      });
    }

    function selectAllBuses() {
      for (let id in allBuses) {
        let chk = document.getElementById('bus_' + id);
        if (chk) chk.checked = true;
        busSelections[id] = true;
      }
      refreshReplay();
    }

    function deselectAllBuses() {
      for (let id in allBuses) {
        let chk = document.getElementById('bus_' + id);
        if (chk) chk.checked = false;
        busSelections[id] = false;
      }
      refreshReplay();
    }

    function toggleBusPanel() {
      let panel = document.getElementById('busSelector');
      let tab = document.getElementById('busSelectorTab');
      let routePanel = document.getElementById('routeSelector');
      let routeTab = document.getElementById('routeSelectorTab');
      const willOpen = panel.classList.contains('hidden');
      if (willOpen) {
        panel.classList.remove('hidden');
        tab.innerHTML = '&#9654;';
        if (routePanel) routePanel.classList.add('hidden');
        if (routeTab) {
          routeTab.innerHTML = '&#9654;';
          routeTab.style.display = 'none';
        }
      } else {
        panel.classList.add('hidden');
        tab.innerHTML = '&#9664;';
        if (routeTab) routeTab.style.display = 'block';
      }
      positionBusTab();
      positionRouteTab();
    }

    function updateRouteSelector(activeRoutes) {
      const container = document.getElementById('routeSelector');
      if (!container) return;
      let html = "";
      html += "<div style='margin-bottom:10px;'>" +
        "<button id='toggleLabelsButton' onclick='toggleLabels()'>" + (showLabels ? "Hide Labels" : "Show Labels") + "</button>" +
        "<button id='toggleDisplayButton' onclick='toggleSpeedOrBlock()'>" + (showSpeed ? "Show Block Numbers" : "Show Speed") + "</button>" +
        "</div>";
      html += "<h3>Select Routes</h3>" +
        "<button onclick='selectAllRoutes()'>Select All</button>" +
        "<button onclick='deselectAllRoutes()'>Deselect All</button><br/><br/>";

      let outChecked = routeSelections.hasOwnProperty(0) ? routeSelections[0] : activeRoutes.has(0);
      html += `<label>
            <input type="checkbox" id="route_0" value="0" ${outChecked ? "checked" : ""}>
            <span class="color-box" style="background:${outOfServiceRouteColor};"></span> Out of Service
          </label>`;

      let routeIDs = Object.keys(allRoutes).map(Number).filter(id => id !== 0);
      routeIDs.sort((a,b) => {
        let descA = allRoutes[a].Description.toUpperCase();
        let descB = allRoutes[b].Description.toUpperCase();
        if (descA < descB) return -1;
        if (descA > descB) return 1;
        return 0;
      });

      routeIDs.forEach(routeID => {
        let route = allRoutes[routeID];
        let checked = routeSelections.hasOwnProperty(routeID) ? routeSelections[routeID] : activeRoutes.has(routeID);
        let displayName = route.Description;
        if (route.InfoText && route.InfoText.trim() !== "") {
          displayName += ` &ndash; ${route.InfoText.trim()}`;
        }
        html += `<label>
            <input type="checkbox" id="route_${routeID}" value="${routeID}" ${checked ? "checked" : ""}>
            <span class="color-box" style="background:${route.MapLineColor};"></span> ${displayName}
          </label>`;
      });

      container.innerHTML = html;

      let outChk = document.getElementById('route_0');
      if (outChk) {
        outChk.addEventListener('change', function() {
          routeSelections[0] = outChk.checked;
          refreshReplay();
        });
      }
      routeIDs.forEach(routeID => {
        let chk = document.getElementById('route_' + routeID);
        if (chk) {
          chk.addEventListener('change', function() {
            routeSelections[routeID] = chk.checked;
            refreshReplay();
          });
        }
      });
    }

    function selectAllRoutes() {
      let outChk = document.getElementById('route_0');
      if (outChk) outChk.checked = true;
      for (let routeID in allRoutes) {
        let chk = document.getElementById('route_' + routeID);
        if (chk) chk.checked = true;
        routeSelections[routeID] = true;
      }
      routeSelections[0] = true;
      refreshReplay();
    }

    function deselectAllRoutes() {
      let outChk = document.getElementById('route_0');
      if (outChk) outChk.checked = false;
      for (let routeID in allRoutes) {
        let chk = document.getElementById('route_' + routeID);
        if (chk) chk.checked = false;
        routeSelections[routeID] = false;
      }
      routeSelections[0] = false;
      refreshReplay();
    }

    function togglePanel() {
      let panel = document.getElementById('routeSelector');
      let tab = document.getElementById('routeSelectorTab');
      let busPanel = document.getElementById('busSelector');
      let busTab = document.getElementById('busSelectorTab');
      const willOpen = panel.classList.contains('hidden');
      if (willOpen) {
        panel.classList.remove('hidden');
        tab.innerHTML = '&#9664;';
        if (busPanel) busPanel.classList.add('hidden');
        if (busTab) {
          busTab.innerHTML = '&#9664;';
          busTab.style.display = 'none';
        }
      } else {
        panel.classList.add('hidden');
        tab.innerHTML = '&#9654;';
        if (busTab) busTab.style.display = 'block';
      }
      positionRouteTab();
      positionBusTab();
    }

    function hourKey(ms) {
      const d = new Date(ms);
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      const h = String(d.getHours()).padStart(2, '0');
      return `${y}${m}${day}_${h}`;
    }

    async function loadHour(ms) {
      const key = hourKey(ms);
      if (loadedHours.has(key)) return;
      try {
        const resp = await fetch(`/vehicle_log/${key}.jsonl`, { cache: 'no-store' });
        if (!resp.ok) { loadedHours.add(key); return; }
        const text = await resp.text();
        if (!text.trim()) { loadedHours.add(key); return; }
        const entries = text
          .split('\n')
          .filter(l => l.trim())
          .map(line => JSON.parse(line));
        playbackData = playbackData.concat(entries);
        playbackData.sort((a, b) => new Date(a.ts) - new Date(b.ts));
        playbackData = playbackData.filter(e => {
          const t = new Date(e.ts);
          return (!startTime || t >= startTime) && (!userEndTime || t <= userEndTime);
        });
        playbackTimes = playbackData.map(e => new Date(e.ts).getTime());
        loadedHours.add(key);
        if (playbackTimes.length) {
          const lastMs = playbackTimes[playbackTimes.length - 1];
          const timeline = document.getElementById('timeline');
          if (timeline) timeline.max = lastMs;
          const endInput = document.getElementById('endTime');
          if (endInput && endInput._flatpickr) {
            endInput._flatpickr.setDate(new Date(lastMs), true);
          }
        }
      } catch (err) {
        console.error('Failed to load log hour', err);
        loadedHours.add(key);
      }
    }

    async function ensureLoaded(ms) {
      const key = hourKey(ms);
      if (!loadedHours.has(key)) {
        await loadHour(ms);
      }
    }

    function clearMarkers() {
      for (let id in markers) { map.removeLayer(markers[id]); }
      markers = {};
      for (let id in nameMarkers) { map.removeLayer(nameMarkers[id]); }
      nameMarkers = {};
      for (let id in speedMarkers) { map.removeLayer(speedMarkers[id]); }
      speedMarkers = {};
      for (let id in blockMarkers) { map.removeLayer(blockMarkers[id]); }
      blockMarkers = {};
    }

    function drawRoutes() {
      routeLayers.forEach(layer => map.removeLayer(layer));
      routeLayers = [];
      for (let routeID in allRoutes) {
        const route = allRoutes[routeID];
        if (!route.decodedPolyline) continue;
        if (!isRouteSelected(Number(routeID))) continue;
        const color = getRouteColor(Number(routeID));
        const layer = L.polyline(route.decodedPolyline, {
          color: color,
          weight: 6,
          opacity: 1
        }).addTo(map);
        routeLayers.push(layer);
      }
    }


    function findFrameIndex(ms) {
      let idx = 0;
      for (let i = 0; i < playbackTimes.length; i++) {
        if (playbackTimes[i] <= ms) {
          idx = i;
        } else {
          break;
        }
      }
      return idx;
    }

    function showFrame(i, displayMs) {
      if (!playbackData[i]) return;
      currentFrameIndex = i;
      const entry = playbackData[i];
      const timeline = document.getElementById('timeline');
      const timeMs = (typeof displayMs !== 'undefined') ? displayMs : playbackTimes[i];
      const formatted = new Date(timeMs).toLocaleString('en-US', {timeZone: 'America/New_York'});
      timeline.value = timeMs;
      timeline.title = formatted; // show date/time when hovering the slider
      document.getElementById('timeLabel').textContent = `Showing: ${formatted}`;

      const activeRoutesSet = new Set();
      const activeBusesSet = new Set();
      entry.vehicles.forEach(v => {
        activeRoutesSet.add(v.RouteID || 0);
        activeBusesSet.add(v.VehicleID);
        const busName = v.Name ? v.Name.slice(0, -2) : '';
        if (busName) {
          allBuses[v.VehicleID] = busName;
        }
      });
      activeRoutes = activeRoutesSet;
      activeBuses = activeBusesSet;
      updateRouteSelector(activeRoutesSet);
      updateBusSelector(activeBusesSet);

      drawRoutes();
      clearMarkers();
      const blocks = entry.blocks || {};
      const seen = new Set();
      let smoothDuration = 0;
      if (playbackSpeed >= 10 && i > 0) {
        smoothDuration = (new Date(playbackData[i].ts) - new Date(playbackData[i-1].ts)) / playbackSpeed;
      }
      entry.vehicles.forEach(vehicle => {
        const routeID = vehicle.RouteID || 0;
        if (!isRouteSelected(routeID) || !isBusSelected(vehicle.VehicleID)) return;
        seen.add(vehicle.VehicleID);
        const pos = [vehicle.Latitude, vehicle.Longitude];
        const startPos = (playbackSpeed >= 10 && lastPositions[vehicle.VehicleID]) ? lastPositions[vehicle.VehicleID] : pos;
        const isMoving = vehicle.GroundSpeed > 0;
        const heading = vehicle.Heading;
        const routeColor = getRouteColor(routeID);
        const svgIcon = `
          <svg width="40" height="80" viewBox="0 0 40 80" xmlns="http://www.w3.org/2000/svg">
            <g>
              <circle cx="20" cy="20" r="15" fill="${routeColor}" stroke="white" stroke-width="3" />
              ${isMoving ? `
                <line x1="20" y1="10" x2="20" y2="22" stroke="white" stroke-width="4" stroke-linecap="round" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
                <polygon points="15,22 25,22 20,30" fill="white" style="transform: rotate(${heading + 180}deg); transform-origin: 20px 20px" />
              ` : `
                <rect x="14" y="14" width="12" height="12" fill="white" />
              `}
            </g>
          </svg>`;
        const busIcon = L.divIcon({ html: svgIcon, className: '', iconSize: [40,40], iconAnchor: [20,20] });
        const marker = L.marker(startPos, { icon: busIcon }).addTo(map);
        if (playbackSpeed >= 10 && smoothDuration > 0) {
          marker._icon.style.transition = `transform ${smoothDuration}ms linear`;
          setTimeout(() => marker.setLatLng(pos), 0);
        } else {
          marker.setLatLng(pos);
        }
        markers[vehicle.VehicleID] = marker;

        if (showLabels && showSpeed) {
          const speedBubble = `
            <svg width="60" height="20" viewBox="0 0 60 20" xmlns="http://www.w3.org/2000/svg">
              <g>
                <rect x="0" y="0" width="60" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                <text x="30" y="15" font-size="12" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${Math.round(vehicle.GroundSpeed)} MPH</text>
              </g>
            </svg>`;
          const speedIcon = L.divIcon({ html: speedBubble, className: '', iconSize: [60,20], iconAnchor: [30,-15] });
          const sm = L.marker(startPos, { icon: speedIcon, interactive: false }).addTo(map);
          if (playbackSpeed >= 10 && smoothDuration > 0) {
            sm._icon.style.transition = `transform ${smoothDuration}ms linear`;
            setTimeout(() => sm.setLatLng(pos), 0);
          } else {
            sm.setLatLng(pos);
          }
          speedMarkers[vehicle.VehicleID] = sm;
        }

        if (showLabels && showBlockNumbers) {
          const blockName = blocks[vehicle.VehicleID];
          if (blockName && blockName.includes('[')) {
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.font = 'bold 14px FGDC';
            const textWidth = ctx.measureText(blockName).width;
            const blockWidth = Math.max(40, textWidth + 20);
            const blockBubble = `
              <svg width="${blockWidth}" height="30" viewBox="0 0 ${blockWidth} 30" xmlns="http://www.w3.org/2000/svg">
                <g>
                  <rect x="0" y="5" width="${blockWidth}" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                  <text x="${blockWidth/2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${blockName}</text>
                </g>
              </svg>`;
            const blockIcon = L.divIcon({ html: blockBubble, className: '', iconSize: [blockWidth,30], iconAnchor: [blockWidth/2,-13] });
            const bm = L.marker(startPos, { icon: blockIcon, interactive: false }).addTo(map);
            if (playbackSpeed >= 10 && smoothDuration > 0) {
              bm._icon.style.transition = `transform ${smoothDuration}ms linear`;
              setTimeout(() => bm.setLatLng(pos), 0);
            } else {
              bm.setLatLng(pos);
            }
            blockMarkers[vehicle.VehicleID] = bm;
          }
        }

        const busName = vehicle.Name ? vehicle.Name.slice(0, -2) : '';
        if (showLabels && busName) {
          const bubbleWidth = Math.max(40, busName.length * 10);
          const nameBubble = `
            <svg width="${bubbleWidth}" height="30" viewBox="0 0 ${bubbleWidth} 30" xmlns="http://www.w3.org/2000/svg">
              <g>
                <rect x="0" y="5" width="${bubbleWidth}" height="20" rx="10" ry="10" fill="${routeColor}" stroke="white" stroke-width="3" />
                <text x="${bubbleWidth / 2}" y="20" font-size="14" font-weight="bold" text-anchor="middle" fill="${getContrastColor(routeColor)}" font-family="FGDC">${busName}</text>
              </g>
            </svg>`;
          const nameIcon = L.divIcon({ html: nameBubble, className: '', iconSize: [bubbleWidth,30], iconAnchor: [bubbleWidth/2,40] });
          const nm = L.marker(startPos, { icon: nameIcon, interactive: false }).addTo(map);
          if (playbackSpeed >= 10 && smoothDuration > 0) {
            nm._icon.style.transition = `transform ${smoothDuration}ms linear`;
            setTimeout(() => nm.setLatLng(pos), 0);
          } else {
            nm.setLatLng(pos);
          }
          nameMarkers[vehicle.VehicleID] = nm;
        }

        lastPositions[vehicle.VehicleID] = pos;
      });
      for (let id in lastPositions) {
        if (!seen.has(Number(id))) {
          delete lastPositions[id];
        }
      }
    }

    async function scheduleNext() {
      const current = currentFrameIndex;
      let next = current + 1;
      if (next >= playbackData.length) {
        if (endTime) {
          let ms = playbackTimes[playbackTimes.length - 1] + 1000;
          const endMs = endTime.getTime();
          while (ms <= endMs && next >= playbackData.length) {
            await loadHour(ms);
            next = current + 1;
            ms += 3600 * 1000; // step one hour forward
          }
          if (next >= playbackData.length) { pause(); return; }
        } else { pause(); return; }
      }
      const rawDelta = playbackTimes[next] - playbackTimes[current];
      const safeDelta = Math.max(rawDelta, 0);
      const maxGap = 60 * 1000; // cap wait to 60 seconds to skip long gaps quickly
      const wait = Math.min(safeDelta, maxGap) / playbackSpeed;
      timer = setTimeout(() => {
        showFrame(next);
        scheduleNext();
      }, wait);
    }

    function play() {
      pause();
      isPlaying = true;
      updateSpeedButtons();
      scheduleNext();
    }

    function pause() {
      if (timer) clearTimeout(timer);
      timer = null;
      if (isPlaying) {
        isPlaying = false;
      }
      updateSpeedButtons();
    }

    async function applyRange() {
      const dateStr = document.getElementById('datePicker').value;
      const startStr = document.getElementById('startTime').value || '00:00';
      const endStr = document.getElementById('endTime').value || '23:59';
      startTime = new Date(`${dateStr}T${startStr}:00`);
      userEndTime = new Date(`${dateStr}T${endStr}:00`);
      endTime = userEndTime;
      playbackData = [];
      playbackTimes = [];
      loadedHours = new Set();
      const timeline = document.getElementById('timeline');
      timeline.min = startTime.getTime();
      timeline.max = userEndTime.getTime();

      const startMs = startTime.getTime();
      const endMs = userEndTime.getTime();
      let ms = startMs - (startMs % (3600 * 1000));
      while (ms <= endMs) {
        await loadHour(ms);
        ms += 3600 * 1000;
      }

      if (playbackTimes.length) {
        const idx = findFrameIndex(startMs);
        showFrame(idx, startMs);
      }
    }

    playBtn.onclick = () => { playbackSpeed = 1; play(); };
    pauseBtn.onclick = pause;
    ff2Btn.onclick = () => { playbackSpeed = 2; play(); };
    ff4Btn.onclick = () => { playbackSpeed = 4; play(); };
    ff8Btn.onclick = () => { playbackSpeed = 8; play(); };
    ff10Btn.onclick = () => { playbackSpeed = 10; play(); };
    ff30Btn.onclick = () => { playbackSpeed = 30; play(); };
    ff100Btn.onclick = () => { playbackSpeed = 100; play(); };
    ff200Btn.onclick = () => { playbackSpeed = 200; play(); };
    document.getElementById('timeline').addEventListener('input', async e => {
      pause();
      const ms = parseInt(e.target.value);
      await ensureLoaded(ms);
      const idx = findFrameIndex(ms);
      showFrame(idx, ms);
    });
    document.getElementById('loadRangeBtn').onclick = () => { pause(); applyRange(); };

    pause();
    fetchRoutes().then(() => applyRange());
  </script>
</body>
</html>
