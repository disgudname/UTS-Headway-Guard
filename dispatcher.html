<!doctype html>
<meta charset="utf-8">
<title>UTS Anti-Bunching — Dispatcher</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
@font-face{font-family:'FGDC';src:url('FGDC.ttf') format('truetype')}
:root{--route-color:#2a3442}
body{font:17px 'FGDC',system-ui;margin:0;background:#0b0e11;color:#e8eef5}
header{display:flex;gap:10px;align-items:center;padding:12px 14px;border-bottom:1px solid #1f2630}
select{background:#10151c;color:#e8eef5;border:1px solid #2a3442;border-radius:10px;padding:8px 10px}
.chip{display:inline-block;border:1px solid #2a3442;border-radius:999px;padding:2px 8px;margin-left:8px;color:#cfe1ff}
table{width:100%;border-collapse:collapse;margin-top:8px}
th,td{border-bottom:1px solid #1f2630;padding:10px;text-align:left}
#blocks-table{width:auto}
#blocks td{border:none;padding:2px 4px;text-align:center;width:14ch;height:2.6em}
#blocks td .cell{border-radius:4px;background:var(--route-color,transparent);color:var(--text-color,#e8eef5);display:flex;flex-direction:column;justify-content:center;align-items:center;width:100%;height:100%}
#extra-buses{list-style:none;padding:0;margin:0;display:grid;grid-template-columns:repeat(auto-fill,minmax(6ch,1fr));gap:4px}
#extra-buses li{background:#10151c;border:1px solid #2a3442;border-radius:4px;padding:4px;text-align:center}
#extra-buses .hint{background:none;border:none;padding:0;grid-column:1/-1;text-align:left}
.mono{font-family:FGDC,ui-monospace,Menlo,Consolas,monospace}
.pill{display:inline-flex;gap:8px;align-items:center;border:1px solid #2a3442;border-radius:999px;padding:4px 8px;background:#10151c}
.dot{width:10px;height:10px;border-radius:50%}
.ok{color:#b6f0cb}.ok .dot{background:#24c28a}
.warn{color:#ffe29a}.warn .dot{background:#ffbf47}
.bad{color:#ffb0b0}.bad .dot{background:#ff6b6b}
.hint{color:#9fb0c9}
.banner{padding:8px 12px;display:none}
.banner.error{background:#3b1f1f;color:#ffbfbf;border-bottom:1px solid #5a2b2b}
.banner.info{background:#121922;color:#cfe1ff;border-bottom:1px solid #2a3442}
h2{font-size:18px;margin:16px 0 0}
</style>
<header>
  <h1 style="font-size:18px;margin:0">UTS Anti-Bunching — Dispatcher</h1>
  <label>Route: <select id="route"></select></label>
  <span id="target" class="chip">Target —</span>
  <span id="upd" class="chip">Updated —</span>
</header>
<div id="banner" class="banner info"></div>
<div style="display:flex">
  <main style="flex:1;padding:0 12px 16px">
    <h2>Headway Guard AntiBunching</h2>
    <table>
      <thead><tr>
        <th>Vehicle</th><th>Block</th><th>Order</th><th>Leader</th><th>Countdown</th>
      </tr></thead>
      <tbody id="rows"><tr><td class="hint" colspan="5">Loading…</td></tr></tbody>
    </table>
    <h2>TransLoc AntiBunching</h2>
    <table>
      <thead><tr>
        <th>Vehicle</th><th>Block</th><th>Order</th><th>Leader</th><th>Countdown</th>
      </tr></thead>
      <tbody id="rows-tl"><tr><td class="hint" colspan="5">Loading…</td></tr></tbody>
    </table>
  </main>
  <aside style="flex:1;padding:0 12px 16px;border-left:1px solid #1f2630">
    <h2>Block Assignments</h2>
    <table id="blocks-table">
      <tbody id="blocks"><tr><td class="hint">Loading…</td></tr></tbody>
    </table>
    <h2>Extra Buses</h2>
    <ul id="extra-buses"><li class="hint">Loading…</li></ul>
  </aside>
</div>
<script>
const $ = s => document.querySelector(s);
const fmt = s => { if (s==null || !isFinite(s)) return "—"; s = Math.round(s); return String(Math.floor(s/60)).padStart(2,'0')+":"+String(s%60).padStart(2,'0'); };
const pill = st => { const m = {green:["OK","ok"],yellow:["Slow Down","warn"],red:["HOLD","bad"]}; const [t,c] = m[st] || ["OK","ok"]; return '<span class="pill '+c+'"><span class="dot"></span><span>'+t+'</span></span>'; };
async function j(u){ const r = await fetch(u,{cache:"no-store"}); if(!r.ok) throw new Error(r.status); return r.json(); }
function setBanner(txt,kind){ const b=$('#banner'); if(!txt){ b.style.display='none'; b.textContent=''; return; } b.className='banner '+(kind||'info'); b.textContent=txt; b.style.display='block'; }

const tz = 'America/New_York';
const timeFormatter = new Intl.DateTimeFormat([], {
  hour: 'numeric',
  minute: '2-digit',
  second: '2-digit',
  hour12: true,
  timeZone: tz
});

function contrastColor(hex){
  if(!hex) return '#e8eef5';
  const c=hex.replace('#','');
  const r=parseInt(c.substr(0,2),16)/255;
  const g=parseInt(c.substr(2,2),16)/255;
  const b=parseInt(c.substr(4,2),16)/255;
  const l=0.2126*r+0.7152*g+0.0722*b;
  return l>0.5?'#000':'#fff';
}

let allBuses=[
  "12132","12232","12332","12432","12532","12632",
  "14132","14232","14332","14432","14532",
  "17132","17232","17332","17432","17532","17632","17732",
  "18132","18232","18332","18432","18532","18632","18732","18832",
  "19132","19232","19332","19432","19532",
  "20131","20231","20331","20431",
  "24012","24112","24212","24312","24412",
  "25131","25231","25331","25431",
];

async function loadConfig(){
  try{
    const cfg = await j('/v1/config');
    if(cfg.ALL_BUSES) allBuses = cfg.ALL_BUSES.map(b=>String(b));
  }catch(e){}
}

let activeES=null, activeIV=null, activeTL=null, currentRid=null, sessionId=0, userLocked=false, busOrder=[], lastRows=[], lastTLRows=[], blockByBus=new Map(), allBlockByBus=new Map();

function updateExtraBuses(){
  const extra=$('#extra-buses');
  const unassigned=allBuses.map(b=>String(b)).filter(b=>!allBlockByBus.has(b));
  extra.innerHTML=unassigned.length
    ? unassigned.map(b=>`<li class="mono">${b}</li>`).join('')
    : '<li class="hint">None</li>';
}

async function loadBlocks(){
  try{
    const res=await j('/v1/dispatch/blocks');
    const groups=res.block_groups||[];
    const colorByRoute=new Map(Object.entries(res.color_by_route||{}));
    const routeByBus=new Map(Object.entries(res.route_by_bus||{}));
    const tbody=$('#blocks');
    if(!groups.length){ tbody.innerHTML='<tr><td class="hint" colspan="4">No blocks.</td></tr>'; blockByBus=new Map(); allBlockByBus=new Map(); updateExtraBuses(); return; }

    const entryMap=new Map();
    const busMap=new Map();
    for(const g of groups){
      const blocks=g.Blocks||[];
      if(blocks.length){
        for(const b of blocks){
          const trip=b.Trips?.[0];
          const bus=trip?.VehicleName||'—';
          let rid=routeByBus.get(bus);
          if(rid==null) rid=trip?.RouteID||b.Route?.RouteId;
          let col=null;
          if(rid===0){
            col='#000000';
          }else if(rid){
            col=colorByRoute.get(String(rid))||trip?.RouteColor||b.Route?.Color||null;
          }else{
            col=trip?.RouteColor||b.Route?.Color||null;
          }
          if(col && !col.startsWith('#')) col='#'+col;
          let key=g.BlockGroupId;
          if(!String(key).includes('[')) key = b.BlockId || key;
          const segs=[];
          segs.push({start:b.BlockStartTime,end:b.BlockEndTime});
          for(const t of (b.Trips||[])){
            segs.push({start:t.TripStartTime||t.BlockStartTime,end:t.TripEndTime||t.BlockEndTime});
          }
          let info=entryMap.get(key);
          if(!info){
            info={block:key,bus:bus,color:col,textColor:contrastColor(col),segments:[]};
            entryMap.set(key,info);
          }else{
            if(info.bus==='—' && bus!=='—') info.bus=bus;
            if(!info.color && col){ info.color=col; info.textColor=contrastColor(col); }
          }
          info.segments.push(...segs);
          if(bus && bus!=='—'){
            let bb=busMap.get(bus);
            if(!bb){ bb={block:key,segments:[]}; busMap.set(bus,bb); }
            bb.segments.push(...segs);
          }
        }
      }else{
        const key=g.BlockGroupId;
        if(!entryMap.has(key)){
          entryMap.set(key,{block:key,bus:'—',color:null,textColor:contrastColor(null),segments:[]});
        }
      }
    }

    let entries=Array.from(entryMap.values()).filter(e=>e.block.includes('[') || e.bus!=='—');
    let busBlocks=Array.from(busMap.entries()).map(([bus,val])=>({bus,block:val.block,segments:val.segments}));
    const alias={
      "[01]":"[01]/[04]",
      "[03]":"[05]/[03]",
      "[04]":"[01]/[04]",
      "[05]":"[05]/[03]",
      "[06]":"[22]/[06]",
      "[10]":"[20]/[10]",
      "[15]":"[26]/[15]",
      "[16] AM":"[21]/[16] AM",
      "[17]":"[23]/[17]",
      "[18] AM":"[24]/[18] AM",
      "[20] AM":"[20]/[10]",
      "[21] AM":"[21]/[16] AM",
      "[22] AM":"[22]/[06]",
      "[23]":"[23]/[17]",
      "[24] AM":"[24]/[18] AM",
      "[26] AM":"[26]/[15]"
    };
    function aliasBlock(b){ const key=String(b||'').trim(); return alias[key]||key; }
    entries=entries.map(e=>({...e,block:aliasBlock(e.block)}));
    busBlocks=busBlocks.map(e=>({...e,block:aliasBlock(e.block)}));
    allBlockByBus=new Map(busBlocks.map(e=>[e.bus,e.block]));
    const seen=new Map();
    const filtered=[];
    for(const e of entries){
      if(e.block.includes('[')){
        const prev=seen.get(e.block);
        if(!prev || (prev.bus==='—' && e.bus!=='—')){
          seen.set(e.block,e);
        }
      }else{
        filtered.push(e);
      }
    }
    entries=[...filtered,...seen.values()];
    entries.sort((a,b)=>{
      function parse(s){
        s=String(s).trim();
        const letters=(s.match(/^[A-Za-z]+/)||[''])[0].toUpperCase();
        const nums=(s.match(/\d+/g)||[]).map(Number);
        return {letters,nums};
      }
      const pa=parse(a.block), pb=parse(b.block);
      if(pa.letters<pb.letters) return -1; if(pa.letters>pb.letters) return 1;
      const len=Math.max(pa.nums.length,pb.nums.length);
      for(let i=0;i<len;i++){
        const na=pa.nums[i]||0, nb=pb.nums[i]||0;
        if(na!==nb) return na-nb;
      }
      return 0;
    });
    const now=new Date();
    function parseTime(t){
      if(!t) return null;
      const m=t.match(/(\d+):(\d+)\s*(AM|PM)/i);
      if(!m) return null;
      let [_,hh,mm,ap]=m; hh=parseInt(hh,10); mm=parseInt(mm,10); ap=ap.toUpperCase();
      if(ap==='PM' && hh<12) hh+=12; if(ap==='AM' && hh===12) hh=0;
      const d=new Date(); d.setHours(hh,mm,0,0); return d;
    }
    for(const e of entries){
      const active=e.segments.some(seg=>{
        const start=parseTime(seg.start), end=parseTime(seg.end);
        return start && end && now>=start && now<=end;
      });
      if(!active){
        e.color=null;
        e.textColor=contrastColor(null);
      }
    }
    const tmp=new Map();
    for(const e of busBlocks){
      for(const seg of e.segments){
      const start=parseTime(seg.start), end=parseTime(seg.end);
      if(!start||!end) continue;
      const s=new Date(start.getTime()-30*60000);
      const f=new Date(end.getTime()+30*60000);
      if(now>=s && now<=f){
        const prev=tmp.get(e.bus);
        if(!prev || prev.start<start){ tmp.set(e.bus,{block:e.block,start}); }
      }
    }
  }
  blockByBus=new Map(Array.from(tmp.entries()).map(([bus,val])=>[bus,val.block]));
  const cols=4;
  const rows=Math.ceil(entries.length/cols);
  let html='';
    for(let r=0;r<rows;r++){
      html+='<tr>';
      for(let c=0;c<cols;c++){
        const it=entries[r+c*rows];
        html += it
          ? `<td><div class="cell" style="--route-color:${it.color || 'transparent'};--text-color:${it.textColor}"><div class="mono">${it.block}</div><div>${it.bus}</div></div></td>`
          : '<td></td>';
      }
      html+='</tr>';
    }
  if(!entries.length) html='<tr><td class="hint" colspan="4">No blocks.</td></tr>';
  tbody.innerHTML=html;
  updateExtraBuses();
  if(lastRows.length) render(lastRows);
  if(lastTLRows.length) renderTL(lastTLRows);
  }catch(e){ $('#blocks').innerHTML='<tr><td class="hint" colspan="4">Error</td></tr>'; blockByBus=new Map(); allBlockByBus=new Map(); updateExtraBuses(); }
}

async function loadRoutes(){
  const d = await j("/v1/routes");
  const list = d.routes || [];
  const active = list.filter(r => r.active_vehicles > 0).sort((a, b) => String(a.name || "").localeCompare(String(b.name || "")));
  const inactive = list.filter(r => !r.active_vehicles).sort((a, b) => String(a.name || "").localeCompare(String(b.name || "")));
  const sel = $('#route');
  const prev = currentRid;
  const combined = active.concat(inactive);
  sel.innerHTML = combined.map(r => '<option value="' + r.id + '">' + (r.name || ("Route " + r.id)) + '</option>').join("");
  if (prev) { sel.value = String(prev); }
  if (!sel.value && combined.length) { sel.value = String(combined[0].id); }
  if (!currentRid && sel.value) await start(sel.value);
}

function computeBusOrder(rows){
  const names = rows.map(r=>r.name).filter(Boolean);
  const followerOf=new Map();
  for(const r of rows){
    const leader=r.leader_name;
    if(leader && names.includes(leader)) followerOf.set(r.name, leader);
  }
  const next=new Map();
  for(const [f,l] of followerOf){ next.set(l,f); }
  const starts=names.filter(n=>!followerOf.has(n) || !names.includes(followerOf.get(n)));
  const order=[];
  const seen=new Set();
  for(const st of starts){
    let cur=st;
    while(cur && !seen.has(cur)){
      order.push(cur);
      seen.add(cur);
      cur=next.get(cur);
    }
  }
  for(const n of names) if(!seen.has(n)) order.push(n);
  return order.length?order:names.slice().sort();
}

function render(rows){
  lastRows=rows.slice();
  const t=lastRows.find(x=>x.target_headway_sec!=null)?.target_headway_sec; $('#target').textContent="Target "+(t!=null?fmt(t):"—");
  const ts = lastRows[0]?.updated_at ? new Date(lastRows[0].updated_at * 1000) : new Date();
  $('#upd').textContent = "Updated " + timeFormatter.format(ts);
  rows = rows.filter(r=>blockByBus.has(r.name));
  const onlyBus = rows.length===1 && rows.every(x=>x.headway_sec==null || x.headway_sec===undefined);

  if(!rows.length){ $('#rows').innerHTML='<tr><td class="hint" colspan="5">No vehicles.</td></tr>'; return; }

  busOrder = computeBusOrder(rows);
  const orderMap=new Map(busOrder.map((n,i)=>[n,i]));
  rows = rows.slice().sort((a,b)=>{
    const ia=orderMap.has(a.name)?orderMap.get(a.name):Infinity;
    const ib=orderMap.has(b.name)?orderMap.get(b.name):Infinity;
    if(ia!==ib) return ia-ib;
    return String(a.name||'').localeCompare(String(b.name||''));
  });

  $('#rows').innerHTML=rows.map(v=>'<tr>'
    +'<td class="mono">'+(v.name||"—")+'</td>'
    +'<td class="mono">'+(blockByBus.get(v.name)||"—")+'</td>'
    +'<td>'+ (onlyBus ? '<span class="pill ok"><span class="dot"></span><span>Only Bus</span></span>' : pill(v.status)) +'</td>'
    +'<td class="mono">'+(v.leader_name||"—")+'</td>'
    +'<td class="mono">'+(v.status!=="green"&&v.countdown_sec!=null?fmt(v.countdown_sec):"—")+'</td>'
    +'</tr>').join("");
  setBanner(onlyBus ? 'Only 1 vehicle on route — headway control inactive.' : '', 'info');
  if(lastTLRows.length) renderTL(lastTLRows);
}

function renderTL(rows){
  lastTLRows = rows.slice();
  rows = rows.filter(r=>blockByBus.has(r.VehicleName));
  if(!rows.length){ $('#rows-tl').innerHTML='<tr><td class="hint" colspan="5">No vehicles.</td></tr>'; return; }
  const orderMap=new Map(busOrder.map((n,i)=>[n,i]));
  rows = rows.slice().sort((a,b)=>{
    const ia=orderMap.has(a.VehicleName)?orderMap.get(a.VehicleName):Infinity;
    const ib=orderMap.has(b.VehicleName)?orderMap.get(b.VehicleName):Infinity;
    if(ia!==ib) return ia-ib;
    return String(a.VehicleName||'').localeCompare(String(b.VehicleName||''));
  });
  $('#rows-tl').innerHTML=rows.map(v=>{
    const sev=String(v.Severity||'').toLowerCase();
    return '<tr>'
      +'<td class="mono">'+(v.VehicleName||"—")+'</td>'
      +'<td class="mono">'+(blockByBus.get(v.VehicleName)||"—")+'</td>'
      +'<td>'+pill(sev)+'</td>'
      +'<td class="mono">—</td>'
      +'<td class="mono">'+(sev!=='green'&&v.Adjustment!=null?fmt(v.Adjustment):"—")+'</td>'
      +'</tr>';
  }).join('');
}

async function start(rid){
  rid=String(rid);
  if(activeES){ try{ activeES.close(); }catch(_){}; activeES=null; }
  if(activeIV){ clearInterval(activeIV); activeIV=null; }
  if(activeTL){ clearInterval(activeTL); activeTL=null; }
  currentRid=rid;
  const sid=++sessionId;
  try{
    const route=await j('/v1/routes/'+rid);
    const col=route && route.color ? route.color : null;
    if(col) document.documentElement.style.setProperty('--route-color', col);
  }catch(_){ document.documentElement.style.setProperty('--route-color','#2a3442'); }

  try{
    const es=new EventSource("/v1/stream/routes/"+rid);
    activeES=es;
    es.onmessage=ev=>{ if(rid!==currentRid || sid!==sessionId) return; try{ render(JSON.parse(ev.data||"[]")); }catch(_){} };
    es.onerror=_=>{ if(activeES===es){ es.close(); if(sid!==sessionId) return; activeES=null; startPoll(); } };
  }catch(_){ startPoll(); }

  function startPoll(){
    async function tick(){ if(rid!==currentRid || sid!==sessionId) return; try{ render(await j('/v1/routes/'+rid+'/status')); }catch(_){} }
    tick();
    activeIV=setInterval(tick, 10000);
  }

  function startTransloc(){
    async function tick(){
      if(rid!==currentRid || sid!==sessionId) return;
      try{
        const data=await j('/v1/transloc/anti_bunching');
        const route=(data||[]).find(r=>String(r.RouteID)===rid);
        renderTL(route?.VehicleAntiBunching||[]);
      }catch(_){ }
    }
    tick();
    activeTL=setInterval(tick, 10000);
  }

  startTransloc();
}

async function pollHealth(){
  try{ const h=await j('/v1/health'); if(!h.ok && h.last_error){ setBanner('Feed error: '+h.last_error, 'error'); }
       else{ /* keep info banner state */ } }
  catch(e){ setBanner('Health check failed', 'error'); }
  setTimeout(pollHealth, 15000);
}

document.addEventListener('DOMContentLoaded', async ()=>{ await loadConfig(); loadRoutes(); pollHealth(); loadBlocks(); setInterval(loadBlocks,30000); });
document.getElementById('route').addEventListener('change', e=> { userLocked=true; start(e.target.value); });
</script>
